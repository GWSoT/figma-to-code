
ðŸ”§ Tool: Skill
Input: {
  "skill": "superpowers:brainstorming"
}
I'll help you implement this feature for generating component prop interfaces from design variations. Let me start by exploring the codebase to understand the existing structure and context.

ðŸ”§ Tool: Task
Input: {
  "prompt": "Explore the codebase to understand:\n1. The overall project structure, especially around component generation or design-to-code functionality\n2. Any existing prop interface generation or type inference code\n3. How design variations are currently handled\n4. The patterns used for TypeScript interfaces and type generation\n5. Look for any Figma-related code or design system integration\n\nFocus on:\n- src/ directory structure\n- Any existing code for component generation\n- Type definitions and interface patterns\n- Design system or Figma integration code\n\nBe thorough in your exploration.",
  "description": "Explore codebase structure",
  "subagent_type": "Explore"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "find /home/rainman/figma-to-code/figma-to-code -type f -name \"*.md\" | head -20",
  "description": "Find documentation files"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "src/**/*.{ts,tsx}",
  "path": "/home/rainman/figma-to-code/figma-to-code"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "ls -la /home/rainman/figma-to-code/figma-to-code/src/",
  "description": "List main src directory"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "ls -la /home/rainman/figma-to-code/figma-to-code/docs/",
  "description": "List docs directory"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/docs"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/docs/architecture.md"
}

ðŸ”§ Tool: Grep
Input: {
  "pattern": "[Ff]igma|design.*system|component.*generation|type.*inference",
  "path": "/home/rainman/figma-to-code/figma-to-code",
  "type": "ts"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "find /home/rainman/figma-to-code/figma-to-code/src -name \"*figma*\" -o -name \"*design*\" -o -name \"*generate*\" -o -name \"*variation*\" 2>/dev/null | head -20",
  "description": "Find files with figma/design/generate keywords"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/package.json"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/figma-component-resolver.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/tailwind-generator.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/styled-components-generator.ts",
  "limit": 300
}

ðŸ”§ Tool: Bash
Input: {
  "command": "ls -la /home/rainman/figma-to-code/figma-to-code/src/types/",
  "description": "List types directory"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "find /home/rainman/figma-to-code/figma-to-code/src -name \"*variation*\" -o -name \"*variant*\" -o -name \"*props*\" | head -20",
  "description": "Find variation/variant related files"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/types/css-frameworks.ts",
  "limit": 200
}

ðŸ”§ Tool: Bash
Input: {
  "command": "ls -la /home/rainman/figma-to-code/figma-to-code/src/components/ | grep -E \"\\.tsx$\" | head -10",
  "description": "List sample components"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/components/ui/button.tsx",
  "limit": 100
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/figma-api.ts",
  "limit": 400
}

ðŸ”§ Tool: Grep
Input: {
  "pattern": "interface.*Props|type.*Props|interface.*Component|type.*Variant",
  "path": "/home/rainman/figma-to-code/figma-to-code/src",
  "type": "ts",
  "head_limit": 30
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/layout-analyzer.ts",
  "limit": 300
}

ðŸ”§ Tool: Bash
Input: {
  "command": "grep -r \"VariantProps\\|CVA\\|variant\" /home/rainman/figma-to-code/figma-to-code/src --include=\"*.ts\" --include=\"*.tsx\" | head -20",
  "description": "Search for variant-related patterns"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/figma-state-management.ts",
  "limit": 300
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/figma-interactive-elements.ts",
  "limit": 300
}

ðŸ”§ Tool: Bash
Input: {
  "command": "find /home/rainman/figma-to-code/figma-to-code/src -type f -name \"*.ts\" -path \"*/utils/*\" | xargs grep -l \"interface.*Props\\|type.*Props\" 2>/dev/null | head -10",
  "description": "Find prop-related utility files"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "wc -l /home/rainman/figma-to-code/figma-to-code/src/utils/*.ts | tail -1",
  "description": "Count total lines in utils"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "find /home/rainman/figma-to-code/figma-to-code/src -type f -name \"*.ts\" -o -name \"*.tsx\" | wc -l",
  "description": "Count total TypeScript files"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "head -50 /home/rainman/figma-to-code/figma-to-code/README.md",
  "description": "Check README"
}
Excellent! Now I have a comprehensive understanding of the codebase. Let me read the key existing files to understand the current patterns for variant detection and type inference:

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/figma-interactive-elements.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/figma-state-management.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/figma-component-resolver.ts"
}
Now I have a comprehensive understanding of the existing codebase. Let me also read the button component to see the CVA pattern being used:

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/components/ui/button.tsx"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "src/utils/*.ts"
}
Now I have a clear understanding of the codebase. Let me create a task list and implement the feature for generating component prop interfaces from design variations.

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Design the prop interface generator architecture",
      "status": "in_progress",
      "activeForm": "Designing the prop interface generator architecture"
    },
    {
      "content": "Create TypeScript types for prop analysis and generation",
      "status": "pending",
      "activeForm": "Creating TypeScript types for prop analysis"
    },
    {
      "content": "Implement variant property extraction from Figma data",
      "status": "pending",
      "activeForm": "Implementing variant property extraction"
    },
    {
      "content": "Implement required vs optional prop inference",
      "status": "pending",
      "activeForm": "Implementing required vs optional prop inference"
    },
    {
      "content": "Implement prop type inference from usage patterns",
      "status": "pending",
      "activeForm": "Implementing prop type inference"
    },
    {
      "content": "Implement default value and documentation generation",
      "status": "pending",
      "activeForm": "Implementing default value and documentation generation"
    },
    {
      "content": "Generate TypeScript interface code output",
      "status": "pending",
      "activeForm": "Generating TypeScript interface code output"
    },
    {
      "content": "Create Playwright verification test",
      "status": "pending",
      "activeForm": "Creating Playwright verification test"
    }
  ]
}
Now let me implement the feature. I'll create a new utility file that generates component prop interfaces from design variations:

ðŸ”§ Tool: Write
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts",
  "content": "/**\n * Component Prop Interface Generator\n *\n * Generates TypeScript prop interfaces from Figma design variations.\n * Features:\n * - Extracts variant properties from component sets\n * - Identifies required vs optional props\n * - Infers prop types from usage patterns\n * - Supports default values and documentation comments\n */\n\nimport type { FigmaNode } from \"./figma-api\";\nimport type {\n  InteractiveElementAnalysis,\n  InteractiveElementType,\n  InteractiveState,\n  VariantInfo,\n} from \"./figma-interactive-elements\";\nimport type { ResolvedComponent, ResolvedInstance } from \"./figma-component-resolver\";\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * TypeScript prop types that can be inferred\n */\nexport type InferredPropType =\n  | \"string\"\n  | \"number\"\n  | \"boolean\"\n  | \"string-literal\"\n  | \"number-literal\"\n  | \"ReactNode\"\n  | \"(() => void)\"\n  | \"((value: T) => void)\"\n  | \"React.MouseEventHandler\"\n  | \"React.ChangeEventHandler\"\n  | \"React.FormEventHandler\"\n  | \"React.KeyboardEventHandler\"\n  | \"React.FocusEventHandler\"\n  | \"CSSProperties\"\n  | \"className\"\n  | \"children\"\n  | \"ref\"\n  | \"unknown\";\n\n/**\n * Source of how a prop was inferred\n */\nexport type PropInferenceSource =\n  | \"variant-property\"\n  | \"component-property\"\n  | \"visual-analysis\"\n  | \"element-type\"\n  | \"naming-convention\"\n  | \"state-analysis\"\n  | \"content-slot\"\n  | \"default\";\n\n/**\n * A single prop definition\n */\nexport interface PropDefinition {\n  /** Prop name (camelCase) */\n  name: string;\n  /** Inferred TypeScript type */\n  type: InferredPropType;\n  /** Full TypeScript type string (may include unions, generics, etc.) */\n  typeString: string;\n  /** Whether the prop is required */\n  required: boolean;\n  /** Default value if optional */\n  defaultValue?: string;\n  /** JSDoc description */\n  description: string;\n  /** Source of inference */\n  inferenceSource: PropInferenceSource;\n  /** Confidence score (0-1) */\n  confidence: number;\n  /** Possible literal values for enum-like props */\n  possibleValues?: string[];\n  /** Related variant property name in Figma */\n  variantPropertyName?: string;\n  /** Additional JSDoc tags */\n  jsdocTags?: JsDocTag[];\n}\n\n/**\n * JSDoc tag for additional documentation\n */\nexport interface JsDocTag {\n  tag: string;\n  value: string;\n}\n\n/**\n * Generated interface result\n */\nexport interface GeneratedInterface {\n  /** Interface name (PascalCase) */\n  name: string;\n  /** Full interface code */\n  code: string;\n  /** Individual prop definitions */\n  props: PropDefinition[];\n  /** Base types the interface extends */\n  extends: string[];\n  /** Whether this is a component props interface */\n  isComponentProps: boolean;\n  /** Associated CVA variant props type if applicable */\n  cvaVariantProps?: string;\n  /** Import statements needed */\n  imports: string[];\n  /** Statistics about the generation */\n  stats: InterfaceGenerationStats;\n}\n\n/**\n * Statistics about the interface generation\n */\nexport interface InterfaceGenerationStats {\n  totalProps: number;\n  requiredProps: number;\n  optionalProps: number;\n  variantProps: number;\n  eventHandlerProps: number;\n  averageConfidence: number;\n}\n\n/**\n * Configuration for interface generation\n */\nexport interface InterfaceGenerationOptions {\n  /** Component name for naming the interface */\n  componentName: string;\n  /** Whether to extend React component props */\n  extendReactProps: boolean;\n  /** Base HTML element for extending native props */\n  baseElement?: keyof JSX.IntrinsicElements;\n  /** Whether to generate CVA (class-variance-authority) variant types */\n  generateCVATypes: boolean;\n  /** Whether to include JSDoc comments */\n  includeJSDoc: boolean;\n  /** Whether to mark all variant props as optional with defaults */\n  variantPropsOptional: boolean;\n  /** Prefix for the interface name */\n  interfacePrefix?: string;\n  /** Suffix for the interface name */\n  interfaceSuffix?: string;\n  /** Whether to export the interface */\n  exportInterface: boolean;\n  /** Whether to include ref prop for forwardRef components */\n  includeRef: boolean;\n  /** Custom prop overrides */\n  customProps?: PropDefinition[];\n}\n\nconst DEFAULT_OPTIONS: InterfaceGenerationOptions = {\n  componentName: \"Component\",\n  extendReactProps: true,\n  baseElement: \"div\",\n  generateCVATypes: true,\n  includeJSDoc: true,\n  variantPropsOptional: true,\n  exportInterface: true,\n  includeRef: false,\n};\n\n/**\n * Input for generating props from a component set\n */\nexport interface ComponentSetInput {\n  /** Component set name */\n  name: string;\n  /** Variant properties from the component set */\n  variantProperties: Record<string, string[]>;\n  /** All variants in the set */\n  variants: VariantInfo[];\n  /** Description from Figma */\n  description?: string;\n}\n\n/**\n * Input for generating props from an interactive element\n */\nexport interface InteractiveElementInput {\n  /** The interactive element analysis */\n  element: InteractiveElementAnalysis;\n  /** Resolved component information if available */\n  resolvedComponent?: ResolvedComponent;\n  /** Instance information if available */\n  resolvedInstance?: ResolvedInstance;\n}\n\n// ============================================================================\n// Variant Property Analysis\n// ============================================================================\n\n/**\n * Analyze variant properties to infer prop definitions\n */\nexport function analyzeVariantProperties(\n  variantProperties: Record<string, string[]>,\n  variants: VariantInfo[]\n): PropDefinition[] {\n  const props: PropDefinition[] = [];\n\n  for (const [propName, values] of Object.entries(variantProperties)) {\n    const prop = inferPropFromVariant(propName, values, variants);\n    if (prop) {\n      props.push(prop);\n    }\n  }\n\n  return props;\n}\n\n/**\n * Infer a prop definition from a variant property\n */\nfunction inferPropFromVariant(\n  propName: string,\n  values: string[],\n  variants: VariantInfo[]\n): PropDefinition {\n  const normalizedName = normalizeVariantPropertyName(propName);\n  const { type, typeString, possibleValues } = inferTypeFromValues(propName, values);\n  const defaultValue = findDefaultValue(propName, values, variants);\n  const description = generateVariantDescription(propName, values);\n\n  return {\n    name: normalizedName,\n    type,\n    typeString,\n    required: false, // Variant props are typically optional with defaults\n    defaultValue,\n    description,\n    inferenceSource: \"variant-property\",\n    confidence: 0.95,\n    possibleValues,\n    variantPropertyName: propName,\n    jsdocTags: [\n      { tag: \"default\", value: defaultValue || `\"${values[0]}\"` },\n    ],\n  };\n}\n\n/**\n * Normalize a Figma variant property name to a valid prop name\n */\nfunction normalizeVariantPropertyName(name: string): string {\n  // Handle common Figma naming patterns\n  // e.g., \"Size\" -> \"size\", \"Has Icon\" -> \"hasIcon\", \"Is Disabled\" -> \"isDisabled\"\n\n  return name\n    .trim()\n    .split(/[\\s-_]+/)\n    .map((word, index) => {\n      const lower = word.toLowerCase();\n      if (index === 0) {\n        return lower;\n      }\n      return lower.charAt(0).toUpperCase() + lower.slice(1);\n    })\n    .join(\"\");\n}\n\n/**\n * Infer TypeScript type from variant values\n */\nfunction inferTypeFromValues(\n  propName: string,\n  values: string[]\n): { type: InferredPropType; typeString: string; possibleValues: string[] } {\n  const lowerName = propName.toLowerCase();\n  const normalizedValues = values.map((v) => v.toLowerCase().trim());\n\n  // Check for boolean patterns\n  if (isBooleanPattern(normalizedValues)) {\n    return {\n      type: \"boolean\",\n      typeString: \"boolean\",\n      possibleValues: [\"true\", \"false\"],\n    };\n  }\n\n  // Check for number patterns\n  if (isNumberPattern(normalizedValues)) {\n    return {\n      type: \"number\",\n      typeString: \"number\",\n      possibleValues: values,\n    };\n  }\n\n  // String literal union for enum-like values\n  if (values.length > 1 && values.length <= 10) {\n    const literalType = values.map((v) => `\"${v}\"`).join(\" | \");\n    return {\n      type: \"string-literal\",\n      typeString: literalType,\n      possibleValues: values,\n    };\n  }\n\n  // Single value - still create a literal type but with string fallback\n  if (values.length === 1) {\n    return {\n      type: \"string-literal\",\n      typeString: `\"${values[0]}\"`,\n      possibleValues: values,\n    };\n  }\n\n  // Fallback to string\n  return {\n    type: \"string\",\n    typeString: \"string\",\n    possibleValues: values,\n  };\n}\n\n/**\n * Check if values represent a boolean pattern\n */\nfunction isBooleanPattern(values: string[]): boolean {\n  const booleanPairs = [\n    [\"true\", \"false\"],\n    [\"yes\", \"no\"],\n    [\"on\", \"off\"],\n    [\"enabled\", \"disabled\"],\n    [\"show\", \"hide\"],\n    [\"visible\", \"hidden\"],\n    [\"active\", \"inactive\"],\n    [\"checked\", \"unchecked\"],\n    [\"selected\", \"unselected\"],\n  ];\n\n  if (values.length !== 2) return false;\n\n  const sorted = [...values].sort();\n  return booleanPairs.some((pair) => {\n    const sortedPair = [...pair].sort();\n    return sorted[0] === sortedPair[0] && sorted[1] === sortedPair[1];\n  });\n}\n\n/**\n * Check if values represent number patterns\n */\nfunction isNumberPattern(values: string[]): boolean {\n  return values.every((v) => {\n    const num = parseFloat(v);\n    return !isNaN(num) && isFinite(num);\n  });\n}\n\n/**\n * Find the default value for a variant property\n */\nfunction findDefaultValue(\n  propName: string,\n  values: string[],\n  variants: VariantInfo[]\n): string | undefined {\n  const lowerName = propName.toLowerCase();\n\n  // Look for \"default\" state variant\n  const defaultVariant = variants.find(\n    (v) => v.state === \"default\" || v.name.toLowerCase().includes(\"default\")\n  );\n\n  if (defaultVariant && defaultVariant.properties[propName]) {\n    return `\"${defaultVariant.properties[propName]}\"`;\n  }\n\n  // Common defaults based on property name\n  if (lowerName.includes(\"size\")) {\n    if (values.includes(\"md\") || values.includes(\"medium\")) {\n      return values.includes(\"md\") ? '\"md\"' : '\"medium\"';\n    }\n    if (values.includes(\"default\")) return '\"default\"';\n  }\n\n  if (lowerName.includes(\"variant\") || lowerName.includes(\"type\") || lowerName.includes(\"style\")) {\n    if (values.includes(\"default\")) return '\"default\"';\n    if (values.includes(\"primary\")) return '\"primary\"';\n  }\n\n  // Use first value as default\n  return `\"${values[0]}\"`;\n}\n\n/**\n * Generate a description for a variant property\n */\nfunction generateVariantDescription(propName: string, values: string[]): string {\n  const normalizedName = normalizeVariantPropertyName(propName);\n\n  // Generate contextual descriptions based on property name\n  const lowerName = propName.toLowerCase();\n\n  if (lowerName.includes(\"size\")) {\n    return `The size variant of the component. Available sizes: ${values.join(\", \")}.`;\n  }\n\n  if (lowerName.includes(\"variant\") || lowerName.includes(\"style\") || lowerName.includes(\"type\")) {\n    return `The visual variant of the component. Options: ${values.join(\", \")}.`;\n  }\n\n  if (lowerName.includes(\"state\")) {\n    return `The interactive state of the component. States: ${values.join(\", \")}.`;\n  }\n\n  if (lowerName.includes(\"color\") || lowerName.includes(\"theme\")) {\n    return `The color/theme variant. Options: ${values.join(\", \")}.`;\n  }\n\n  if (lowerName.includes(\"icon\")) {\n    return `Whether to display an icon. Options: ${values.join(\", \")}.`;\n  }\n\n  if (lowerName.includes(\"disabled\")) {\n    return `Whether the component is disabled.`;\n  }\n\n  if (lowerName.includes(\"loading\")) {\n    return `Whether the component is in a loading state.`;\n  }\n\n  // Generic description\n  return `The ${normalizedName} variant of the component. Possible values: ${values.join(\", \")}.`;\n}\n\n// ============================================================================\n// Interactive Element Analysis\n// ============================================================================\n\n/**\n * Infer props from an interactive element analysis\n */\nexport function inferPropsFromInteractiveElement(\n  input: InteractiveElementInput\n): PropDefinition[] {\n  const props: PropDefinition[] = [];\n  const { element, resolvedComponent, resolvedInstance } = input;\n\n  // Add element-type specific props\n  const elementTypeProps = getPropsForElementType(element.elementType);\n  props.push(...elementTypeProps);\n\n  // Add state-based props\n  const stateProps = getPropsFromStates(element.states.map((s) => s.state));\n  props.push(...stateProps);\n\n  // Add event handler props\n  const eventProps = getEventHandlerProps(element.elementType);\n  props.push(...eventProps);\n\n  // Add component set variant props if available\n  if (element.metadata.componentSet) {\n    const variantProps = analyzeVariantProperties(\n      element.metadata.componentSet.variantProperties,\n      element.metadata.componentSet.allVariants\n    );\n    props.push(...variantProps);\n  }\n\n  // Add content slot props based on visual hints\n  const contentProps = getContentSlotProps(element);\n  props.push(...contentProps);\n\n  return deduplicateProps(props);\n}\n\n/**\n * Get props based on element type\n */\nfunction getPropsForElementType(elementType: InteractiveElementType): PropDefinition[] {\n  const props: PropDefinition[] = [];\n\n  switch (elementType) {\n    case \"button\":\n    case \"icon-button\":\n    case \"fab\":\n      props.push(\n        createProp(\"children\", \"ReactNode\", false, \"The button content.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the button is disabled.\", \"false\"),\n        createProp(\"type\", \"string-literal\", false, \"The button type.\", '\"button\"', [\n          \"button\",\n          \"submit\",\n          \"reset\",\n        ])\n      );\n      break;\n\n    case \"text-input\":\n    case \"search-input\":\n      props.push(\n        createProp(\"value\", \"string\", false, \"The input value.\"),\n        createProp(\"placeholder\", \"string\", false, \"Placeholder text when empty.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the input is disabled.\", \"false\"),\n        createProp(\"readOnly\", \"boolean\", false, \"Whether the input is read-only.\", \"false\"),\n        createProp(\"required\", \"boolean\", false, \"Whether the input is required.\", \"false\")\n      );\n      break;\n\n    case \"textarea\":\n      props.push(\n        createProp(\"value\", \"string\", false, \"The textarea value.\"),\n        createProp(\"placeholder\", \"string\", false, \"Placeholder text when empty.\"),\n        createProp(\"rows\", \"number\", false, \"Number of visible text rows.\", \"4\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the textarea is disabled.\", \"false\")\n      );\n      break;\n\n    case \"checkbox\":\n      props.push(\n        createProp(\"checked\", \"boolean\", false, \"Whether the checkbox is checked.\", \"false\"),\n        createProp(\"indeterminate\", \"boolean\", false, \"Whether in indeterminate state.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the checkbox is disabled.\", \"false\"),\n        createProp(\"label\", \"string\", false, \"Label text for the checkbox.\")\n      );\n      break;\n\n    case \"radio\":\n      props.push(\n        createProp(\"checked\", \"boolean\", false, \"Whether the radio is selected.\", \"false\"),\n        createProp(\"value\", \"string\", true, \"The value of the radio option.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the radio is disabled.\", \"false\"),\n        createProp(\"name\", \"string\", true, \"The name for grouping radio buttons.\"),\n        createProp(\"label\", \"string\", false, \"Label text for the radio button.\")\n      );\n      break;\n\n    case \"toggle\":\n    case \"switch\":\n      props.push(\n        createProp(\"checked\", \"boolean\", false, \"Whether the toggle is on.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the toggle is disabled.\", \"false\"),\n        createProp(\"label\", \"string\", false, \"Label text for the toggle.\")\n      );\n      break;\n\n    case \"select\":\n    case \"dropdown\":\n      props.push(\n        createProp(\"value\", \"string\", false, \"The selected value.\"),\n        createProp(\"options\", \"unknown\", true, \"The available options.\"),\n        createProp(\"placeholder\", \"string\", false, \"Placeholder text when no selection.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the select is disabled.\", \"false\"),\n        createProp(\"multiple\", \"boolean\", false, \"Whether multiple selection is allowed.\", \"false\")\n      );\n      break;\n\n    case \"slider\":\n    case \"range\":\n      props.push(\n        createProp(\"value\", \"number\", false, \"The current value.\", \"0\"),\n        createProp(\"min\", \"number\", false, \"Minimum value.\", \"0\"),\n        createProp(\"max\", \"number\", false, \"Maximum value.\", \"100\"),\n        createProp(\"step\", \"number\", false, \"Step increment.\", \"1\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the slider is disabled.\", \"false\")\n      );\n      break;\n\n    case \"tab\":\n      props.push(\n        createProp(\"value\", \"string\", true, \"The tab value/identifier.\"),\n        createProp(\"selected\", \"boolean\", false, \"Whether this tab is selected.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the tab is disabled.\", \"false\"),\n        createProp(\"children\", \"ReactNode\", false, \"The tab label content.\")\n      );\n      break;\n\n    case \"accordion\":\n    case \"disclosure\":\n      props.push(\n        createProp(\"expanded\", \"boolean\", false, \"Whether the section is expanded.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether it can be toggled.\", \"false\"),\n        createProp(\"title\", \"ReactNode\", true, \"The accordion header content.\"),\n        createProp(\"children\", \"ReactNode\", true, \"The expandable content.\")\n      );\n      break;\n\n    case \"dialog-trigger\":\n      props.push(\n        createProp(\"children\", \"ReactNode\", true, \"The trigger button content.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the trigger is disabled.\", \"false\")\n      );\n      break;\n\n    case \"chip\":\n    case \"tag\":\n      props.push(\n        createProp(\"children\", \"ReactNode\", true, \"The chip/tag content.\"),\n        createProp(\"selected\", \"boolean\", false, \"Whether the chip is selected.\", \"false\"),\n        createProp(\"onDelete\", \"(() => void)\", false, \"Callback when delete is clicked.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the chip is disabled.\", \"false\")\n      );\n      break;\n\n    case \"link\":\n    case \"breadcrumb-link\":\n      props.push(\n        createProp(\"href\", \"string\", true, \"The link destination URL.\"),\n        createProp(\"children\", \"ReactNode\", true, \"The link content.\"),\n        createProp(\"target\", \"string\", false, \"The link target (e.g., _blank).\")\n      );\n      break;\n\n    case \"pagination-control\":\n      props.push(\n        createProp(\"page\", \"number\", true, \"The current page number.\"),\n        createProp(\"totalPages\", \"number\", true, \"Total number of pages.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether pagination is disabled.\", \"false\")\n      );\n      break;\n\n    case \"rating\":\n      props.push(\n        createProp(\"value\", \"number\", false, \"The current rating value.\", \"0\"),\n        createProp(\"max\", \"number\", false, \"Maximum rating value.\", \"5\"),\n        createProp(\"readOnly\", \"boolean\", false, \"Whether the rating is read-only.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the rating is disabled.\", \"false\")\n      );\n      break;\n\n    case \"file-upload\":\n      props.push(\n        createProp(\"accept\", \"string\", false, \"Accepted file types.\"),\n        createProp(\"multiple\", \"boolean\", false, \"Whether multiple files allowed.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether upload is disabled.\", \"false\")\n      );\n      break;\n\n    default:\n      // Generic interactive element props\n      props.push(\n        createProp(\"children\", \"ReactNode\", false, \"The element content.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the element is disabled.\", \"false\")\n      );\n  }\n\n  return props;\n}\n\n/**\n * Get props from detected interactive states\n */\nfunction getPropsFromStates(states: InteractiveState[]): PropDefinition[] {\n  const props: PropDefinition[] = [];\n\n  if (states.includes(\"loading\")) {\n    props.push(\n      createProp(\n        \"loading\",\n        \"boolean\",\n        false,\n        \"Whether the component is in a loading state.\",\n        \"false\",\n        undefined,\n        \"state-analysis\"\n      )\n    );\n  }\n\n  if (states.includes(\"error\")) {\n    props.push(\n      createProp(\n        \"error\",\n        \"boolean\",\n        false,\n        \"Whether the component has an error.\",\n        \"false\",\n        undefined,\n        \"state-analysis\"\n      ),\n      createProp(\n        \"errorMessage\",\n        \"string\",\n        false,\n        \"Error message to display.\",\n        undefined,\n        undefined,\n        \"state-analysis\"\n      )\n    );\n  }\n\n  if (states.includes(\"success\")) {\n    props.push(\n      createProp(\n        \"success\",\n        \"boolean\",\n        false,\n        \"Whether the component shows success state.\",\n        \"false\",\n        undefined,\n        \"state-analysis\"\n      )\n    );\n  }\n\n  if (states.includes(\"warning\")) {\n    props.push(\n      createProp(\n        \"warning\",\n        \"boolean\",\n        false,\n        \"Whether the component shows a warning.\",\n        \"false\",\n        undefined,\n        \"state-analysis\"\n      )\n    );\n  }\n\n  return props;\n}\n\n/**\n * Get event handler props based on element type\n */\nfunction getEventHandlerProps(elementType: InteractiveElementType): PropDefinition[] {\n  const props: PropDefinition[] = [];\n\n  switch (elementType) {\n    case \"button\":\n    case \"icon-button\":\n    case \"fab\":\n    case \"chip\":\n    case \"tag\":\n    case \"link\":\n    case \"dialog-trigger\":\n      props.push(\n        createProp(\n          \"onClick\",\n          \"React.MouseEventHandler\",\n          false,\n          \"Click event handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"text-input\":\n    case \"search-input\":\n    case \"textarea\":\n      props.push(\n        createProp(\n          \"onChange\",\n          \"React.ChangeEventHandler\",\n          false,\n          \"Change event handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        ),\n        createProp(\n          \"onBlur\",\n          \"React.FocusEventHandler\",\n          false,\n          \"Blur event handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        ),\n        createProp(\n          \"onFocus\",\n          \"React.FocusEventHandler\",\n          false,\n          \"Focus event handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"checkbox\":\n    case \"radio\":\n    case \"toggle\":\n    case \"switch\":\n      props.push(\n        createProp(\n          \"onChange\",\n          \"((checked: boolean) => void)\",\n          false,\n          \"Change event handler with new checked value.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"select\":\n    case \"dropdown\":\n      props.push(\n        createProp(\n          \"onChange\",\n          \"((value: T) => void)\",\n          false,\n          \"Change event handler with selected value.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        ),\n        createProp(\n          \"onOpenChange\",\n          \"((open: boolean) => void)\",\n          false,\n          \"Open state change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"slider\":\n    case \"range\":\n      props.push(\n        createProp(\n          \"onChange\",\n          \"((value: number) => void)\",\n          false,\n          \"Value change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        ),\n        createProp(\n          \"onChangeEnd\",\n          \"((value: number) => void)\",\n          false,\n          \"Handler called when interaction ends.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"tab\":\n      props.push(\n        createProp(\n          \"onSelect\",\n          \"(() => void)\",\n          false,\n          \"Called when tab is selected.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"accordion\":\n    case \"disclosure\":\n      props.push(\n        createProp(\n          \"onExpandedChange\",\n          \"((expanded: boolean) => void)\",\n          false,\n          \"Expansion state change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"pagination-control\":\n      props.push(\n        createProp(\n          \"onPageChange\",\n          \"((page: number) => void)\",\n          false,\n          \"Page change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"rating\":\n      props.push(\n        createProp(\n          \"onChange\",\n          \"((rating: number) => void)\",\n          false,\n          \"Rating change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"file-upload\":\n      props.push(\n        createProp(\n          \"onFilesChange\",\n          \"((files: File[]) => void)\",\n          false,\n          \"File selection change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n  }\n\n  return props;\n}\n\n/**\n * Get content slot props based on visual hints\n */\nfunction getContentSlotProps(element: InteractiveElementAnalysis): PropDefinition[] {\n  const props: PropDefinition[] = [];\n  const { visualHints } = element.metadata;\n\n  if (visualHints.hasIcon) {\n    props.push(\n      createProp(\n        \"icon\",\n        \"ReactNode\",\n        false,\n        \"Icon element to display.\",\n        undefined,\n        undefined,\n        \"visual-analysis\"\n      ),\n      createProp(\n        \"iconPosition\",\n        \"string-literal\",\n        false,\n        \"Position of the icon relative to content.\",\n        '\"start\"',\n        [\"start\", \"end\"],\n        \"visual-analysis\"\n      )\n    );\n  }\n\n  if (visualHints.hasText && !isTextPrimaryElement(element.elementType)) {\n    props.push(\n      createProp(\n        \"label\",\n        \"string\",\n        false,\n        \"Label text to display.\",\n        undefined,\n        undefined,\n        \"visual-analysis\"\n      )\n    );\n  }\n\n  if (visualHints.hasIndicator) {\n    props.push(\n      createProp(\n        \"showIndicator\",\n        \"boolean\",\n        false,\n        \"Whether to show the state indicator.\",\n        \"false\",\n        undefined,\n        \"visual-analysis\"\n      )\n    );\n  }\n\n  return props;\n}\n\n/**\n * Check if element type primarily displays text content\n */\nfunction isTextPrimaryElement(elementType: InteractiveElementType): boolean {\n  return [\n    \"button\",\n    \"link\",\n    \"tab\",\n    \"chip\",\n    \"tag\",\n    \"breadcrumb-link\",\n  ].includes(elementType);\n}\n\n/**\n * Helper to create a prop definition\n */\nfunction createProp(\n  name: string,\n  type: InferredPropType,\n  required: boolean,\n  description: string,\n  defaultValue?: string,\n  possibleValues?: string[],\n  inferenceSource: PropInferenceSource = \"element-type\"\n): PropDefinition {\n  const typeString = getTypeString(type, possibleValues);\n\n  return {\n    name,\n    type,\n    typeString,\n    required,\n    defaultValue,\n    description,\n    inferenceSource,\n    confidence: 0.85,\n    possibleValues,\n    jsdocTags: defaultValue ? [{ tag: \"default\", value: defaultValue }] : undefined,\n  };\n}\n\n/**\n * Get the TypeScript type string for a type\n */\nfunction getTypeString(type: InferredPropType, possibleValues?: string[]): string {\n  switch (type) {\n    case \"string-literal\":\n      if (possibleValues && possibleValues.length > 0) {\n        return possibleValues.map((v) => `\"${v}\"`).join(\" | \");\n      }\n      return \"string\";\n    case \"ReactNode\":\n      return \"React.ReactNode\";\n    case \"(() => void)\":\n    case \"((value: T) => void)\":\n    case \"React.MouseEventHandler\":\n    case \"React.ChangeEventHandler\":\n    case \"React.FormEventHandler\":\n    case \"React.KeyboardEventHandler\":\n    case \"React.FocusEventHandler\":\n      return type;\n    case \"CSSProperties\":\n      return \"React.CSSProperties\";\n    case \"className\":\n      return \"string\";\n    case \"children\":\n      return \"React.ReactNode\";\n    case \"ref\":\n      return \"React.Ref<HTMLElement>\";\n    default:\n      return type;\n  }\n}\n\n/**\n * Deduplicate props by name, keeping highest confidence\n */\nfunction deduplicateProps(props: PropDefinition[]): PropDefinition[] {\n  const propMap = new Map<string, PropDefinition>();\n\n  for (const prop of props) {\n    const existing = propMap.get(prop.name);\n    if (!existing || prop.confidence > existing.confidence) {\n      propMap.set(prop.name, prop);\n    }\n  }\n\n  return Array.from(propMap.values());\n}\n\n// ============================================================================\n// Interface Code Generation\n// ============================================================================\n\n/**\n * Generate a TypeScript interface from component analysis\n */\nexport function generatePropInterface(\n  componentSetInput: ComponentSetInput | null,\n  interactiveInput: InteractiveElementInput | null,\n  options: Partial<InterfaceGenerationOptions> = {}\n): GeneratedInterface {\n  const opts: InterfaceGenerationOptions = { ...DEFAULT_OPTIONS, ...options };\n  const allProps: PropDefinition[] = [];\n  const imports: string[] = [];\n\n  // Collect props from component set\n  if (componentSetInput) {\n    const variantProps = analyzeVariantProperties(\n      componentSetInput.variantProperties,\n      componentSetInput.variants\n    );\n    allProps.push(...variantProps);\n  }\n\n  // Collect props from interactive element\n  if (interactiveInput) {\n    const elementProps = inferPropsFromInteractiveElement(interactiveInput);\n    allProps.push(...elementProps);\n  }\n\n  // Add custom props\n  if (opts.customProps) {\n    allProps.push(...opts.customProps);\n  }\n\n  // Add common props\n  allProps.push(\n    createProp(\n      \"className\",\n      \"className\",\n      false,\n      \"Additional CSS class names.\",\n      undefined,\n      undefined,\n      \"default\"\n    )\n  );\n\n  if (opts.includeRef) {\n    allProps.push(\n      createProp(\n        \"ref\",\n        \"ref\",\n        false,\n        \"Ref to the underlying DOM element.\",\n        undefined,\n        undefined,\n        \"default\"\n      )\n    );\n  }\n\n  // Deduplicate\n  const props = deduplicateProps(allProps);\n\n  // Determine imports\n  if (props.some((p) => p.typeString.includes(\"React.\"))) {\n    imports.push('import * as React from \"react\";');\n  }\n\n  // Generate interface name\n  const interfaceName = generateInterfaceName(opts);\n\n  // Generate extends clause\n  const extendsTypes = generateExtendsClause(opts, props);\n\n  // Generate CVA variant props if needed\n  let cvaVariantProps: string | undefined;\n  if (opts.generateCVATypes && componentSetInput) {\n    cvaVariantProps = generateCVAVariantProps(componentSetInput, opts);\n  }\n\n  // Generate the interface code\n  const code = generateInterfaceCode(interfaceName, props, extendsTypes, cvaVariantProps, opts);\n\n  // Calculate stats\n  const stats = calculateInterfaceStats(props);\n\n  return {\n    name: interfaceName,\n    code,\n    props,\n    extends: extendsTypes,\n    isComponentProps: true,\n    cvaVariantProps,\n    imports,\n    stats,\n  };\n}\n\n/**\n * Generate interface name from options\n */\nfunction generateInterfaceName(options: InterfaceGenerationOptions): string {\n  const prefix = options.interfacePrefix || \"\";\n  const suffix = options.interfaceSuffix || \"Props\";\n  return `${prefix}${options.componentName}${suffix}`;\n}\n\n/**\n * Generate extends clause\n */\nfunction generateExtendsClause(\n  options: InterfaceGenerationOptions,\n  props: PropDefinition[]\n): string[] {\n  const extendsTypes: string[] = [];\n\n  if (options.extendReactProps && options.baseElement) {\n    extendsTypes.push(`React.ComponentProps<\"${options.baseElement}\">`);\n  }\n\n  if (options.generateCVATypes) {\n    extendsTypes.push(`VariantProps<typeof ${options.componentName.toLowerCase()}Variants>`);\n  }\n\n  return extendsTypes;\n}\n\n/**\n * Generate CVA variant props type definition\n */\nfunction generateCVAVariantProps(\n  componentSetInput: ComponentSetInput,\n  options: InterfaceGenerationOptions\n): string {\n  const variantName = `${options.componentName.toLowerCase()}Variants`;\n  let code = \"\";\n\n  code += `const ${variantName} = cva(\\n`;\n  code += `  \"/* base classes */\",\\n`;\n  code += `  {\\n`;\n  code += `    variants: {\\n`;\n\n  for (const [propName, values] of Object.entries(componentSetInput.variantProperties)) {\n    const normalizedName = normalizeVariantPropertyName(propName);\n    code += `      ${normalizedName}: {\\n`;\n    for (const value of values) {\n      code += `        \"${value}\": \"/* ${value} styles */\",\\n`;\n    }\n    code += `      },\\n`;\n  }\n\n  code += `    },\\n`;\n  code += `    defaultVariants: {\\n`;\n\n  // Add default variants\n  for (const [propName, values] of Object.entries(componentSetInput.variantProperties)) {\n    const normalizedName = normalizeVariantPropertyName(propName);\n    const defaultValue = findDefaultValue(propName, values, componentSetInput.variants);\n    if (defaultValue) {\n      code += `      ${normalizedName}: ${defaultValue},\\n`;\n    }\n  }\n\n  code += `    },\\n`;\n  code += `  }\\n`;\n  code += `);\\n`;\n\n  return code;\n}\n\n/**\n * Generate the full interface code\n */\nfunction generateInterfaceCode(\n  interfaceName: string,\n  props: PropDefinition[],\n  extendsTypes: string[],\n  cvaVariantProps: string | undefined,\n  options: InterfaceGenerationOptions\n): string {\n  let code = \"\";\n\n  // Add CVA types if present\n  if (cvaVariantProps) {\n    code += cvaVariantProps;\n    code += \"\\n\";\n  }\n\n  // Add interface JSDoc\n  if (options.includeJSDoc) {\n    code += `/**\\n`;\n    code += ` * Props for the ${options.componentName} component.\\n`;\n    code += ` */\\n`;\n  }\n\n  // Start interface\n  const exportKeyword = options.exportInterface ? \"export \" : \"\";\n  code += `${exportKeyword}interface ${interfaceName}`;\n\n  // Add extends\n  if (extendsTypes.length > 0) {\n    code += ` extends ${extendsTypes.join(\", \")}`;\n  }\n\n  code += ` {\\n`;\n\n  // Filter out props that would be inherited from extended types\n  const propsToInclude = filterInheritedProps(props, extendsTypes, options);\n\n  // Add props\n  for (const prop of propsToInclude) {\n    // Add JSDoc for prop\n    if (options.includeJSDoc && prop.description) {\n      code += `  /**\\n`;\n      code += `   * ${prop.description}\\n`;\n      if (prop.jsdocTags) {\n        for (const tag of prop.jsdocTags) {\n          code += `   * @${tag.tag} ${tag.value}\\n`;\n        }\n      }\n      code += `   */\\n`;\n    }\n\n    // Add prop definition\n    const optionalMarker = prop.required ? \"\" : \"?\";\n    code += `  ${prop.name}${optionalMarker}: ${prop.typeString};\\n`;\n  }\n\n  code += `}\\n`;\n\n  return code;\n}\n\n/**\n * Filter out props that would be inherited from extended types\n */\nfunction filterInheritedProps(\n  props: PropDefinition[],\n  extendsTypes: string[],\n  options: InterfaceGenerationOptions\n): PropDefinition[] {\n  // If extending React component props, many common props are inherited\n  const inheritedProps = new Set<string>();\n\n  if (options.extendReactProps) {\n    // Common props inherited from HTML elements\n    inheritedProps.add(\"id\");\n    inheritedProps.add(\"style\");\n    inheritedProps.add(\"title\");\n    inheritedProps.add(\"tabIndex\");\n    inheritedProps.add(\"role\");\n    inheritedProps.add(\"aria-label\");\n    inheritedProps.add(\"aria-labelledby\");\n    inheritedProps.add(\"aria-describedby\");\n\n    // Event handlers inherited from elements\n    inheritedProps.add(\"onKeyDown\");\n    inheritedProps.add(\"onKeyUp\");\n    inheritedProps.add(\"onMouseEnter\");\n    inheritedProps.add(\"onMouseLeave\");\n  }\n\n  if (options.generateCVATypes) {\n    // Variant props are included via VariantProps<typeof variants>\n    // We keep them for documentation but they're technically inherited\n  }\n\n  return props.filter((p) => !inheritedProps.has(p.name));\n}\n\n/**\n * Calculate statistics about the generated interface\n */\nfunction calculateInterfaceStats(props: PropDefinition[]): InterfaceGenerationStats {\n  const requiredProps = props.filter((p) => p.required).length;\n  const optionalProps = props.length - requiredProps;\n  const variantProps = props.filter((p) => p.inferenceSource === \"variant-property\").length;\n  const eventHandlerProps = props.filter((p) =>\n    p.typeString.includes(\"=>\") || p.typeString.includes(\"Handler\")\n  ).length;\n  const averageConfidence =\n    props.length > 0\n      ? props.reduce((sum, p) => sum + p.confidence, 0) / props.length\n      : 0;\n\n  return {\n    totalProps: props.length,\n    requiredProps,\n    optionalProps,\n    variantProps,\n    eventHandlerProps,\n    averageConfidence,\n  };\n}\n\n// ============================================================================\n// High-Level API\n// ============================================================================\n\n/**\n * Generate prop interfaces from a Figma component set\n */\nexport function generateInterfaceFromComponentSet(\n  componentSet: {\n    name: string;\n    variantProperties: Record<string, string[]>;\n    variants: VariantInfo[];\n    description?: string;\n  },\n  options?: Partial<InterfaceGenerationOptions>\n): GeneratedInterface {\n  const opts = {\n    ...options,\n    componentName: options?.componentName || sanitizeComponentName(componentSet.name),\n  };\n\n  return generatePropInterface(componentSet, null, opts);\n}\n\n/**\n * Generate prop interfaces from an interactive element analysis\n */\nexport function generateInterfaceFromElement(\n  element: InteractiveElementAnalysis,\n  resolvedComponent?: ResolvedComponent,\n  resolvedInstance?: ResolvedInstance,\n  options?: Partial<InterfaceGenerationOptions>\n): GeneratedInterface {\n  const componentName =\n    options?.componentName ||\n    (resolvedComponent\n      ? sanitizeComponentName(resolvedComponent.name)\n      : sanitizeComponentName(element.nodeName));\n\n  const opts = { ...options, componentName };\n\n  return generatePropInterface(\n    element.metadata.componentSet\n      ? {\n          name: element.metadata.componentSet.name,\n          variantProperties: element.metadata.componentSet.variantProperties,\n          variants: element.metadata.componentSet.allVariants,\n        }\n      : null,\n    { element, resolvedComponent, resolvedInstance },\n    opts\n  );\n}\n\n/**\n * Sanitize a component name for use in TypeScript\n */\nfunction sanitizeComponentName(name: string): string {\n  return name\n    .replace(/[^a-zA-Z0-9]/g, \" \")\n    .trim()\n    .split(/\\s+/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(\"\");\n}\n\n/**\n * Generate multiple interfaces from a collection of components\n */\nexport function generateInterfacesFromComponents(\n  components: Array<{\n    componentSet?: ComponentSetInput;\n    interactiveElement?: InteractiveElementInput;\n    options?: Partial<InterfaceGenerationOptions>;\n  }>\n): GeneratedInterface[] {\n  return components.map((component) =>\n    generatePropInterface(\n      component.componentSet || null,\n      component.interactiveElement || null,\n      component.options\n    )\n  );\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport {\n  analyzeVariantProperties,\n  inferPropsFromInteractiveElement,\n  generatePropInterface,\n  generateInterfaceFromComponentSet,\n  generateInterfaceFromElement,\n  generateInterfacesFromComponents,\n  normalizeVariantPropertyName,\n  sanitizeComponentName,\n};\n"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Design the prop interface generator architecture",
      "status": "completed",
      "activeForm": "Designing the prop interface generator architecture"
    },
    {
      "content": "Create TypeScript types for prop analysis and generation",
      "status": "completed",
      "activeForm": "Creating TypeScript types for prop analysis"
    },
    {
      "content": "Implement variant property extraction from Figma data",
      "status": "completed",
      "activeForm": "Implementing variant property extraction"
    },
    {
      "content": "Implement required vs optional prop inference",
      "status": "completed",
      "activeForm": "Implementing required vs optional prop inference"
    },
    {
      "content": "Implement prop type inference from usage patterns",
      "status": "completed",
      "activeForm": "Implementing prop type inference"
    },
    {
      "content": "Implement default value and documentation generation",
      "status": "completed",
      "activeForm": "Implementing default value and documentation generation"
    },
    {
      "content": "Generate TypeScript interface code output",
      "status": "completed",
      "activeForm": "Generating TypeScript interface code output"
    },
    {
      "content": "Create Playwright verification test",
      "status": "in_progress",
      "activeForm": "Creating Playwright verification test"
    }
  ]
}
Now let me verify the implementation compiles correctly by checking TypeScript:

ðŸ”§ Tool: Bash
Input: {
  "command": "npx tsc --noEmit src/utils/prop-interface-generator.ts 2>&1 | head -50",
  "description": "Type check the new file",
  "timeout": 60000
}
Let me fix the TypeScript issues:

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts",
  "offset": 1,
  "limit": 100
}
I need to fix several issues. Let me rewrite the file with the corrections:

ðŸ”§ Tool: Write
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts",
  "content": "/**\n * Component Prop Interface Generator\n *\n * Generates TypeScript prop interfaces from Figma design variations.\n * Features:\n * - Extracts variant properties from component sets\n * - Identifies required vs optional props\n * - Infers prop types from usage patterns\n * - Supports default values and documentation comments\n */\n\nimport type {\n  InteractiveElementAnalysis,\n  InteractiveElementType,\n  InteractiveState,\n  VariantInfo,\n} from \"./figma-interactive-elements\";\nimport type { ResolvedComponent, ResolvedInstance } from \"./figma-component-resolver\";\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * TypeScript prop types that can be inferred\n */\nexport type InferredPropType =\n  | \"string\"\n  | \"number\"\n  | \"boolean\"\n  | \"string-literal\"\n  | \"number-literal\"\n  | \"ReactNode\"\n  | \"function\"\n  | \"eventHandler\"\n  | \"CSSProperties\"\n  | \"className\"\n  | \"children\"\n  | \"ref\"\n  | \"unknown\";\n\n/**\n * Source of how a prop was inferred\n */\nexport type PropInferenceSource =\n  | \"variant-property\"\n  | \"component-property\"\n  | \"visual-analysis\"\n  | \"element-type\"\n  | \"naming-convention\"\n  | \"state-analysis\"\n  | \"content-slot\"\n  | \"default\";\n\n/**\n * A single prop definition\n */\nexport interface PropDefinition {\n  /** Prop name (camelCase) */\n  name: string;\n  /** Inferred TypeScript type */\n  type: InferredPropType;\n  /** Full TypeScript type string (may include unions, generics, etc.) */\n  typeString: string;\n  /** Whether the prop is required */\n  required: boolean;\n  /** Default value if optional */\n  defaultValue?: string;\n  /** JSDoc description */\n  description: string;\n  /** Source of inference */\n  inferenceSource: PropInferenceSource;\n  /** Confidence score (0-1) */\n  confidence: number;\n  /** Possible literal values for enum-like props */\n  possibleValues?: string[];\n  /** Related variant property name in Figma */\n  variantPropertyName?: string;\n  /** Additional JSDoc tags */\n  jsdocTags?: JsDocTag[];\n}\n\n/**\n * JSDoc tag for additional documentation\n */\nexport interface JsDocTag {\n  tag: string;\n  value: string;\n}\n\n/**\n * Generated interface result\n */\nexport interface GeneratedInterface {\n  /** Interface name (PascalCase) */\n  name: string;\n  /** Full interface code */\n  code: string;\n  /** Individual prop definitions */\n  props: PropDefinition[];\n  /** Base types the interface extends */\n  extends: string[];\n  /** Whether this is a component props interface */\n  isComponentProps: boolean;\n  /** Associated CVA variant props type if applicable */\n  cvaVariantProps?: string;\n  /** Import statements needed */\n  imports: string[];\n  /** Statistics about the generation */\n  stats: InterfaceGenerationStats;\n}\n\n/**\n * Statistics about the interface generation\n */\nexport interface InterfaceGenerationStats {\n  totalProps: number;\n  requiredProps: number;\n  optionalProps: number;\n  variantProps: number;\n  eventHandlerProps: number;\n  averageConfidence: number;\n}\n\n/**\n * Supported base HTML element types\n */\nexport type BaseElementType =\n  | \"div\"\n  | \"span\"\n  | \"button\"\n  | \"input\"\n  | \"a\"\n  | \"form\"\n  | \"label\"\n  | \"select\"\n  | \"textarea\"\n  | \"img\"\n  | \"ul\"\n  | \"li\"\n  | \"nav\"\n  | \"header\"\n  | \"footer\"\n  | \"main\"\n  | \"section\"\n  | \"article\";\n\n/**\n * Configuration for interface generation\n */\nexport interface InterfaceGenerationOptions {\n  /** Component name for naming the interface */\n  componentName: string;\n  /** Whether to extend React component props */\n  extendReactProps: boolean;\n  /** Base HTML element for extending native props */\n  baseElement?: BaseElementType;\n  /** Whether to generate CVA (class-variance-authority) variant types */\n  generateCVATypes: boolean;\n  /** Whether to include JSDoc comments */\n  includeJSDoc: boolean;\n  /** Whether to mark all variant props as optional with defaults */\n  variantPropsOptional: boolean;\n  /** Prefix for the interface name */\n  interfacePrefix?: string;\n  /** Suffix for the interface name */\n  interfaceSuffix?: string;\n  /** Whether to export the interface */\n  exportInterface: boolean;\n  /** Whether to include ref prop for forwardRef components */\n  includeRef: boolean;\n  /** Custom prop overrides */\n  customProps?: PropDefinition[];\n}\n\nconst DEFAULT_OPTIONS: InterfaceGenerationOptions = {\n  componentName: \"Component\",\n  extendReactProps: true,\n  baseElement: \"div\",\n  generateCVATypes: true,\n  includeJSDoc: true,\n  variantPropsOptional: true,\n  exportInterface: true,\n  includeRef: false,\n};\n\n/**\n * Input for generating props from a component set\n */\nexport interface ComponentSetInput {\n  /** Component set name */\n  name: string;\n  /** Variant properties from the component set */\n  variantProperties: Record<string, string[]>;\n  /** All variants in the set */\n  variants: VariantInfo[];\n  /** Description from Figma */\n  description?: string;\n}\n\n/**\n * Input for generating props from an interactive element\n */\nexport interface InteractiveElementInput {\n  /** The interactive element analysis */\n  element: InteractiveElementAnalysis;\n  /** Resolved component information if available */\n  resolvedComponent?: ResolvedComponent;\n  /** Instance information if available */\n  resolvedInstance?: ResolvedInstance;\n}\n\n// ============================================================================\n// Variant Property Analysis\n// ============================================================================\n\n/**\n * Analyze variant properties to infer prop definitions\n */\nfunction analyzeVariantPropertiesImpl(\n  variantProperties: Record<string, string[]>,\n  variants: VariantInfo[]\n): PropDefinition[] {\n  const props: PropDefinition[] = [];\n\n  for (const [propName, values] of Object.entries(variantProperties)) {\n    const prop = inferPropFromVariant(propName, values, variants);\n    if (prop) {\n      props.push(prop);\n    }\n  }\n\n  return props;\n}\n\n/**\n * Infer a prop definition from a variant property\n */\nfunction inferPropFromVariant(\n  propName: string,\n  values: string[],\n  variants: VariantInfo[]\n): PropDefinition {\n  const normalizedName = normalizeVariantPropertyNameImpl(propName);\n  const { type, typeString, possibleValues } = inferTypeFromValues(propName, values);\n  const defaultValue = findDefaultValue(propName, values, variants);\n  const description = generateVariantDescription(propName, values);\n\n  return {\n    name: normalizedName,\n    type,\n    typeString,\n    required: false, // Variant props are typically optional with defaults\n    defaultValue,\n    description,\n    inferenceSource: \"variant-property\",\n    confidence: 0.95,\n    possibleValues,\n    variantPropertyName: propName,\n    jsdocTags: [\n      { tag: \"default\", value: defaultValue || `\"${values[0]}\"` },\n    ],\n  };\n}\n\n/**\n * Normalize a Figma variant property name to a valid prop name\n */\nfunction normalizeVariantPropertyNameImpl(name: string): string {\n  // Handle common Figma naming patterns\n  // e.g., \"Size\" -> \"size\", \"Has Icon\" -> \"hasIcon\", \"Is Disabled\" -> \"isDisabled\"\n\n  return name\n    .trim()\n    .split(/[\\s-_]+/)\n    .map((word, index) => {\n      const lower = word.toLowerCase();\n      if (index === 0) {\n        return lower;\n      }\n      return lower.charAt(0).toUpperCase() + lower.slice(1);\n    })\n    .join(\"\");\n}\n\n/**\n * Infer TypeScript type from variant values\n */\nfunction inferTypeFromValues(\n  propName: string,\n  values: string[]\n): { type: InferredPropType; typeString: string; possibleValues: string[] } {\n  const normalizedValues = values.map((v) => v.toLowerCase().trim());\n\n  // Check for boolean patterns\n  if (isBooleanPattern(normalizedValues)) {\n    return {\n      type: \"boolean\",\n      typeString: \"boolean\",\n      possibleValues: [\"true\", \"false\"],\n    };\n  }\n\n  // Check for number patterns\n  if (isNumberPattern(normalizedValues)) {\n    return {\n      type: \"number\",\n      typeString: \"number\",\n      possibleValues: values,\n    };\n  }\n\n  // String literal union for enum-like values\n  if (values.length > 1 && values.length <= 10) {\n    const literalType = values.map((v) => `\"${v}\"`).join(\" | \");\n    return {\n      type: \"string-literal\",\n      typeString: literalType,\n      possibleValues: values,\n    };\n  }\n\n  // Single value - still create a literal type but with string fallback\n  if (values.length === 1) {\n    return {\n      type: \"string-literal\",\n      typeString: `\"${values[0]}\"`,\n      possibleValues: values,\n    };\n  }\n\n  // Fallback to string\n  return {\n    type: \"string\",\n    typeString: \"string\",\n    possibleValues: values,\n  };\n}\n\n/**\n * Check if values represent a boolean pattern\n */\nfunction isBooleanPattern(values: string[]): boolean {\n  const booleanPairs = [\n    [\"true\", \"false\"],\n    [\"yes\", \"no\"],\n    [\"on\", \"off\"],\n    [\"enabled\", \"disabled\"],\n    [\"show\", \"hide\"],\n    [\"visible\", \"hidden\"],\n    [\"active\", \"inactive\"],\n    [\"checked\", \"unchecked\"],\n    [\"selected\", \"unselected\"],\n  ];\n\n  if (values.length !== 2) return false;\n\n  const sorted = [...values].sort();\n  return booleanPairs.some((pair) => {\n    const sortedPair = [...pair].sort();\n    return sorted[0] === sortedPair[0] && sorted[1] === sortedPair[1];\n  });\n}\n\n/**\n * Check if values represent number patterns\n */\nfunction isNumberPattern(values: string[]): boolean {\n  return values.every((v) => {\n    const num = parseFloat(v);\n    return !isNaN(num) && isFinite(num);\n  });\n}\n\n/**\n * Find the default value for a variant property\n */\nfunction findDefaultValue(\n  propName: string,\n  values: string[],\n  variants: VariantInfo[]\n): string | undefined {\n  const lowerName = propName.toLowerCase();\n\n  // Look for \"default\" state variant\n  const defaultVariant = variants.find(\n    (v) => v.state === \"default\" || v.name.toLowerCase().includes(\"default\")\n  );\n\n  if (defaultVariant && defaultVariant.properties[propName]) {\n    return `\"${defaultVariant.properties[propName]}\"`;\n  }\n\n  // Common defaults based on property name\n  if (lowerName.includes(\"size\")) {\n    if (values.includes(\"md\") || values.includes(\"medium\")) {\n      return values.includes(\"md\") ? '\"md\"' : '\"medium\"';\n    }\n    if (values.includes(\"default\")) return '\"default\"';\n  }\n\n  if (lowerName.includes(\"variant\") || lowerName.includes(\"type\") || lowerName.includes(\"style\")) {\n    if (values.includes(\"default\")) return '\"default\"';\n    if (values.includes(\"primary\")) return '\"primary\"';\n  }\n\n  // Use first value as default\n  return `\"${values[0]}\"`;\n}\n\n/**\n * Generate a description for a variant property\n */\nfunction generateVariantDescription(propName: string, values: string[]): string {\n  const normalizedName = normalizeVariantPropertyNameImpl(propName);\n\n  // Generate contextual descriptions based on property name\n  const lowerName = propName.toLowerCase();\n\n  if (lowerName.includes(\"size\")) {\n    return `The size variant of the component. Available sizes: ${values.join(\", \")}.`;\n  }\n\n  if (lowerName.includes(\"variant\") || lowerName.includes(\"style\") || lowerName.includes(\"type\")) {\n    return `The visual variant of the component. Options: ${values.join(\", \")}.`;\n  }\n\n  if (lowerName.includes(\"state\")) {\n    return `The interactive state of the component. States: ${values.join(\", \")}.`;\n  }\n\n  if (lowerName.includes(\"color\") || lowerName.includes(\"theme\")) {\n    return `The color/theme variant. Options: ${values.join(\", \")}.`;\n  }\n\n  if (lowerName.includes(\"icon\")) {\n    return `Whether to display an icon. Options: ${values.join(\", \")}.`;\n  }\n\n  if (lowerName.includes(\"disabled\")) {\n    return `Whether the component is disabled.`;\n  }\n\n  if (lowerName.includes(\"loading\")) {\n    return `Whether the component is in a loading state.`;\n  }\n\n  // Generic description\n  return `The ${normalizedName} variant of the component. Possible values: ${values.join(\", \")}.`;\n}\n\n// ============================================================================\n// Interactive Element Analysis\n// ============================================================================\n\n/**\n * Infer props from an interactive element analysis\n */\nfunction inferPropsFromInteractiveElementImpl(\n  input: InteractiveElementInput\n): PropDefinition[] {\n  const props: PropDefinition[] = [];\n  const { element } = input;\n\n  // Add element-type specific props\n  const elementTypeProps = getPropsForElementType(element.elementType);\n  props.push(...elementTypeProps);\n\n  // Add state-based props\n  const stateProps = getPropsFromStates(element.states.map((s) => s.state));\n  props.push(...stateProps);\n\n  // Add event handler props\n  const eventProps = getEventHandlerProps(element.elementType);\n  props.push(...eventProps);\n\n  // Add component set variant props if available\n  if (element.metadata.componentSet) {\n    const variantProps = analyzeVariantPropertiesImpl(\n      element.metadata.componentSet.variantProperties,\n      element.metadata.componentSet.allVariants\n    );\n    props.push(...variantProps);\n  }\n\n  // Add content slot props based on visual hints\n  const contentProps = getContentSlotProps(element);\n  props.push(...contentProps);\n\n  return deduplicateProps(props);\n}\n\n/**\n * Get props based on element type\n */\nfunction getPropsForElementType(elementType: InteractiveElementType): PropDefinition[] {\n  const props: PropDefinition[] = [];\n\n  switch (elementType) {\n    case \"button\":\n    case \"icon-button\":\n    case \"fab\":\n      props.push(\n        createProp(\"children\", \"ReactNode\", false, \"The button content.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the button is disabled.\", \"false\"),\n        createProp(\"type\", \"string-literal\", false, \"The button type.\", '\"button\"', [\n          \"button\",\n          \"submit\",\n          \"reset\",\n        ])\n      );\n      break;\n\n    case \"text-input\":\n    case \"search-input\":\n      props.push(\n        createProp(\"value\", \"string\", false, \"The input value.\"),\n        createProp(\"placeholder\", \"string\", false, \"Placeholder text when empty.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the input is disabled.\", \"false\"),\n        createProp(\"readOnly\", \"boolean\", false, \"Whether the input is read-only.\", \"false\"),\n        createProp(\"required\", \"boolean\", false, \"Whether the input is required.\", \"false\")\n      );\n      break;\n\n    case \"textarea\":\n      props.push(\n        createProp(\"value\", \"string\", false, \"The textarea value.\"),\n        createProp(\"placeholder\", \"string\", false, \"Placeholder text when empty.\"),\n        createProp(\"rows\", \"number\", false, \"Number of visible text rows.\", \"4\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the textarea is disabled.\", \"false\")\n      );\n      break;\n\n    case \"checkbox\":\n      props.push(\n        createProp(\"checked\", \"boolean\", false, \"Whether the checkbox is checked.\", \"false\"),\n        createProp(\"indeterminate\", \"boolean\", false, \"Whether in indeterminate state.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the checkbox is disabled.\", \"false\"),\n        createProp(\"label\", \"string\", false, \"Label text for the checkbox.\")\n      );\n      break;\n\n    case \"radio\":\n      props.push(\n        createProp(\"checked\", \"boolean\", false, \"Whether the radio is selected.\", \"false\"),\n        createProp(\"value\", \"string\", true, \"The value of the radio option.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the radio is disabled.\", \"false\"),\n        createProp(\"name\", \"string\", true, \"The name for grouping radio buttons.\"),\n        createProp(\"label\", \"string\", false, \"Label text for the radio button.\")\n      );\n      break;\n\n    case \"toggle\":\n    case \"switch\":\n      props.push(\n        createProp(\"checked\", \"boolean\", false, \"Whether the toggle is on.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the toggle is disabled.\", \"false\"),\n        createProp(\"label\", \"string\", false, \"Label text for the toggle.\")\n      );\n      break;\n\n    case \"select\":\n    case \"dropdown\":\n      props.push(\n        createProp(\"value\", \"string\", false, \"The selected value.\"),\n        createProp(\"options\", \"unknown\", true, \"The available options.\"),\n        createProp(\"placeholder\", \"string\", false, \"Placeholder text when no selection.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the select is disabled.\", \"false\"),\n        createProp(\"multiple\", \"boolean\", false, \"Whether multiple selection is allowed.\", \"false\")\n      );\n      break;\n\n    case \"slider\":\n    case \"range\":\n      props.push(\n        createProp(\"value\", \"number\", false, \"The current value.\", \"0\"),\n        createProp(\"min\", \"number\", false, \"Minimum value.\", \"0\"),\n        createProp(\"max\", \"number\", false, \"Maximum value.\", \"100\"),\n        createProp(\"step\", \"number\", false, \"Step increment.\", \"1\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the slider is disabled.\", \"false\")\n      );\n      break;\n\n    case \"tab\":\n      props.push(\n        createProp(\"value\", \"string\", true, \"The tab value/identifier.\"),\n        createProp(\"selected\", \"boolean\", false, \"Whether this tab is selected.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the tab is disabled.\", \"false\"),\n        createProp(\"children\", \"ReactNode\", false, \"The tab label content.\")\n      );\n      break;\n\n    case \"accordion\":\n    case \"disclosure\":\n      props.push(\n        createProp(\"expanded\", \"boolean\", false, \"Whether the section is expanded.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether it can be toggled.\", \"false\"),\n        createProp(\"title\", \"ReactNode\", true, \"The accordion header content.\"),\n        createProp(\"children\", \"ReactNode\", true, \"The expandable content.\")\n      );\n      break;\n\n    case \"dialog-trigger\":\n      props.push(\n        createProp(\"children\", \"ReactNode\", true, \"The trigger button content.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the trigger is disabled.\", \"false\")\n      );\n      break;\n\n    case \"chip\":\n    case \"tag\":\n      props.push(\n        createProp(\"children\", \"ReactNode\", true, \"The chip/tag content.\"),\n        createProp(\"selected\", \"boolean\", false, \"Whether the chip is selected.\", \"false\"),\n        createProp(\"onDelete\", \"function\", false, \"Callback when delete is clicked.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the chip is disabled.\", \"false\")\n      );\n      break;\n\n    case \"link\":\n    case \"breadcrumb-link\":\n      props.push(\n        createProp(\"href\", \"string\", true, \"The link destination URL.\"),\n        createProp(\"children\", \"ReactNode\", true, \"The link content.\"),\n        createProp(\"target\", \"string\", false, \"The link target (e.g., _blank).\")\n      );\n      break;\n\n    case \"pagination-control\":\n      props.push(\n        createProp(\"page\", \"number\", true, \"The current page number.\"),\n        createProp(\"totalPages\", \"number\", true, \"Total number of pages.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether pagination is disabled.\", \"false\")\n      );\n      break;\n\n    case \"rating\":\n      props.push(\n        createProp(\"value\", \"number\", false, \"The current rating value.\", \"0\"),\n        createProp(\"max\", \"number\", false, \"Maximum rating value.\", \"5\"),\n        createProp(\"readOnly\", \"boolean\", false, \"Whether the rating is read-only.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the rating is disabled.\", \"false\")\n      );\n      break;\n\n    case \"file-upload\":\n      props.push(\n        createProp(\"accept\", \"string\", false, \"Accepted file types.\"),\n        createProp(\"multiple\", \"boolean\", false, \"Whether multiple files allowed.\", \"false\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether upload is disabled.\", \"false\")\n      );\n      break;\n\n    default:\n      // Generic interactive element props\n      props.push(\n        createProp(\"children\", \"ReactNode\", false, \"The element content.\"),\n        createProp(\"disabled\", \"boolean\", false, \"Whether the element is disabled.\", \"false\")\n      );\n  }\n\n  return props;\n}\n\n/**\n * Get props from detected interactive states\n */\nfunction getPropsFromStates(states: InteractiveState[]): PropDefinition[] {\n  const props: PropDefinition[] = [];\n\n  if (states.includes(\"loading\")) {\n    props.push(\n      createProp(\n        \"loading\",\n        \"boolean\",\n        false,\n        \"Whether the component is in a loading state.\",\n        \"false\",\n        undefined,\n        \"state-analysis\"\n      )\n    );\n  }\n\n  if (states.includes(\"error\")) {\n    props.push(\n      createProp(\n        \"error\",\n        \"boolean\",\n        false,\n        \"Whether the component has an error.\",\n        \"false\",\n        undefined,\n        \"state-analysis\"\n      ),\n      createProp(\n        \"errorMessage\",\n        \"string\",\n        false,\n        \"Error message to display.\",\n        undefined,\n        undefined,\n        \"state-analysis\"\n      )\n    );\n  }\n\n  if (states.includes(\"success\")) {\n    props.push(\n      createProp(\n        \"success\",\n        \"boolean\",\n        false,\n        \"Whether the component shows success state.\",\n        \"false\",\n        undefined,\n        \"state-analysis\"\n      )\n    );\n  }\n\n  if (states.includes(\"warning\")) {\n    props.push(\n      createProp(\n        \"warning\",\n        \"boolean\",\n        false,\n        \"Whether the component shows a warning.\",\n        \"false\",\n        undefined,\n        \"state-analysis\"\n      )\n    );\n  }\n\n  return props;\n}\n\n/**\n * Get event handler props based on element type\n */\nfunction getEventHandlerProps(elementType: InteractiveElementType): PropDefinition[] {\n  const props: PropDefinition[] = [];\n\n  switch (elementType) {\n    case \"button\":\n    case \"icon-button\":\n    case \"fab\":\n    case \"chip\":\n    case \"tag\":\n    case \"link\":\n    case \"dialog-trigger\":\n      props.push(\n        createProp(\n          \"onClick\",\n          \"eventHandler\",\n          false,\n          \"Click event handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"text-input\":\n    case \"search-input\":\n    case \"textarea\":\n      props.push(\n        createProp(\n          \"onChange\",\n          \"eventHandler\",\n          false,\n          \"Change event handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        ),\n        createProp(\n          \"onBlur\",\n          \"eventHandler\",\n          false,\n          \"Blur event handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        ),\n        createProp(\n          \"onFocus\",\n          \"eventHandler\",\n          false,\n          \"Focus event handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"checkbox\":\n    case \"radio\":\n    case \"toggle\":\n    case \"switch\":\n      props.push(\n        createProp(\n          \"onChange\",\n          \"function\",\n          false,\n          \"Change event handler with new checked value.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"select\":\n    case \"dropdown\":\n      props.push(\n        createProp(\n          \"onChange\",\n          \"function\",\n          false,\n          \"Change event handler with selected value.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        ),\n        createProp(\n          \"onOpenChange\",\n          \"function\",\n          false,\n          \"Open state change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"slider\":\n    case \"range\":\n      props.push(\n        createProp(\n          \"onChange\",\n          \"function\",\n          false,\n          \"Value change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        ),\n        createProp(\n          \"onChangeEnd\",\n          \"function\",\n          false,\n          \"Handler called when interaction ends.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"tab\":\n      props.push(\n        createProp(\n          \"onSelect\",\n          \"function\",\n          false,\n          \"Called when tab is selected.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"accordion\":\n    case \"disclosure\":\n      props.push(\n        createProp(\n          \"onExpandedChange\",\n          \"function\",\n          false,\n          \"Expansion state change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"pagination-control\":\n      props.push(\n        createProp(\n          \"onPageChange\",\n          \"function\",\n          false,\n          \"Page change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"rating\":\n      props.push(\n        createProp(\n          \"onChange\",\n          \"function\",\n          false,\n          \"Rating change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n\n    case \"file-upload\":\n      props.push(\n        createProp(\n          \"onFilesChange\",\n          \"function\",\n          false,\n          \"File selection change handler.\",\n          undefined,\n          undefined,\n          \"element-type\"\n        )\n      );\n      break;\n  }\n\n  return props;\n}\n\n/**\n * Get content slot props based on visual hints\n */\nfunction getContentSlotProps(element: InteractiveElementAnalysis): PropDefinition[] {\n  const props: PropDefinition[] = [];\n  const { visualHints } = element.metadata;\n\n  if (visualHints.hasIcon) {\n    props.push(\n      createProp(\n        \"icon\",\n        \"ReactNode\",\n        false,\n        \"Icon element to display.\",\n        undefined,\n        undefined,\n        \"visual-analysis\"\n      ),\n      createProp(\n        \"iconPosition\",\n        \"string-literal\",\n        false,\n        \"Position of the icon relative to content.\",\n        '\"start\"',\n        [\"start\", \"end\"],\n        \"visual-analysis\"\n      )\n    );\n  }\n\n  if (visualHints.hasText && !isTextPrimaryElement(element.elementType)) {\n    props.push(\n      createProp(\n        \"label\",\n        \"string\",\n        false,\n        \"Label text to display.\",\n        undefined,\n        undefined,\n        \"visual-analysis\"\n      )\n    );\n  }\n\n  if (visualHints.hasIndicator) {\n    props.push(\n      createProp(\n        \"showIndicator\",\n        \"boolean\",\n        false,\n        \"Whether to show the state indicator.\",\n        \"false\",\n        undefined,\n        \"visual-analysis\"\n      )\n    );\n  }\n\n  return props;\n}\n\n/**\n * Check if element type primarily displays text content\n */\nfunction isTextPrimaryElement(elementType: InteractiveElementType): boolean {\n  return [\n    \"button\",\n    \"link\",\n    \"tab\",\n    \"chip\",\n    \"tag\",\n    \"breadcrumb-link\",\n  ].includes(elementType);\n}\n\n/**\n * Helper to create a prop definition\n */\nfunction createProp(\n  name: string,\n  type: InferredPropType,\n  required: boolean,\n  description: string,\n  defaultValue?: string,\n  possibleValues?: string[],\n  inferenceSource: PropInferenceSource = \"element-type\"\n): PropDefinition {\n  const typeString = getTypeString(type, name, possibleValues);\n\n  return {\n    name,\n    type,\n    typeString,\n    required,\n    defaultValue,\n    description,\n    inferenceSource,\n    confidence: 0.85,\n    possibleValues,\n    jsdocTags: defaultValue ? [{ tag: \"default\", value: defaultValue }] : undefined,\n  };\n}\n\n/**\n * Get the TypeScript type string for a type\n */\nfunction getTypeString(type: InferredPropType, propName: string, possibleValues?: string[]): string {\n  switch (type) {\n    case \"string-literal\":\n      if (possibleValues && possibleValues.length > 0) {\n        return possibleValues.map((v) => `\"${v}\"`).join(\" | \");\n      }\n      return \"string\";\n    case \"ReactNode\":\n      return \"React.ReactNode\";\n    case \"function\":\n      // Infer function signature from prop name\n      if (propName === \"onDelete\" || propName === \"onSelect\") {\n        return \"() => void\";\n      }\n      if (propName === \"onChange\") {\n        return \"(value: unknown) => void\";\n      }\n      if (propName === \"onOpenChange\" || propName === \"onExpandedChange\") {\n        return \"(open: boolean) => void\";\n      }\n      if (propName === \"onPageChange\") {\n        return \"(page: number) => void\";\n      }\n      if (propName === \"onChangeEnd\") {\n        return \"(value: number) => void\";\n      }\n      if (propName === \"onFilesChange\") {\n        return \"(files: File[]) => void\";\n      }\n      return \"() => void\";\n    case \"eventHandler\":\n      if (propName === \"onClick\") {\n        return \"React.MouseEventHandler<HTMLElement>\";\n      }\n      if (propName === \"onChange\") {\n        return \"React.ChangeEventHandler<HTMLElement>\";\n      }\n      if (propName === \"onBlur\" || propName === \"onFocus\") {\n        return \"React.FocusEventHandler<HTMLElement>\";\n      }\n      return \"React.EventHandler<React.SyntheticEvent>\";\n    case \"CSSProperties\":\n      return \"React.CSSProperties\";\n    case \"className\":\n      return \"string\";\n    case \"children\":\n      return \"React.ReactNode\";\n    case \"ref\":\n      return \"React.Ref<HTMLElement>\";\n    default:\n      return type;\n  }\n}\n\n/**\n * Deduplicate props by name, keeping highest confidence\n */\nfunction deduplicateProps(props: PropDefinition[]): PropDefinition[] {\n  const propMap = new Map<string, PropDefinition>();\n\n  for (const prop of props) {\n    const existing = propMap.get(prop.name);\n    if (!existing || prop.confidence > existing.confidence) {\n      propMap.set(prop.name, prop);\n    }\n  }\n\n  return Array.from(propMap.values());\n}\n\n// ============================================================================\n// Interface Code Generation\n// ============================================================================\n\n/**\n * Generate a TypeScript interface from component analysis\n */\nfunction generatePropInterfaceImpl(\n  componentSetInput: ComponentSetInput | null,\n  interactiveInput: InteractiveElementInput | null,\n  options: Partial<InterfaceGenerationOptions> = {}\n): GeneratedInterface {\n  const opts: InterfaceGenerationOptions = { ...DEFAULT_OPTIONS, ...options };\n  const allProps: PropDefinition[] = [];\n  const imports: string[] = [];\n\n  // Collect props from component set\n  if (componentSetInput) {\n    const variantProps = analyzeVariantPropertiesImpl(\n      componentSetInput.variantProperties,\n      componentSetInput.variants\n    );\n    allProps.push(...variantProps);\n  }\n\n  // Collect props from interactive element\n  if (interactiveInput) {\n    const elementProps = inferPropsFromInteractiveElementImpl(interactiveInput);\n    allProps.push(...elementProps);\n  }\n\n  // Add custom props\n  if (opts.customProps) {\n    allProps.push(...opts.customProps);\n  }\n\n  // Add common props\n  allProps.push(\n    createProp(\n      \"className\",\n      \"className\",\n      false,\n      \"Additional CSS class names.\",\n      undefined,\n      undefined,\n      \"default\"\n    )\n  );\n\n  if (opts.includeRef) {\n    allProps.push(\n      createProp(\n        \"ref\",\n        \"ref\",\n        false,\n        \"Ref to the underlying DOM element.\",\n        undefined,\n        undefined,\n        \"default\"\n      )\n    );\n  }\n\n  // Deduplicate\n  const props = deduplicateProps(allProps);\n\n  // Determine imports\n  if (props.some((p) => p.typeString.includes(\"React.\"))) {\n    imports.push('import * as React from \"react\";');\n  }\n\n  // Generate interface name\n  const interfaceName = generateInterfaceName(opts);\n\n  // Generate extends clause\n  const extendsTypes = generateExtendsClause(opts);\n\n  // Generate CVA variant props if needed\n  let cvaVariantProps: string | undefined;\n  if (opts.generateCVATypes && componentSetInput) {\n    cvaVariantProps = generateCVAVariantProps(componentSetInput, opts);\n  }\n\n  // Generate the interface code\n  const code = generateInterfaceCode(interfaceName, props, extendsTypes, cvaVariantProps, opts);\n\n  // Calculate stats\n  const stats = calculateInterfaceStats(props);\n\n  return {\n    name: interfaceName,\n    code,\n    props,\n    extends: extendsTypes,\n    isComponentProps: true,\n    cvaVariantProps,\n    imports,\n    stats,\n  };\n}\n\n/**\n * Generate interface name from options\n */\nfunction generateInterfaceName(options: InterfaceGenerationOptions): string {\n  const prefix = options.interfacePrefix || \"\";\n  const suffix = options.interfaceSuffix || \"Props\";\n  return `${prefix}${options.componentName}${suffix}`;\n}\n\n/**\n * Generate extends clause\n */\nfunction generateExtendsClause(\n  options: InterfaceGenerationOptions\n): string[] {\n  const extendsTypes: string[] = [];\n\n  if (options.extendReactProps && options.baseElement) {\n    extendsTypes.push(`React.ComponentProps<\"${options.baseElement}\">`);\n  }\n\n  if (options.generateCVATypes) {\n    extendsTypes.push(`VariantProps<typeof ${options.componentName.toLowerCase()}Variants>`);\n  }\n\n  return extendsTypes;\n}\n\n/**\n * Generate CVA variant props type definition\n */\nfunction generateCVAVariantProps(\n  componentSetInput: ComponentSetInput,\n  options: InterfaceGenerationOptions\n): string {\n  const variantName = `${options.componentName.toLowerCase()}Variants`;\n  let code = \"\";\n\n  code += `const ${variantName} = cva(\\n`;\n  code += `  \"/* base classes */\",\\n`;\n  code += `  {\\n`;\n  code += `    variants: {\\n`;\n\n  for (const [propName, values] of Object.entries(componentSetInput.variantProperties)) {\n    const normalizedName = normalizeVariantPropertyNameImpl(propName);\n    code += `      ${normalizedName}: {\\n`;\n    for (const value of values) {\n      code += `        \"${value}\": \"/* ${value} styles */\",\\n`;\n    }\n    code += `      },\\n`;\n  }\n\n  code += `    },\\n`;\n  code += `    defaultVariants: {\\n`;\n\n  // Add default variants\n  for (const [propName, values] of Object.entries(componentSetInput.variantProperties)) {\n    const normalizedName = normalizeVariantPropertyNameImpl(propName);\n    const defaultValue = findDefaultValue(propName, values, componentSetInput.variants);\n    if (defaultValue) {\n      code += `      ${normalizedName}: ${defaultValue},\\n`;\n    }\n  }\n\n  code += `    },\\n`;\n  code += `  }\\n`;\n  code += `);\\n`;\n\n  return code;\n}\n\n/**\n * Generate the full interface code\n */\nfunction generateInterfaceCode(\n  interfaceName: string,\n  props: PropDefinition[],\n  extendsTypes: string[],\n  cvaVariantProps: string | undefined,\n  options: InterfaceGenerationOptions\n): string {\n  let code = \"\";\n\n  // Add CVA types if present\n  if (cvaVariantProps) {\n    code += cvaVariantProps;\n    code += \"\\n\";\n  }\n\n  // Add interface JSDoc\n  if (options.includeJSDoc) {\n    code += `/**\\n`;\n    code += ` * Props for the ${options.componentName} component.\\n`;\n    code += ` */\\n`;\n  }\n\n  // Start interface\n  const exportKeyword = options.exportInterface ? \"export \" : \"\";\n  code += `${exportKeyword}interface ${interfaceName}`;\n\n  // Add extends\n  if (extendsTypes.length > 0) {\n    code += ` extends ${extendsTypes.join(\", \")}`;\n  }\n\n  code += ` {\\n`;\n\n  // Filter out props that would be inherited from extended types\n  const propsToInclude = filterInheritedProps(props, options);\n\n  // Add props\n  for (const prop of propsToInclude) {\n    // Add JSDoc for prop\n    if (options.includeJSDoc && prop.description) {\n      code += `  /**\\n`;\n      code += `   * ${prop.description}\\n`;\n      if (prop.jsdocTags) {\n        for (const tag of prop.jsdocTags) {\n          code += `   * @${tag.tag} ${tag.value}\\n`;\n        }\n      }\n      code += `   */\\n`;\n    }\n\n    // Add prop definition\n    const optionalMarker = prop.required ? \"\" : \"?\";\n    code += `  ${prop.name}${optionalMarker}: ${prop.typeString};\\n`;\n  }\n\n  code += `}\\n`;\n\n  return code;\n}\n\n/**\n * Filter out props that would be inherited from extended types\n */\nfunction filterInheritedProps(\n  props: PropDefinition[],\n  options: InterfaceGenerationOptions\n): PropDefinition[] {\n  // If extending React component props, many common props are inherited\n  const inheritedProps = new Set<string>();\n\n  if (options.extendReactProps) {\n    // Common props inherited from HTML elements\n    inheritedProps.add(\"id\");\n    inheritedProps.add(\"style\");\n    inheritedProps.add(\"title\");\n    inheritedProps.add(\"tabIndex\");\n    inheritedProps.add(\"role\");\n    inheritedProps.add(\"aria-label\");\n    inheritedProps.add(\"aria-labelledby\");\n    inheritedProps.add(\"aria-describedby\");\n\n    // Event handlers inherited from elements\n    inheritedProps.add(\"onKeyDown\");\n    inheritedProps.add(\"onKeyUp\");\n    inheritedProps.add(\"onMouseEnter\");\n    inheritedProps.add(\"onMouseLeave\");\n  }\n\n  return props.filter((p) => !inheritedProps.has(p.name));\n}\n\n/**\n * Calculate statistics about the generated interface\n */\nfunction calculateInterfaceStats(props: PropDefinition[]): InterfaceGenerationStats {\n  const requiredProps = props.filter((p) => p.required).length;\n  const optionalProps = props.length - requiredProps;\n  const variantProps = props.filter((p) => p.inferenceSource === \"variant-property\").length;\n  const eventHandlerProps = props.filter((p) =>\n    p.typeString.includes(\"=>\") || p.typeString.includes(\"Handler\")\n  ).length;\n  const averageConfidence =\n    props.length > 0\n      ? props.reduce((sum, p) => sum + p.confidence, 0) / props.length\n      : 0;\n\n  return {\n    totalProps: props.length,\n    requiredProps,\n    optionalProps,\n    variantProps,\n    eventHandlerProps,\n    averageConfidence,\n  };\n}\n\n// ============================================================================\n// High-Level API\n// ============================================================================\n\n/**\n * Generate prop interfaces from a Figma component set\n */\nfunction generateInterfaceFromComponentSetImpl(\n  componentSet: {\n    name: string;\n    variantProperties: Record<string, string[]>;\n    variants: VariantInfo[];\n    description?: string;\n  },\n  options?: Partial<InterfaceGenerationOptions>\n): GeneratedInterface {\n  const opts = {\n    ...options,\n    componentName: options?.componentName || sanitizeComponentNameImpl(componentSet.name),\n  };\n\n  return generatePropInterfaceImpl(componentSet, null, opts);\n}\n\n/**\n * Generate prop interfaces from an interactive element analysis\n */\nfunction generateInterfaceFromElementImpl(\n  element: InteractiveElementAnalysis,\n  resolvedComponent?: ResolvedComponent,\n  resolvedInstance?: ResolvedInstance,\n  options?: Partial<InterfaceGenerationOptions>\n): GeneratedInterface {\n  const componentName =\n    options?.componentName ||\n    (resolvedComponent\n      ? sanitizeComponentNameImpl(resolvedComponent.name)\n      : sanitizeComponentNameImpl(element.nodeName));\n\n  const opts = { ...options, componentName };\n\n  return generatePropInterfaceImpl(\n    element.metadata.componentSet\n      ? {\n          name: element.metadata.componentSet.name,\n          variantProperties: element.metadata.componentSet.variantProperties,\n          variants: element.metadata.componentSet.allVariants,\n        }\n      : null,\n    { element, resolvedComponent, resolvedInstance },\n    opts\n  );\n}\n\n/**\n * Sanitize a component name for use in TypeScript\n */\nfunction sanitizeComponentNameImpl(name: string): string {\n  return name\n    .replace(/[^a-zA-Z0-9]/g, \" \")\n    .trim()\n    .split(/\\s+/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(\"\");\n}\n\n/**\n * Generate multiple interfaces from a collection of components\n */\nfunction generateInterfacesFromComponentsImpl(\n  components: Array<{\n    componentSet?: ComponentSetInput;\n    interactiveElement?: InteractiveElementInput;\n    options?: Partial<InterfaceGenerationOptions>;\n  }>\n): GeneratedInterface[] {\n  return components.map((component) =>\n    generatePropInterfaceImpl(\n      component.componentSet || null,\n      component.interactiveElement || null,\n      component.options\n    )\n  );\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport const analyzeVariantProperties = analyzeVariantPropertiesImpl;\nexport const inferPropsFromInteractiveElement = inferPropsFromInteractiveElementImpl;\nexport const generatePropInterface = generatePropInterfaceImpl;\nexport const generateInterfaceFromComponentSet = generateInterfaceFromComponentSetImpl;\nexport const generateInterfaceFromElement = generateInterfaceFromElementImpl;\nexport const generateInterfacesFromComponents = generateInterfacesFromComponentsImpl;\nexport const normalizeVariantPropertyName = normalizeVariantPropertyNameImpl;\nexport const sanitizeComponentName = sanitizeComponentNameImpl;\n"
}
Now let me verify the TypeScript compiles correctly using the full build:

ðŸ”§ Tool: Bash
Input: {
  "command": "npm run build 2>&1 | tail -50",
  "description": "Build to verify TypeScript compiles",
  "timeout": 120000
}
