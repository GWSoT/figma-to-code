I'll start by exploring the codebase to understand the existing structure and then implement the slot/children pattern detection feature.

ðŸ”§ Tool: Skill
Input: {
  "skill": "superpowers:brainstorming"
}
I'll explore the codebase first to understand the existing structure and patterns for code generation before designing the slot/children pattern detection feature.

ðŸ”§ Tool: Task
Input: {
  "prompt": "Explore the codebase to understand:\n1. The existing code generation utilities in src/utils/\n2. Any existing Figma-related code or design parsing\n3. The patterns used for generating React, Vue, or Svelte code\n4. Test patterns used in the project\n\nFocus on files related to code generation, component generation, and any Figma integration. Report back with file paths and key patterns found.",
  "description": "Explore code generation patterns",
  "subagent_type": "Explore"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "src/utils/**/*"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "src/**/*figma*"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "tests/**/*.spec.ts"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "find /home/rainman/figma-to-code/figma-to-code/src -type f -name \"*.ts\" -o -name \"*.tsx\" | head -30",
  "description": "List TypeScript files in src directory"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/styled-components-generator.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/svelte-component-generator.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/tailwind-generator.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/tests/styled-components-generator.spec.ts",
  "limit": 100
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/tests/prop-interface-generator.spec.ts",
  "limit": 100
}

ðŸ”§ Tool: Bash
Input: {
  "command": "find /home/rainman/figma-to-code/figma-to-code/src/utils -name \"*.ts\" | head -20",
  "description": "List Figma utility files"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "grep -l \"export function\" /home/rainman/figma-to-code/figma-to-code/src/utils/figma-*.ts | head -10",
  "description": "Find main Figma utility functions"
}
Now I have a good understanding of the codebase. Let me read the existing generators to understand their patterns more deeply, particularly focusing on how components are structured and where slot/children patterns would fit.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/svelte-component-generator.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/figma-api.ts"
}
Now I have a good understanding of the codebase. Let me check if there are any existing tests to understand the test patterns better.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/tests/styled-components-generator.spec.ts"
}
Now I have a comprehensive understanding of the codebase. I see that the feature needs to:

1. **Detect slot/children patterns in Figma designs** - Identify when a component has content areas meant for children/slots
2. **Generate React children props** - For React components
3. **Generate Vue slots** - Including named slots
4. **Generate Svelte slots** - Including named slots for complex structures

Let me create a plan and implement this feature.

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Create slot pattern detector utility",
      "status": "in_progress",
      "activeForm": "Creating slot pattern detector utility"
    },
    {
      "content": "Update prop-interface-generator for React children/slots",
      "status": "pending",
      "activeForm": "Updating prop-interface-generator for React children/slots"
    },
    {
      "content": "Update svelte-component-generator for Svelte slots",
      "status": "pending",
      "activeForm": "Updating svelte-component-generator for Svelte slots"
    },
    {
      "content": "Create Vue slot generator utility",
      "status": "pending",
      "activeForm": "Creating Vue slot generator utility"
    },
    {
      "content": "Write tests for slot pattern detection",
      "status": "pending",
      "activeForm": "Writing tests for slot pattern detection"
    },
    {
      "content": "Verify with Playwright test",
      "status": "pending",
      "activeForm": "Verifying with Playwright test"
    }
  ]
}
Let me start by creating the slot pattern detector utility:

ðŸ”§ Tool: Write
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/slot-pattern-detector.ts",
  "content": "/**\n * Slot/Children Pattern Detector\n *\n * Identifies slot/children patterns in Figma designs and generates proper:\n * - React children and render props\n * - Vue slots (default and named)\n * - Svelte slots (default and named)\n *\n * Detection is based on:\n * - Node naming conventions (e.g., \"Slot\", \"Content\", \"Children\")\n * - Frame auto-layout with placeholder content\n * - Component structure analysis\n * - Visual hints like empty containers\n */\n\nimport type { FigmaNode } from \"./figma-api\";\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Types of slots that can be detected\n */\nexport type SlotType =\n  | \"default\" // Main content slot (React children, Vue default slot)\n  | \"header\" // Header/top slot\n  | \"footer\" // Footer/bottom slot\n  | \"leading\" // Left/start slot (icons, avatars)\n  | \"trailing\" // Right/end slot (actions, icons)\n  | \"title\" // Title slot\n  | \"subtitle\" // Subtitle slot\n  | \"content\" // Generic content slot\n  | \"actions\" // Actions/buttons slot\n  | \"icon\" // Icon slot\n  | \"prefix\" // Prefix slot (for inputs)\n  | \"suffix\" // Suffix slot (for inputs)\n  | \"trigger\" // Trigger slot (for dropdowns, dialogs)\n  | \"overlay\" // Overlay content slot\n  | \"custom\"; // Custom named slot\n\n/**\n * A detected slot in a Figma design\n */\nexport interface DetectedSlot {\n  /** Unique identifier for the slot */\n  id: string;\n  /** Slot type */\n  type: SlotType;\n  /** Slot name (for named slots) */\n  name: string;\n  /** Original Figma node name */\n  nodeName: string;\n  /** Node ID in Figma */\n  nodeId: string;\n  /** Whether this is the default/main content slot */\n  isDefault: boolean;\n  /** Whether the slot is required (has no fallback) */\n  required: boolean;\n  /** Description of the slot's purpose */\n  description: string;\n  /** Expected content type */\n  expectedContentType: SlotContentType;\n  /** Position hint for rendering order */\n  position: SlotPosition;\n  /** Confidence score (0-1) */\n  confidence: number;\n  /** Bounding box for the slot area */\n  bounds?: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n  /** Fallback content if slot is empty */\n  fallbackContent?: string;\n}\n\n/**\n * Expected content type for a slot\n */\nexport type SlotContentType =\n  | \"any\" // Any content\n  | \"text\" // Text content\n  | \"element\" // Single element\n  | \"elements\" // Multiple elements\n  | \"component\" // React/Vue/Svelte component\n  | \"icon\" // Icon element\n  | \"image\" // Image element\n  | \"interactive\"; // Interactive element (button, link)\n\n/**\n * Position hint for slot ordering\n */\nexport type SlotPosition =\n  | \"start\" // Start/top/left\n  | \"center\" // Center/middle\n  | \"end\" // End/bottom/right\n  | \"before\" // Before main content\n  | \"after\" // After main content\n  | \"overlay\"; // Overlaying content\n\n/**\n * Result of slot pattern detection\n */\nexport interface SlotPatternResult {\n  /** Whether slots were detected */\n  hasSlots: boolean;\n  /** Detected slots */\n  slots: DetectedSlot[];\n  /** Whether there's a default content slot */\n  hasDefaultSlot: boolean;\n  /** Named slots (excluding default) */\n  namedSlots: DetectedSlot[];\n  /** Total confidence score */\n  overallConfidence: number;\n  /** Component type hint based on slot patterns */\n  componentTypeHint?: string;\n  /** Generated code for different frameworks */\n  frameworkCode: {\n    react: ReactSlotCode;\n    vue: VueSlotCode;\n    svelte: SvelteSlotCode;\n  };\n}\n\n/**\n * React slot code generation\n */\nexport interface ReactSlotCode {\n  /** Props interface additions */\n  propsInterface: string;\n  /** JSX for rendering slots */\n  jsx: string;\n  /** Usage example */\n  usageExample: string;\n}\n\n/**\n * Vue slot code generation\n */\nexport interface VueSlotCode {\n  /** Template slots */\n  template: string;\n  /** Script setup for slot handling */\n  scriptSetup: string;\n  /** Usage example */\n  usageExample: string;\n}\n\n/**\n * Svelte slot code generation\n */\nexport interface SvelteSlotCode {\n  /** Template slots */\n  template: string;\n  /** Script additions */\n  script: string;\n  /** Usage example */\n  usageExample: string;\n}\n\n/**\n * Options for slot detection\n */\nexport interface SlotDetectionOptions {\n  /** Minimum confidence threshold (0-1) */\n  minConfidence: number;\n  /** Include placeholder analysis */\n  analyzePlaceholders: boolean;\n  /** Include auto-layout analysis */\n  analyzeAutoLayout: boolean;\n  /** Framework for code generation */\n  framework: \"react\" | \"vue\" | \"svelte\" | \"all\";\n  /** Use TypeScript */\n  useTypeScript: boolean;\n  /** Component name for code generation */\n  componentName: string;\n}\n\nconst DEFAULT_OPTIONS: SlotDetectionOptions = {\n  minConfidence: 0.5,\n  analyzePlaceholders: true,\n  analyzeAutoLayout: true,\n  framework: \"all\",\n  useTypeScript: true,\n  componentName: \"Component\",\n};\n\n// ============================================================================\n// Slot Name Patterns\n// ============================================================================\n\n/**\n * Patterns for detecting slot types from node names\n */\nconst SLOT_NAME_PATTERNS: Record<SlotType, RegExp[]> = {\n  default: [\n    /^slot$/i,\n    /^content$/i,\n    /^children$/i,\n    /^main$/i,\n    /^body$/i,\n    /\\bcontent\\s*slot\\b/i,\n    /\\bdefault\\s*slot\\b/i,\n    /\\bmain\\s*content\\b/i,\n  ],\n  header: [\n    /^header$/i,\n    /^top$/i,\n    /\\bheader\\s*slot\\b/i,\n    /\\btop\\s*content\\b/i,\n    /\\bheading\\b/i,\n  ],\n  footer: [\n    /^footer$/i,\n    /^bottom$/i,\n    /\\bfooter\\s*slot\\b/i,\n    /\\bbottom\\s*content\\b/i,\n  ],\n  leading: [\n    /^leading$/i,\n    /^start$/i,\n    /^left$/i,\n    /^prepend$/i,\n    /\\bleading\\s*slot\\b/i,\n    /\\bstart\\s*content\\b/i,\n  ],\n  trailing: [\n    /^trailing$/i,\n    /^end$/i,\n    /^right$/i,\n    /^append$/i,\n    /\\btrailing\\s*slot\\b/i,\n    /\\bend\\s*content\\b/i,\n  ],\n  title: [\n    /^title$/i,\n    /\\btitle\\s*slot\\b/i,\n    /\\bheadline\\b/i,\n  ],\n  subtitle: [\n    /^subtitle$/i,\n    /^subhead$/i,\n    /\\bsubtitle\\s*slot\\b/i,\n    /\\bsubheading\\b/i,\n  ],\n  content: [\n    /\\bcontent\\b/i,\n    /\\binner\\b/i,\n    /\\bwrapper\\b/i,\n  ],\n  actions: [\n    /^actions$/i,\n    /^buttons$/i,\n    /^cta$/i,\n    /\\baction\\s*slot\\b/i,\n    /\\bbuttons?\\s*area\\b/i,\n  ],\n  icon: [\n    /^icon$/i,\n    /^icon\\s*slot$/i,\n    /\\bicon\\s*container\\b/i,\n    /\\bicon\\s*wrapper\\b/i,\n  ],\n  prefix: [\n    /^prefix$/i,\n    /\\bprefix\\s*slot\\b/i,\n    /\\binput\\s*prefix\\b/i,\n  ],\n  suffix: [\n    /^suffix$/i,\n    /\\bsuffix\\s*slot\\b/i,\n    /\\binput\\s*suffix\\b/i,\n  ],\n  trigger: [\n    /^trigger$/i,\n    /\\btrigger\\s*slot\\b/i,\n    /\\bactivator\\b/i,\n  ],\n  overlay: [\n    /^overlay$/i,\n    /\\boverlay\\s*content\\b/i,\n    /\\bmodal\\s*content\\b/i,\n    /\\bdialog\\s*content\\b/i,\n    /\\bpopover\\s*content\\b/i,\n  ],\n  custom: [], // No automatic patterns for custom slots\n};\n\n/**\n * Patterns indicating placeholder content (not real content)\n */\nconst PLACEHOLDER_PATTERNS: RegExp[] = [\n  /placeholder/i,\n  /lorem\\s*ipsum/i,\n  /sample/i,\n  /example/i,\n  /dummy/i,\n  /mock/i,\n  /your\\s+\\w+\\s+here/i,\n  /\\[.*\\]/,\n  /\\{.*\\}/,\n  /\\.{3,}/,\n  /xxx+/i,\n];\n\n/**\n * Patterns for component containers that should have children\n */\nconst CONTAINER_COMPONENT_PATTERNS: RegExp[] = [\n  /^card$/i,\n  /^modal$/i,\n  /^dialog$/i,\n  /^drawer$/i,\n  /^panel$/i,\n  /^section$/i,\n  /^container$/i,\n  /^wrapper$/i,\n  /^layout$/i,\n  /^box$/i,\n  /^stack$/i,\n  /^flex$/i,\n  /^grid$/i,\n  /^group$/i,\n  /^accordion$/i,\n  /^tab\\s*panel$/i,\n  /^popover$/i,\n  /^tooltip$/i,\n  /^dropdown$/i,\n  /^menu$/i,\n  /^list$/i,\n  /^list\\s*item$/i,\n];\n\n// ============================================================================\n// Slot Detection Functions\n// ============================================================================\n\n/**\n * Detect slot patterns in a Figma node tree\n */\nexport function detectSlotPatterns(\n  node: FigmaNode,\n  options: Partial<SlotDetectionOptions> = {}\n): SlotPatternResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const slots: DetectedSlot[] = [];\n\n  // Analyze the node and its children for slot patterns\n  analyzeNodeForSlots(node, slots, opts, true);\n\n  // Deduplicate and sort slots\n  const uniqueSlots = deduplicateSlots(slots);\n  const filteredSlots = uniqueSlots.filter(s => s.confidence >= opts.minConfidence);\n\n  // Determine default slot\n  const defaultSlot = findDefaultSlot(filteredSlots);\n  const namedSlots = filteredSlots.filter(s => !s.isDefault);\n\n  // Calculate overall confidence\n  const overallConfidence = filteredSlots.length > 0\n    ? filteredSlots.reduce((sum, s) => sum + s.confidence, 0) / filteredSlots.length\n    : 0;\n\n  // Generate framework-specific code\n  const frameworkCode = generateFrameworkCode(filteredSlots, opts);\n\n  return {\n    hasSlots: filteredSlots.length > 0,\n    slots: filteredSlots,\n    hasDefaultSlot: !!defaultSlot,\n    namedSlots,\n    overallConfidence,\n    componentTypeHint: inferComponentType(node, filteredSlots),\n    frameworkCode,\n  };\n}\n\n/**\n * Analyze a node and its children for slot patterns\n */\nfunction analyzeNodeForSlots(\n  node: FigmaNode,\n  slots: DetectedSlot[],\n  options: SlotDetectionOptions,\n  isRoot: boolean\n): void {\n  // Check if node name matches slot patterns\n  const slotFromName = detectSlotFromName(node);\n  if (slotFromName) {\n    slots.push(slotFromName);\n  }\n\n  // Check for container components that should have default children\n  if (isRoot && isContainerComponent(node.name)) {\n    const containerSlot = createContainerDefaultSlot(node);\n    if (containerSlot) {\n      slots.push(containerSlot);\n    }\n  }\n\n  // Check for auto-layout containers with placeholder content\n  if (options.analyzeAutoLayout && isAutoLayoutContainer(node)) {\n    const layoutSlots = detectAutoLayoutSlots(node, options);\n    slots.push(...layoutSlots);\n  }\n\n  // Check for placeholder content indicating slot areas\n  if (options.analyzePlaceholders && hasPlaceholderContent(node)) {\n    const placeholderSlot = createPlaceholderSlot(node);\n    if (placeholderSlot) {\n      slots.push(placeholderSlot);\n    }\n  }\n\n  // Recursively analyze children\n  if (node.children) {\n    for (const child of node.children) {\n      analyzeNodeForSlots(child, slots, options, false);\n    }\n  }\n}\n\n/**\n * Detect slot type from node name\n */\nfunction detectSlotFromName(node: FigmaNode): DetectedSlot | null {\n  const name = node.name.trim();\n\n  for (const [slotType, patterns] of Object.entries(SLOT_NAME_PATTERNS)) {\n    for (const pattern of patterns) {\n      if (pattern.test(name)) {\n        return createSlot(node, slotType as SlotType, 0.9);\n      }\n    }\n  }\n\n  // Check for explicit slot naming convention: \"slot:name\" or \"[slot]\"\n  const explicitSlotMatch = name.match(/(?:slot[:\\s-]+)?(\\w+)/i);\n  if (name.toLowerCase().includes(\"slot\") && explicitSlotMatch) {\n    const slotName = explicitSlotMatch[1].toLowerCase();\n    const slotType = mapNameToSlotType(slotName);\n    return createSlot(node, slotType, 0.95);\n  }\n\n  return null;\n}\n\n/**\n * Map a slot name to a slot type\n */\nfunction mapNameToSlotType(name: string): SlotType {\n  const lowerName = name.toLowerCase();\n\n  // Check each slot type's patterns\n  for (const [slotType, patterns] of Object.entries(SLOT_NAME_PATTERNS)) {\n    for (const pattern of patterns) {\n      if (pattern.test(lowerName)) {\n        return slotType as SlotType;\n      }\n    }\n  }\n\n  // Check for common mappings\n  const mappings: Record<string, SlotType> = {\n    header: \"header\",\n    head: \"header\",\n    top: \"header\",\n    footer: \"footer\",\n    foot: \"footer\",\n    bottom: \"footer\",\n    left: \"leading\",\n    start: \"leading\",\n    prepend: \"leading\",\n    right: \"trailing\",\n    end: \"trailing\",\n    append: \"trailing\",\n    title: \"title\",\n    headline: \"title\",\n    subtitle: \"subtitle\",\n    subhead: \"subtitle\",\n    content: \"content\",\n    body: \"default\",\n    main: \"default\",\n    children: \"default\",\n    actions: \"actions\",\n    buttons: \"actions\",\n    icon: \"icon\",\n    prefix: \"prefix\",\n    suffix: \"suffix\",\n    trigger: \"trigger\",\n    overlay: \"overlay\",\n  };\n\n  return mappings[lowerName] || \"custom\";\n}\n\n/**\n * Create a slot definition\n */\nfunction createSlot(\n  node: FigmaNode,\n  type: SlotType,\n  confidence: number\n): DetectedSlot {\n  const name = generateSlotName(node.name, type);\n  const position = inferSlotPosition(type, node);\n  const expectedContentType = inferContentType(type, node);\n\n  return {\n    id: `slot-${node.id}`,\n    type,\n    name,\n    nodeName: node.name,\n    nodeId: node.id,\n    isDefault: type === \"default\" || type === \"content\",\n    required: false,\n    description: generateSlotDescription(type, name),\n    expectedContentType,\n    position,\n    confidence,\n    bounds: node.absoluteBoundingBox\n      ? {\n          x: node.absoluteBoundingBox.x,\n          y: node.absoluteBoundingBox.y,\n          width: node.absoluteBoundingBox.width,\n          height: node.absoluteBoundingBox.height,\n        }\n      : undefined,\n  };\n}\n\n/**\n * Generate a valid slot name from node name\n */\nfunction generateSlotName(nodeName: string, type: SlotType): string {\n  // Clean the node name\n  let name = nodeName\n    .replace(/\\s*slot\\s*/gi, \"\")\n    .replace(/[\\s-]+/g, \"-\")\n    .replace(/[^a-zA-Z0-9-]/g, \"\")\n    .toLowerCase()\n    .replace(/^-+|-+$/g, \"\");\n\n  // If empty after cleaning, use the slot type\n  if (!name) {\n    name = type === \"custom\" ? \"content\" : type;\n  }\n\n  // Convert to camelCase for named slots\n  if (type !== \"default\") {\n    name = name.replace(/-([a-z])/g, (_, c) => c.toUpperCase());\n  } else {\n    name = \"default\";\n  }\n\n  return name;\n}\n\n/**\n * Infer slot position from type and node\n */\nfunction inferSlotPosition(type: SlotType, node: FigmaNode): SlotPosition {\n  switch (type) {\n    case \"header\":\n    case \"title\":\n    case \"leading\":\n    case \"prefix\":\n      return \"start\";\n    case \"footer\":\n    case \"subtitle\":\n    case \"trailing\":\n    case \"suffix\":\n    case \"actions\":\n      return \"end\";\n    case \"overlay\":\n    case \"trigger\":\n      return \"overlay\";\n    case \"content\":\n    case \"default\":\n    default:\n      return \"center\";\n  }\n}\n\n/**\n * Infer expected content type from slot type and node\n */\nfunction inferContentType(type: SlotType, node: FigmaNode): SlotContentType {\n  switch (type) {\n    case \"icon\":\n      return \"icon\";\n    case \"title\":\n    case \"subtitle\":\n      return \"text\";\n    case \"actions\":\n      return \"interactive\";\n    case \"trigger\":\n      return \"component\";\n    case \"leading\":\n    case \"trailing\":\n    case \"prefix\":\n    case \"suffix\":\n      return \"element\";\n    case \"header\":\n    case \"footer\":\n    case \"content\":\n    case \"default\":\n    case \"overlay\":\n    default:\n      return \"any\";\n  }\n}\n\n/**\n * Generate a description for a slot\n */\nfunction generateSlotDescription(type: SlotType, name: string): string {\n  const descriptions: Record<SlotType, string> = {\n    default: \"The main content area of the component.\",\n    header: \"Content displayed in the header area.\",\n    footer: \"Content displayed in the footer area.\",\n    leading: \"Content displayed at the start (left in LTR).\",\n    trailing: \"Content displayed at the end (right in LTR).\",\n    title: \"The title text or element.\",\n    subtitle: \"The subtitle or secondary text.\",\n    content: \"The main content area.\",\n    actions: \"Action buttons or interactive elements.\",\n    icon: \"An icon element.\",\n    prefix: \"Content displayed before the main element.\",\n    suffix: \"Content displayed after the main element.\",\n    trigger: \"The element that triggers the component.\",\n    overlay: \"Content displayed in the overlay.\",\n    custom: `Custom slot for ${name} content.`,\n  };\n\n  return descriptions[type];\n}\n\n/**\n * Check if a node is a container component that typically has children\n */\nfunction isContainerComponent(name: string): boolean {\n  return CONTAINER_COMPONENT_PATTERNS.some((pattern) => pattern.test(name));\n}\n\n/**\n * Create a default slot for container components\n */\nfunction createContainerDefaultSlot(node: FigmaNode): DetectedSlot | null {\n  // Only create if there are children that look like content\n  if (!node.children || node.children.length === 0) {\n    return null;\n  }\n\n  return createSlot(node, \"default\", 0.7);\n}\n\n/**\n * Check if a node is an auto-layout container\n */\nfunction isAutoLayoutContainer(node: FigmaNode): boolean {\n  // Check for Figma auto-layout properties\n  const nodeAny = node as any;\n  return (\n    nodeAny.layoutMode === \"HORIZONTAL\" ||\n    nodeAny.layoutMode === \"VERTICAL\" ||\n    nodeAny.primaryAxisSizingMode !== undefined\n  );\n}\n\n/**\n * Detect slots from auto-layout container structure\n */\nfunction detectAutoLayoutSlots(\n  node: FigmaNode,\n  options: SlotDetectionOptions\n): DetectedSlot[] {\n  const slots: DetectedSlot[] = [];\n  const nodeAny = node as any;\n\n  if (!node.children || node.children.length === 0) {\n    return slots;\n  }\n\n  const isHorizontal = nodeAny.layoutMode === \"HORIZONTAL\";\n\n  // Analyze children positions\n  const children = node.children;\n\n  // Check first child for leading/header slot\n  if (children.length >= 2) {\n    const first = children[0];\n    if (looksLikeSlotContent(first)) {\n      const type = isHorizontal ? \"leading\" : \"header\";\n      slots.push(createSlot(first, type, 0.6));\n    }\n  }\n\n  // Check last child for trailing/footer slot\n  if (children.length >= 2) {\n    const last = children[children.length - 1];\n    if (looksLikeSlotContent(last)) {\n      const type = isHorizontal ? \"trailing\" : \"footer\";\n      slots.push(createSlot(last, type, 0.6));\n    }\n  }\n\n  // Check middle children for content slot\n  if (children.length >= 3) {\n    const middle = children.slice(1, -1);\n    if (middle.length === 1 && looksLikeSlotContent(middle[0])) {\n      slots.push(createSlot(middle[0], \"content\", 0.6));\n    }\n  }\n\n  return slots;\n}\n\n/**\n * Check if a node looks like slot content (placeholder or generic container)\n */\nfunction looksLikeSlotContent(node: FigmaNode): boolean {\n  // Check name patterns\n  if (hasPlaceholderName(node.name)) {\n    return true;\n  }\n\n  // Check for empty or minimal content\n  const nodeAny = node as any;\n  if (nodeAny.type === \"FRAME\" || nodeAny.type === \"GROUP\") {\n    if (!node.children || node.children.length === 0) {\n      return true;\n    }\n  }\n\n  // Check for placeholder patterns\n  return SLOT_NAME_PATTERNS.content.some((pattern) => pattern.test(node.name));\n}\n\n/**\n * Check if a node name looks like a placeholder\n */\nfunction hasPlaceholderName(name: string): boolean {\n  return PLACEHOLDER_PATTERNS.some((pattern) => pattern.test(name));\n}\n\n/**\n * Check if a node has placeholder content\n */\nfunction hasPlaceholderContent(node: FigmaNode): boolean {\n  // Check node name\n  if (hasPlaceholderName(node.name)) {\n    return true;\n  }\n\n  // Check for text children with placeholder content\n  if (node.children) {\n    for (const child of node.children) {\n      if ((child as any).type === \"TEXT\") {\n        const characters = (child as any).characters;\n        if (characters && hasPlaceholderName(characters)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Create a slot from placeholder content\n */\nfunction createPlaceholderSlot(node: FigmaNode): DetectedSlot | null {\n  // Try to infer slot type from placeholder\n  const slotType = inferSlotTypeFromPlaceholder(node);\n\n  return createSlot(node, slotType, 0.65);\n}\n\n/**\n * Infer slot type from placeholder patterns\n */\nfunction inferSlotTypeFromPlaceholder(node: FigmaNode): SlotType {\n  const name = node.name.toLowerCase();\n\n  if (name.includes(\"title\") || name.includes(\"heading\")) {\n    return \"title\";\n  }\n  if (name.includes(\"subtitle\") || name.includes(\"description\")) {\n    return \"subtitle\";\n  }\n  if (name.includes(\"icon\")) {\n    return \"icon\";\n  }\n  if (name.includes(\"action\") || name.includes(\"button\")) {\n    return \"actions\";\n  }\n  if (name.includes(\"header\") || name.includes(\"top\")) {\n    return \"header\";\n  }\n  if (name.includes(\"footer\") || name.includes(\"bottom\")) {\n    return \"footer\";\n  }\n\n  return \"content\";\n}\n\n/**\n * Find the default slot from a list of slots\n */\nfunction findDefaultSlot(slots: DetectedSlot[]): DetectedSlot | undefined {\n  // First, look for explicitly marked default slot\n  const explicitDefault = slots.find((s) => s.isDefault && s.type === \"default\");\n  if (explicitDefault) {\n    return explicitDefault;\n  }\n\n  // Then look for content slots\n  const contentSlot = slots.find((s) => s.type === \"content\");\n  if (contentSlot) {\n    contentSlot.isDefault = true;\n    return contentSlot;\n  }\n\n  // If only one slot, make it default\n  if (slots.length === 1) {\n    slots[0].isDefault = true;\n    return slots[0];\n  }\n\n  return undefined;\n}\n\n/**\n * Deduplicate slots by node ID\n */\nfunction deduplicateSlots(slots: DetectedSlot[]): DetectedSlot[] {\n  const slotMap = new Map<string, DetectedSlot>();\n\n  for (const slot of slots) {\n    const existing = slotMap.get(slot.nodeId);\n    if (!existing || slot.confidence > existing.confidence) {\n      slotMap.set(slot.nodeId, slot);\n    }\n  }\n\n  // Sort by position\n  const positionOrder: SlotPosition[] = [\n    \"start\",\n    \"before\",\n    \"center\",\n    \"after\",\n    \"end\",\n    \"overlay\",\n  ];\n\n  return Array.from(slotMap.values()).sort(\n    (a, b) => positionOrder.indexOf(a.position) - positionOrder.indexOf(b.position)\n  );\n}\n\n/**\n * Infer component type from node and slot patterns\n */\nfunction inferComponentType(\n  node: FigmaNode,\n  slots: DetectedSlot[]\n): string | undefined {\n  const hasHeader = slots.some((s) => s.type === \"header\");\n  const hasFooter = slots.some((s) => s.type === \"footer\");\n  const hasActions = slots.some((s) => s.type === \"actions\");\n  const hasTrigger = slots.some((s) => s.type === \"trigger\");\n  const hasOverlay = slots.some((s) => s.type === \"overlay\");\n  const hasLeadingTrailing =\n    slots.some((s) => s.type === \"leading\") ||\n    slots.some((s) => s.type === \"trailing\");\n\n  if (hasTrigger && hasOverlay) {\n    return \"dropdown\";\n  }\n  if (hasHeader && hasFooter && hasActions) {\n    return \"dialog\";\n  }\n  if (hasHeader && hasFooter) {\n    return \"card\";\n  }\n  if (hasLeadingTrailing) {\n    return \"list-item\";\n  }\n  if (hasActions) {\n    return \"action-container\";\n  }\n\n  return undefined;\n}\n\n// ============================================================================\n// Framework Code Generation\n// ============================================================================\n\n/**\n * Generate framework-specific code for slots\n */\nfunction generateFrameworkCode(\n  slots: DetectedSlot[],\n  options: SlotDetectionOptions\n): SlotPatternResult[\"frameworkCode\"] {\n  return {\n    react: generateReactSlotCode(slots, options),\n    vue: generateVueSlotCode(slots, options),\n    svelte: generateSvelteSlotCode(slots, options),\n  };\n}\n\n/**\n * Generate React slot code\n */\nfunction generateReactSlotCode(\n  slots: DetectedSlot[],\n  options: SlotDetectionOptions\n): ReactSlotCode {\n  const { componentName, useTypeScript } = options;\n  const defaultSlot = slots.find((s) => s.isDefault);\n  const namedSlots = slots.filter((s) => !s.isDefault);\n\n  // Generate props interface\n  let propsInterface = \"\";\n  const propLines: string[] = [];\n\n  // Children prop for default slot\n  if (defaultSlot) {\n    propLines.push(\n      `  /** ${defaultSlot.description} */`,\n      `  children?: React.ReactNode;`\n    );\n  }\n\n  // Named slot props as render props or ReactNode\n  for (const slot of namedSlots) {\n    const propName = slot.name;\n    const propType = getReactPropType(slot);\n    const required = slot.required ? \"\" : \"?\";\n\n    propLines.push(`  /** ${slot.description} */`, `  ${propName}${required}: ${propType};`);\n  }\n\n  if (useTypeScript && propLines.length > 0) {\n    propsInterface = `interface ${componentName}Props {\\n${propLines.join(\"\\n\")}\\n}`;\n  }\n\n  // Generate JSX\n  let jsx = \"\";\n  const jsxParts: string[] = [];\n\n  for (const slot of slots) {\n    if (slot.isDefault) {\n      jsxParts.push(`{children}`);\n    } else {\n      const propName = slot.name;\n      if (slot.expectedContentType === \"component\") {\n        jsxParts.push(`{typeof ${propName} === 'function' ? ${propName}() : ${propName}}`);\n      } else {\n        jsxParts.push(`{${propName}}`);\n      }\n    }\n  }\n\n  jsx = jsxParts.join(\"\\n      \");\n\n  // Generate usage example\n  const usageProps: string[] = [];\n  for (const slot of namedSlots) {\n    usageProps.push(`  ${slot.name}={<div>Your ${slot.name} content</div>}`);\n  }\n\n  const usageExample = `<${componentName}${usageProps.length > 0 ? \"\\n\" + usageProps.join(\"\\n\") + \"\\n\" : \"\"}>\n  {/* Default content */}\n  <p>Your content here</p>\n</${componentName}>`;\n\n  return {\n    propsInterface,\n    jsx,\n    usageExample,\n  };\n}\n\n/**\n * Get React prop type for a slot\n */\nfunction getReactPropType(slot: DetectedSlot): string {\n  switch (slot.expectedContentType) {\n    case \"text\":\n      return \"React.ReactNode | string\";\n    case \"component\":\n      return \"React.ReactNode | (() => React.ReactNode)\";\n    case \"icon\":\n      return \"React.ReactElement\";\n    case \"interactive\":\n      return \"React.ReactNode\";\n    default:\n      return \"React.ReactNode\";\n  }\n}\n\n/**\n * Generate Vue slot code\n */\nfunction generateVueSlotCode(\n  slots: DetectedSlot[],\n  options: SlotDetectionOptions\n): VueSlotCode {\n  const defaultSlot = slots.find((s) => s.isDefault);\n  const namedSlots = slots.filter((s) => !s.isDefault);\n\n  // Generate template slots\n  const templateParts: string[] = [];\n\n  if (defaultSlot) {\n    if (defaultSlot.fallbackContent) {\n      templateParts.push(`<!-- ${defaultSlot.description} -->`);\n      templateParts.push(`<slot>${defaultSlot.fallbackContent}</slot>`);\n    } else {\n      templateParts.push(`<!-- ${defaultSlot.description} -->`);\n      templateParts.push(`<slot />`);\n    }\n  }\n\n  for (const slot of namedSlots) {\n    templateParts.push(`<!-- ${slot.description} -->`);\n    if (slot.fallbackContent) {\n      templateParts.push(`<slot name=\"${slot.name}\">${slot.fallbackContent}</slot>`);\n    } else {\n      templateParts.push(`<slot name=\"${slot.name}\" />`);\n    }\n  }\n\n  const template = templateParts.join(\"\\n    \");\n\n  // Generate script setup for slot handling\n  let scriptSetup = \"\";\n  if (options.useTypeScript && namedSlots.length > 0) {\n    const slotTypes: string[] = [];\n    for (const slot of slots) {\n      const slotName = slot.isDefault ? \"default\" : slot.name;\n      slotTypes.push(`  ${slotName}?: (props: {}) => any;`);\n    }\n\n    scriptSetup = `defineSlots<{\n${slotTypes.join(\"\\n\")}\n}>();`;\n  }\n\n  // Generate usage example\n  const usageParts: string[] = [];\n\n  if (defaultSlot) {\n    usageParts.push(`  <!-- Default slot content -->`);\n    usageParts.push(`  <p>Your content here</p>`);\n  }\n\n  for (const slot of namedSlots) {\n    usageParts.push(`  <!-- ${slot.description} -->`);\n    usageParts.push(`  <template #${slot.name}>`);\n    usageParts.push(`    <div>Your ${slot.name} content</div>`);\n    usageParts.push(`  </template>`);\n  }\n\n  const usageExample = `<${options.componentName}>\n${usageParts.join(\"\\n\")}\n</${options.componentName}>`;\n\n  return {\n    template,\n    scriptSetup,\n    usageExample,\n  };\n}\n\n/**\n * Generate Svelte slot code\n */\nfunction generateSvelteSlotCode(\n  slots: DetectedSlot[],\n  options: SlotDetectionOptions\n): SvelteSlotCode {\n  const defaultSlot = slots.find((s) => s.isDefault);\n  const namedSlots = slots.filter((s) => !s.isDefault);\n\n  // Generate template slots\n  const templateParts: string[] = [];\n\n  if (defaultSlot) {\n    templateParts.push(`<!-- ${defaultSlot.description} -->`);\n    if (defaultSlot.fallbackContent) {\n      templateParts.push(`<slot>${defaultSlot.fallbackContent}</slot>`);\n    } else {\n      templateParts.push(`<slot />`);\n    }\n  }\n\n  for (const slot of namedSlots) {\n    templateParts.push(`<!-- ${slot.description} -->`);\n    if (slot.fallbackContent) {\n      templateParts.push(`<slot name=\"${slot.name}\">${slot.fallbackContent}</slot>`);\n    } else {\n      templateParts.push(`<slot name=\"${slot.name}\" />`);\n    }\n  }\n\n  const template = templateParts.join(\"\\n  \");\n\n  // Generate script additions for Svelte 5 snippets (optional)\n  let script = \"\";\n  if (options.useTypeScript && namedSlots.length > 0) {\n    const snippetTypes: string[] = [];\n\n    for (const slot of namedSlots) {\n      snippetTypes.push(`  /** ${slot.description} */`);\n      snippetTypes.push(`  ${slot.name}?: import('svelte').Snippet;`);\n    }\n\n    if (defaultSlot) {\n      snippetTypes.unshift(`  /** ${defaultSlot.description} */`);\n      snippetTypes.unshift(`  children?: import('svelte').Snippet;`);\n    }\n\n    script = `// Optional: Svelte 5 snippet props for typed slots\ninterface $$Slots {\n${snippetTypes.join(\"\\n\")}\n}`;\n  }\n\n  // Generate usage example\n  const usageParts: string[] = [];\n\n  if (defaultSlot) {\n    usageParts.push(`  <!-- Default slot content -->`);\n    usageParts.push(`  <p>Your content here</p>`);\n  }\n\n  for (const slot of namedSlots) {\n    usageParts.push(`  <!-- ${slot.description} -->`);\n    usageParts.push(`  <svelte:fragment slot=\"${slot.name}\">`);\n    usageParts.push(`    <div>Your ${slot.name} content</div>`);\n    usageParts.push(`  </svelte:fragment>`);\n  }\n\n  const usageExample = `<${options.componentName}>\n${usageParts.join(\"\\n\")}\n</${options.componentName}>`;\n\n  return {\n    template,\n    script,\n    usageExample,\n  };\n}\n\n// ============================================================================\n// Additional Utilities\n// ============================================================================\n\n/**\n * Analyze a component for slot compatibility\n */\nexport function analyzeSlotCompatibility(\n  node: FigmaNode,\n  targetFramework: \"react\" | \"vue\" | \"svelte\"\n): {\n  isCompatible: boolean;\n  issues: string[];\n  suggestions: string[];\n} {\n  const result = detectSlotPatterns(node);\n  const issues: string[] = [];\n  const suggestions: string[] = [];\n\n  // Check for common issues\n  if (!result.hasDefaultSlot && result.namedSlots.length === 0) {\n    suggestions.push(\n      \"Consider adding a default content slot for flexibility.\"\n    );\n  }\n\n  if (result.namedSlots.length > 5) {\n    issues.push(\n      `High number of named slots (${result.namedSlots.length}). Consider simplifying the component structure.`\n    );\n  }\n\n  // Framework-specific checks\n  if (targetFramework === \"react\") {\n    for (const slot of result.namedSlots) {\n      if (slot.name === \"children\") {\n        issues.push(\n          \"Slot named 'children' conflicts with React's children prop.\"\n        );\n      }\n    }\n  }\n\n  if (targetFramework === \"vue\") {\n    for (const slot of result.namedSlots) {\n      if (slot.name.includes(\"-\")) {\n        suggestions.push(\n          `Slot name '${slot.name}' contains hyphens. Use camelCase for Vue slot names.`\n        );\n      }\n    }\n  }\n\n  return {\n    isCompatible: issues.length === 0,\n    issues,\n    suggestions,\n  };\n}\n\n/**\n * Generate slot documentation for a component\n */\nexport function generateSlotDocumentation(\n  result: SlotPatternResult,\n  format: \"markdown\" | \"jsdoc\" = \"markdown\"\n): string {\n  if (!result.hasSlots) {\n    return format === \"markdown\"\n      ? \"No slots detected in this component.\"\n      : \"// No slots detected\";\n  }\n\n  if (format === \"markdown\") {\n    let doc = \"## Slots\\n\\n\";\n\n    if (result.hasDefaultSlot) {\n      const defaultSlot = result.slots.find((s) => s.isDefault);\n      if (defaultSlot) {\n        doc += `### Default Slot\\n\\n${defaultSlot.description}\\n\\n`;\n      }\n    }\n\n    if (result.namedSlots.length > 0) {\n      doc += \"### Named Slots\\n\\n\";\n      doc += \"| Name | Description | Content Type |\\n\";\n      doc += \"|------|-------------|-------------|\\n\";\n\n      for (const slot of result.namedSlots) {\n        doc += `| \\`${slot.name}\\` | ${slot.description} | ${slot.expectedContentType} |\\n`;\n      }\n    }\n\n    return doc;\n  } else {\n    let doc = \"/**\\n * @slot\";\n\n    if (result.hasDefaultSlot) {\n      const defaultSlot = result.slots.find((s) => s.isDefault);\n      if (defaultSlot) {\n        doc += ` - ${defaultSlot.description}\\n`;\n      }\n    }\n\n    for (const slot of result.namedSlots) {\n      doc += ` * @slot ${slot.name} - ${slot.description}\\n`;\n    }\n\n    doc += \" */\";\n    return doc;\n  }\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport {\n  SLOT_NAME_PATTERNS,\n  PLACEHOLDER_PATTERNS,\n  CONTAINER_COMPONENT_PATTERNS,\n  DEFAULT_OPTIONS as SLOT_DETECTION_DEFAULTS,\n};\n"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Create slot pattern detector utility",
      "status": "completed",
      "activeForm": "Creating slot pattern detector utility"
    },
    {
      "content": "Update prop-interface-generator for React children/slots",
      "status": "in_progress",
      "activeForm": "Updating prop-interface-generator for React children/slots"
    },
    {
      "content": "Update svelte-component-generator for Svelte slots",
      "status": "pending",
      "activeForm": "Updating svelte-component-generator for Svelte slots"
    },
    {
      "content": "Create Vue slot generator utility",
      "status": "pending",
      "activeForm": "Creating Vue slot generator utility"
    },
    {
      "content": "Write tests for slot pattern detection",
      "status": "pending",
      "activeForm": "Writing tests for slot pattern detection"
    },
    {
      "content": "Verify with Playwright test",
      "status": "pending",
      "activeForm": "Verifying with Playwright test"
    }
  ]
}
Now let me update the prop-interface-generator to integrate with the slot pattern detector for React children/slots:

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts",
  "old_string": "import type {\n  InteractiveElementAnalysis,\n  InteractiveElementType,\n  InteractiveState,\n  VariantInfo,\n} from \"./figma-interactive-elements\";\nimport type { ResolvedComponent, ResolvedInstance } from \"./figma-component-resolver\";",
  "new_string": "import type {\n  InteractiveElementAnalysis,\n  InteractiveElementType,\n  InteractiveState,\n  VariantInfo,\n} from \"./figma-interactive-elements\";\nimport type { ResolvedComponent, ResolvedInstance } from \"./figma-component-resolver\";\nimport type { FigmaNode } from \"./figma-api\";\nimport type { DetectedSlot, SlotPatternResult } from \"./slot-pattern-detector\";\nimport { detectSlotPatterns } from \"./slot-pattern-detector\";"
}
Now let me add the slot-related types and update the InterfaceGenerationOptions:

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts",
  "old_string": "/**\n * Configuration for interface generation\n */\nexport interface InterfaceGenerationOptions {\n  /** Component name for naming the interface */\n  componentName: string;\n  /** Whether to extend React component props */\n  extendReactProps: boolean;\n  /** Base HTML element for extending native props */\n  baseElement?: BaseElementType;\n  /** Whether to generate CVA (class-variance-authority) variant types */\n  generateCVATypes: boolean;\n  /** Whether to include JSDoc comments */\n  includeJSDoc: boolean;\n  /** Whether to mark all variant props as optional with defaults */\n  variantPropsOptional: boolean;\n  /** Prefix for the interface name */\n  interfacePrefix?: string;\n  /** Suffix for the interface name */\n  interfaceSuffix?: string;\n  /** Whether to export the interface */\n  exportInterface: boolean;\n  /** Whether to include ref prop for forwardRef components */\n  includeRef: boolean;\n  /** Custom prop overrides */\n  customProps?: PropDefinition[];\n}",
  "new_string": "/**\n * Configuration for interface generation\n */\nexport interface InterfaceGenerationOptions {\n  /** Component name for naming the interface */\n  componentName: string;\n  /** Whether to extend React component props */\n  extendReactProps: boolean;\n  /** Base HTML element for extending native props */\n  baseElement?: BaseElementType;\n  /** Whether to generate CVA (class-variance-authority) variant types */\n  generateCVATypes: boolean;\n  /** Whether to include JSDoc comments */\n  includeJSDoc: boolean;\n  /** Whether to mark all variant props as optional with defaults */\n  variantPropsOptional: boolean;\n  /** Prefix for the interface name */\n  interfacePrefix?: string;\n  /** Suffix for the interface name */\n  interfaceSuffix?: string;\n  /** Whether to export the interface */\n  exportInterface: boolean;\n  /** Whether to include ref prop for forwardRef components */\n  includeRef: boolean;\n  /** Custom prop overrides */\n  customProps?: PropDefinition[];\n  /** Whether to detect and include slot props */\n  detectSlots: boolean;\n  /** Figma node for slot detection (required if detectSlots is true) */\n  figmaNode?: FigmaNode;\n  /** Whether to use render props pattern for named slots */\n  useRenderProps: boolean;\n}"
}
Now update the DEFAULT_OPTIONS:

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts",
  "old_string": "const DEFAULT_OPTIONS: InterfaceGenerationOptions = {\n  componentName: \"Component\",\n  extendReactProps: true,\n  baseElement: \"div\",\n  generateCVATypes: true,\n  includeJSDoc: true,\n  variantPropsOptional: true,\n  exportInterface: true,\n  includeRef: false,\n};",
  "new_string": "const DEFAULT_OPTIONS: InterfaceGenerationOptions = {\n  componentName: \"Component\",\n  extendReactProps: true,\n  baseElement: \"div\",\n  generateCVATypes: true,\n  includeJSDoc: true,\n  variantPropsOptional: true,\n  exportInterface: true,\n  includeRef: false,\n  detectSlots: true,\n  useRenderProps: false,\n};"
}
Now let me add the GeneratedInterface enhancement and the slot props generation function:

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts",
  "old_string": "/**\n * Generated interface result\n */\nexport interface GeneratedInterface {\n  /** Interface name (PascalCase) */\n  name: string;\n  /** Full interface code */\n  code: string;\n  /** Individual prop definitions */\n  props: PropDefinition[];\n  /** Base types the interface extends */\n  extends: string[];\n  /** Whether this is a component props interface */\n  isComponentProps: boolean;\n  /** Associated CVA variant props type if applicable */\n  cvaVariantProps?: string;\n  /** Import statements needed */\n  imports: string[];\n  /** Statistics about the generation */\n  stats: InterfaceGenerationStats;\n}",
  "new_string": "/**\n * Generated interface result\n */\nexport interface GeneratedInterface {\n  /** Interface name (PascalCase) */\n  name: string;\n  /** Full interface code */\n  code: string;\n  /** Individual prop definitions */\n  props: PropDefinition[];\n  /** Base types the interface extends */\n  extends: string[];\n  /** Whether this is a component props interface */\n  isComponentProps: boolean;\n  /** Associated CVA variant props type if applicable */\n  cvaVariantProps?: string;\n  /** Import statements needed */\n  imports: string[];\n  /** Statistics about the generation */\n  stats: InterfaceGenerationStats;\n  /** Slot pattern detection result */\n  slotPatternResult?: SlotPatternResult;\n  /** Slot-related props */\n  slotProps?: PropDefinition[];\n}"
}
Now let me add the function to generate slot props and update the generatePropInterfaceImpl function. Let me find where that function is:

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts",
  "offset": 1120,
  "limit": 200
}
Now let me update the generatePropInterfaceImpl function to include slot detection:

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts",
  "old_string": "/**\n * Generate a TypeScript interface from component analysis\n */\nfunction generatePropInterfaceImpl(\n  componentSetInput: ComponentSetInput | null,\n  interactiveInput: InteractiveElementInput | null,\n  options: Partial<InterfaceGenerationOptions> = {}\n): GeneratedInterface {\n  const opts: InterfaceGenerationOptions = { ...DEFAULT_OPTIONS, ...options };\n  const allProps: PropDefinition[] = [];\n  const imports: string[] = [];\n\n  // Collect props from component set\n  if (componentSetInput) {\n    const variantProps = analyzeVariantPropertiesImpl(\n      componentSetInput.variantProperties,\n      componentSetInput.variants\n    );\n    allProps.push(...variantProps);\n  }\n\n  // Collect props from interactive element\n  if (interactiveInput) {\n    const elementProps = inferPropsFromInteractiveElementImpl(interactiveInput);\n    allProps.push(...elementProps);\n  }\n\n  // Add custom props\n  if (opts.customProps) {\n    allProps.push(...opts.customProps);\n  }\n\n  // Add common props\n  allProps.push(\n    createProp(\n      \"className\",\n      \"className\",\n      false,\n      \"Additional CSS class names.\",\n      undefined,\n      undefined,\n      \"default\"\n    )\n  );\n\n  if (opts.includeRef) {\n    allProps.push(\n      createProp(\n        \"ref\",\n        \"ref\",\n        false,\n        \"Ref to the underlying DOM element.\",\n        undefined,\n        undefined,\n        \"default\"\n      )\n    );\n  }\n\n  // Deduplicate\n  const props = deduplicateProps(allProps);\n\n  // Determine imports\n  if (props.some((p) => p.typeString.includes(\"React.\"))) {\n    imports.push('import * as React from \"react\";');\n  }\n\n  // Generate interface name\n  const interfaceName = generateInterfaceName(opts);\n\n  // Generate extends clause\n  const extendsTypes = generateExtendsClause(opts);\n\n  // Generate CVA variant props if needed\n  let cvaVariantProps: string | undefined;\n  if (opts.generateCVATypes && componentSetInput) {\n    cvaVariantProps = generateCVAVariantProps(componentSetInput, opts);\n  }\n\n  // Generate the interface code\n  const code = generateInterfaceCode(interfaceName, props, extendsTypes, cvaVariantProps, opts);\n\n  // Calculate stats\n  const stats = calculateInterfaceStats(props);\n\n  return {\n    name: interfaceName,\n    code,\n    props,\n    extends: extendsTypes,\n    isComponentProps: true,\n    cvaVariantProps,\n    imports,\n    stats,\n  };\n}",
  "new_string": "/**\n * Generate a TypeScript interface from component analysis\n */\nfunction generatePropInterfaceImpl(\n  componentSetInput: ComponentSetInput | null,\n  interactiveInput: InteractiveElementInput | null,\n  options: Partial<InterfaceGenerationOptions> = {}\n): GeneratedInterface {\n  const opts: InterfaceGenerationOptions = { ...DEFAULT_OPTIONS, ...options };\n  const allProps: PropDefinition[] = [];\n  const imports: string[] = [];\n  let slotPatternResult: SlotPatternResult | undefined;\n  let slotProps: PropDefinition[] = [];\n\n  // Collect props from component set\n  if (componentSetInput) {\n    const variantProps = analyzeVariantPropertiesImpl(\n      componentSetInput.variantProperties,\n      componentSetInput.variants\n    );\n    allProps.push(...variantProps);\n  }\n\n  // Collect props from interactive element\n  if (interactiveInput) {\n    const elementProps = inferPropsFromInteractiveElementImpl(interactiveInput);\n    allProps.push(...elementProps);\n  }\n\n  // Add custom props\n  if (opts.customProps) {\n    allProps.push(...opts.customProps);\n  }\n\n  // Detect and add slot props\n  if (opts.detectSlots && opts.figmaNode) {\n    slotPatternResult = detectSlotPatterns(opts.figmaNode, {\n      componentName: opts.componentName,\n      useTypeScript: true,\n      framework: \"react\",\n    });\n\n    if (slotPatternResult.hasSlots) {\n      slotProps = generateSlotPropsFromResult(slotPatternResult, opts);\n      allProps.push(...slotProps);\n    }\n  }\n\n  // Add common props\n  allProps.push(\n    createProp(\n      \"className\",\n      \"className\",\n      false,\n      \"Additional CSS class names.\",\n      undefined,\n      undefined,\n      \"default\"\n    )\n  );\n\n  if (opts.includeRef) {\n    allProps.push(\n      createProp(\n        \"ref\",\n        \"ref\",\n        false,\n        \"Ref to the underlying DOM element.\",\n        undefined,\n        undefined,\n        \"default\"\n      )\n    );\n  }\n\n  // Deduplicate\n  const props = deduplicateProps(allProps);\n\n  // Determine imports\n  if (props.some((p) => p.typeString.includes(\"React.\"))) {\n    imports.push('import * as React from \"react\";');\n  }\n\n  // Generate interface name\n  const interfaceName = generateInterfaceName(opts);\n\n  // Generate extends clause\n  const extendsTypes = generateExtendsClause(opts);\n\n  // Generate CVA variant props if needed\n  let cvaVariantProps: string | undefined;\n  if (opts.generateCVATypes && componentSetInput) {\n    cvaVariantProps = generateCVAVariantProps(componentSetInput, opts);\n  }\n\n  // Generate the interface code\n  const code = generateInterfaceCode(interfaceName, props, extendsTypes, cvaVariantProps, opts);\n\n  // Calculate stats\n  const stats = calculateInterfaceStats(props);\n\n  return {\n    name: interfaceName,\n    code,\n    props,\n    extends: extendsTypes,\n    isComponentProps: true,\n    cvaVariantProps,\n    imports,\n    stats,\n    slotPatternResult,\n    slotProps,\n  };\n}\n\n/**\n * Generate prop definitions from slot pattern result\n */\nfunction generateSlotPropsFromResult(\n  slotResult: SlotPatternResult,\n  options: InterfaceGenerationOptions\n): PropDefinition[] {\n  const props: PropDefinition[] = [];\n\n  for (const slot of slotResult.slots) {\n    const propDef = createSlotProp(slot, options);\n    props.push(propDef);\n  }\n\n  return props;\n}\n\n/**\n * Create a prop definition for a detected slot\n */\nfunction createSlotProp(\n  slot: DetectedSlot,\n  options: InterfaceGenerationOptions\n): PropDefinition {\n  // Determine prop name\n  const propName = slot.isDefault ? \"children\" : slot.name;\n\n  // Determine type based on slot type and options\n  let typeString: string;\n  let type: InferredPropType;\n\n  if (slot.isDefault) {\n    type = \"children\";\n    typeString = \"React.ReactNode\";\n  } else if (options.useRenderProps) {\n    type = \"function\";\n    typeString = \"(() => React.ReactNode) | React.ReactNode\";\n  } else {\n    type = \"ReactNode\";\n    typeString = \"React.ReactNode\";\n  }\n\n  return {\n    name: propName,\n    type,\n    typeString,\n    required: slot.required,\n    defaultValue: undefined,\n    description: slot.description,\n    inferenceSource: \"content-slot\",\n    confidence: slot.confidence,\n    jsdocTags: slot.type !== \"default\"\n      ? [{ tag: \"slot\", value: slot.name }]\n      : undefined,\n  };\n}"
}
Now let's also add a utility function to generate React slot props from a Figma node. Let me add the exports at the end:

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts",
  "offset": 1530,
  "limit": 100
}
Let me add a dedicated function to generate slots from a Figma node and update the exports:

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/prop-interface-generator.ts",
  "old_string": "// ============================================================================\n// Exports\n// ============================================================================\n\nexport const analyzeVariantProperties = analyzeVariantPropertiesImpl;\nexport const inferPropsFromInteractiveElement = inferPropsFromInteractiveElementImpl;\nexport const generatePropInterface = generatePropInterfaceImpl;\nexport const generateInterfaceFromComponentSet = generateInterfaceFromComponentSetImpl;\nexport const generateInterfaceFromElement = generateInterfaceFromElementImpl;\nexport const generateInterfacesFromComponents = generateInterfacesFromComponentsImpl;\nexport const normalizeVariantPropertyName = normalizeVariantPropertyNameImpl;\nexport const sanitizeComponentName = sanitizeComponentNameImpl;",
  "new_string": "/**\n * Generate slot props from a Figma node\n * Convenience function for direct slot detection without full interface generation\n */\nfunction generateSlotPropsFromNodeImpl(\n  node: FigmaNode,\n  options?: Partial<InterfaceGenerationOptions>\n): {\n  slots: DetectedSlot[];\n  props: PropDefinition[];\n  react: ReactSlotCode;\n} {\n  const opts: InterfaceGenerationOptions = { ...DEFAULT_OPTIONS, ...options };\n\n  const slotResult = detectSlotPatterns(node, {\n    componentName: opts.componentName,\n    useTypeScript: true,\n    framework: \"react\",\n  });\n\n  const props = slotResult.hasSlots\n    ? generateSlotPropsFromResult(slotResult, opts)\n    : [];\n\n  return {\n    slots: slotResult.slots,\n    props,\n    react: slotResult.frameworkCode.react,\n  };\n}\n\n// Import ReactSlotCode type for the return type\ntype ReactSlotCode = SlotPatternResult[\"frameworkCode\"][\"react\"];\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport const analyzeVariantProperties = analyzeVariantPropertiesImpl;\nexport const inferPropsFromInteractiveElement = inferPropsFromInteractiveElementImpl;\nexport const generatePropInterface = generatePropInterfaceImpl;\nexport const generateInterfaceFromComponentSet = generateInterfaceFromComponentSetImpl;\nexport const generateInterfaceFromElement = generateInterfaceFromElementImpl;\nexport const generateInterfacesFromComponents = generateInterfacesFromComponentsImpl;\nexport const normalizeVariantPropertyName = normalizeVariantPropertyNameImpl;\nexport const sanitizeComponentName = sanitizeComponentNameImpl;\nexport const generateSlotPropsFromNode = generateSlotPropsFromNodeImpl;"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Create slot pattern detector utility",
      "status": "completed",
      "activeForm": "Creating slot pattern detector utility"
    },
    {
      "content": "Update prop-interface-generator for React children/slots",
      "status": "completed",
      "activeForm": "Updating prop-interface-generator for React children/slots"
    },
    {
      "content": "Update svelte-component-generator for Svelte slots",
      "status": "in_progress",
      "activeForm": "Updating svelte-component-generator for Svelte slots"
    },
    {
      "content": "Create Vue slot generator utility",
      "status": "pending",
      "activeForm": "Creating Vue slot generator utility"
    },
    {
      "content": "Write tests for slot pattern detection",
      "status": "pending",
      "activeForm": "Writing tests for slot pattern detection"
    },
    {
      "content": "Verify with Playwright test",
      "status": "pending",
      "activeForm": "Verifying with Playwright test"
    }
  ]
}
Now let me update the svelte-component-generator to integrate with the slot pattern detector:

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/svelte-component-generator.ts",
  "offset": 1,
  "limit": 100
}
Now let me add the imports for slot pattern detector and add a new function for generating Svelte components with slots. Let me read more of the file to understand the structure:

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/svelte-component-generator.ts",
  "offset": 2100,
  "limit": 50
}
Now let me update the svelte-component-generator to add slot support:

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/svelte-component-generator.ts",
  "old_string": "import type { BoundingBox } from \"./layout-analyzer\";\nimport type {\n  ListPatternResult,\n  ListPatternType,\n  ListSemanticType,\n  ListStructure,\n  ListItemInfo,\n  ItemContentType,\n} from \"./list-pattern-detector\";\nimport type { FormAnalysisResult, FormFieldGroup } from \"./form-analyzer\";\nimport type { NavigationPatternAnalysis, NavigationItem } from \"./navigation-pattern-detector\";",
  "new_string": "import type { BoundingBox } from \"./layout-analyzer\";\nimport type {\n  ListPatternResult,\n  ListPatternType,\n  ListSemanticType,\n  ListStructure,\n  ListItemInfo,\n  ItemContentType,\n} from \"./list-pattern-detector\";\nimport type { FormAnalysisResult, FormFieldGroup } from \"./form-analyzer\";\nimport type { NavigationPatternAnalysis, NavigationItem } from \"./navigation-pattern-detector\";\nimport type { FigmaNode } from \"./figma-api\";\nimport type { DetectedSlot, SlotPatternResult, SvelteSlotCode } from \"./slot-pattern-detector\";\nimport { detectSlotPatterns } from \"./slot-pattern-detector\";"
}
Now let me add the slot-based component generation functions at the end of the file:

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/svelte-component-generator.ts",
  "old_string": "// ============================================================================\n// Exports\n// ============================================================================\n\nexport { DEFAULT_OPTIONS as SVELTE_GENERATION_DEFAULTS };",
  "new_string": "// ============================================================================\n// Slot-Based Component Generation\n// ============================================================================\n\n/**\n * Configuration for slot-based Svelte component generation\n */\nexport interface SvelteSlotComponentOptions extends Partial<SvelteGenerationOptions> {\n  /** Component name */\n  componentName: string;\n  /** Base element for the component */\n  baseElement?: string;\n  /** Additional component classes */\n  componentClasses?: string;\n  /** Additional props to include */\n  additionalProps?: Array<{\n    name: string;\n    type: string;\n    defaultValue?: string;\n    description?: string;\n  }>;\n}\n\n/**\n * Generated slot-based Svelte component\n */\nexport interface GeneratedSlotComponent {\n  /** Complete .svelte component file content */\n  component: string;\n  /** TypeScript types for the component */\n  types: string;\n  /** Detected slots from the Figma node */\n  slots: DetectedSlot[];\n  /** Slot code for Svelte */\n  slotCode: SvelteSlotCode;\n  /** Usage example */\n  usageExample: string;\n}\n\n/**\n * Generate a Svelte component with slots from a Figma node\n */\nexport function generateSvelteSlotComponent(\n  node: FigmaNode,\n  options: SvelteSlotComponentOptions\n): GeneratedSlotComponent {\n  const opts: SvelteGenerationOptions = { ...DEFAULT_OPTIONS, ...options };\n  const { componentName, baseElement = \"div\", componentClasses = \"\", additionalProps = [] } = options;\n\n  // Detect slots from the Figma node\n  const slotResult = detectSlotPatterns(node, {\n    componentName,\n    useTypeScript: opts.useTypeScript,\n    framework: \"svelte\",\n  });\n\n  const slotCode = slotResult.frameworkCode.svelte;\n\n  // Generate the component\n  const component = generateSlotComponentCode(\n    componentName,\n    baseElement,\n    componentClasses,\n    slotResult,\n    additionalProps,\n    opts\n  );\n\n  // Generate types\n  const types = generateSlotComponentTypes(componentName, slotResult, additionalProps, opts);\n\n  // Generate usage example\n  const usageExample = slotCode.usageExample;\n\n  return {\n    component,\n    types,\n    slots: slotResult.slots,\n    slotCode,\n    usageExample,\n  };\n}\n\n/**\n * Generate the slot component code\n */\nfunction generateSlotComponentCode(\n  componentName: string,\n  baseElement: string,\n  componentClasses: string,\n  slotResult: SlotPatternResult,\n  additionalProps: SvelteSlotComponentOptions[\"additionalProps\"],\n  options: SvelteGenerationOptions\n): string {\n  const scriptLang = options.useTypeScript ? ' lang=\"ts\"' : \"\";\n  const { slots } = slotResult;\n\n  // Script section\n  let script = `<script${scriptLang}>`;\n\n  // Imports\n  if (options.includeTransitions) {\n    script += `\\n  import { fade, slide } from 'svelte/transition';`;\n  }\n\n  // Props\n  if (options.useSvelte5Runes) {\n    // Svelte 5 runes syntax\n    const propsInterface = generateSvelte5PropsInterface(componentName, slots, additionalProps, options);\n    script += `\\n\\n${propsInterface}`;\n  } else {\n    // Classic Svelte syntax\n    script += `\\n\\n  /** Additional CSS classes */`;\n    script += `\\n  export let className = '';`;\n\n    for (const prop of additionalProps || []) {\n      const description = prop.description ? `\\n  /** ${prop.description} */` : \"\";\n      const defaultValue = prop.defaultValue ? ` = ${prop.defaultValue}` : \"\";\n      script += `${description}`;\n      script += `\\n  export let ${prop.name}${options.useTypeScript ? `: ${prop.type}` : \"\"}${defaultValue};`;\n    }\n  }\n\n  script += `\\n</script>`;\n\n  // Template section\n  const template = generateSlotTemplate(baseElement, componentClasses, slots, options);\n\n  // Style section\n  const style = options.useTailwind ? \"\" : generateSlotComponentStyles(options);\n\n  return `${script}\\n\\n${template}${style}`;\n}\n\n/**\n * Generate Svelte 5 props interface with runes\n */\nfunction generateSvelte5PropsInterface(\n  componentName: string,\n  slots: DetectedSlot[],\n  additionalProps: SvelteSlotComponentOptions[\"additionalProps\"],\n  options: SvelteGenerationOptions\n): string {\n  let code = `  interface Props {`;\n  code += `\\n    /** Additional CSS classes */`;\n  code += `\\n    class?: string;`;\n\n  for (const prop of additionalProps || []) {\n    const description = prop.description ? `\\n    /** ${prop.description} */` : \"\";\n    const optional = prop.defaultValue ? \"?\" : \"\";\n    code += `${description}`;\n    code += `\\n    ${prop.name}${optional}: ${prop.type};`;\n  }\n\n  // Add snippet props for slots (Svelte 5)\n  for (const slot of slots) {\n    const slotName = slot.isDefault ? \"children\" : slot.name;\n    code += `\\n    /** ${slot.description} */`;\n    code += `\\n    ${slotName}?: import('svelte').Snippet;`;\n  }\n\n  code += `\\n  }`;\n  code += `\\n`;\n  code += `\\n  let { class: className = ''`;\n\n  for (const prop of additionalProps || []) {\n    const defaultValue = prop.defaultValue ? ` = ${prop.defaultValue}` : \"\";\n    code += `, ${prop.name}${defaultValue}`;\n  }\n\n  for (const slot of slots) {\n    const slotName = slot.isDefault ? \"children\" : slot.name;\n    code += `, ${slotName}`;\n  }\n\n  code += ` }: Props = $props();`;\n\n  return code;\n}\n\n/**\n * Generate the slot template\n */\nfunction generateSlotTemplate(\n  baseElement: string,\n  componentClasses: string,\n  slots: DetectedSlot[],\n  options: SvelteGenerationOptions\n): string {\n  const classAttr = componentClasses\n    ? `class=\"${componentClasses} {className}\"`\n    : `class={className}`;\n\n  const defaultSlot = slots.find(s => s.isDefault);\n  const namedSlots = slots.filter(s => !s.isDefault);\n\n  // Sort named slots by position\n  const positionOrder = [\"start\", \"before\", \"center\", \"after\", \"end\", \"overlay\"];\n  const sortedNamedSlots = [...namedSlots].sort(\n    (a, b) => positionOrder.indexOf(a.position) - positionOrder.indexOf(b.position)\n  );\n\n  // Build template\n  let template = `<${baseElement} ${classAttr}>`;\n\n  // Add slots in order based on position\n  const startSlots = sortedNamedSlots.filter(s => s.position === \"start\" || s.position === \"before\");\n  const endSlots = sortedNamedSlots.filter(s => s.position === \"end\" || s.position === \"after\");\n  const overlaySlots = sortedNamedSlots.filter(s => s.position === \"overlay\");\n\n  // Start/before slots\n  for (const slot of startSlots) {\n    template += `\\n  <!-- ${slot.description} -->`;\n    if (slot.fallbackContent) {\n      template += `\\n  <slot name=\"${slot.name}\">${slot.fallbackContent}</slot>`;\n    } else {\n      template += `\\n  <slot name=\"${slot.name}\" />`;\n    }\n  }\n\n  // Default slot\n  if (defaultSlot) {\n    template += `\\n  <!-- ${defaultSlot.description} -->`;\n    if (defaultSlot.fallbackContent) {\n      template += `\\n  <slot>${defaultSlot.fallbackContent}</slot>`;\n    } else {\n      template += `\\n  <slot />`;\n    }\n  } else if (slots.length === 0) {\n    // No slots detected, add a default slot anyway\n    template += `\\n  <!-- Default content slot -->`;\n    template += `\\n  <slot />`;\n  }\n\n  // End/after slots\n  for (const slot of endSlots) {\n    template += `\\n  <!-- ${slot.description} -->`;\n    if (slot.fallbackContent) {\n      template += `\\n  <slot name=\"${slot.name}\">${slot.fallbackContent}</slot>`;\n    } else {\n      template += `\\n  <slot name=\"${slot.name}\" />`;\n    }\n  }\n\n  // Overlay slots\n  for (const slot of overlaySlots) {\n    template += `\\n  <!-- ${slot.description} -->`;\n    template += `\\n  {#if $$slots.${slot.name}}`;\n    template += `\\n    <div class=\"${options.useTailwind ? \"absolute inset-0\" : \"overlay\"}\">`;\n    if (slot.fallbackContent) {\n      template += `\\n      <slot name=\"${slot.name}\">${slot.fallbackContent}</slot>`;\n    } else {\n      template += `\\n      <slot name=\"${slot.name}\" />`;\n    }\n    template += `\\n    </div>`;\n    template += `\\n  {/if}`;\n  }\n\n  template += `\\n</${baseElement}>`;\n\n  return template;\n}\n\n/**\n * Generate component styles for non-Tailwind usage\n */\nfunction generateSlotComponentStyles(options: SvelteGenerationOptions): string {\n  return `\n\n<style>\n  .overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n  }\n</style>`;\n}\n\n/**\n * Generate TypeScript types for the slot component\n */\nfunction generateSlotComponentTypes(\n  componentName: string,\n  slotResult: SlotPatternResult,\n  additionalProps: SvelteSlotComponentOptions[\"additionalProps\"],\n  options: SvelteGenerationOptions\n): string {\n  if (!options.useTypeScript) {\n    return \"// TypeScript types not generated (useTypeScript: false)\";\n  }\n\n  let types = `/**\\n * Props for ${componentName} component\\n */\\n`;\n  types += `export interface ${componentName}Props {\\n`;\n  types += `  /** Additional CSS classes */\\n`;\n  types += `  class?: string;\\n`;\n\n  for (const prop of additionalProps || []) {\n    const description = prop.description ? `  /** ${prop.description} */\\n` : \"\";\n    const optional = prop.defaultValue ? \"?\" : \"\";\n    types += `${description}`;\n    types += `  ${prop.name}${optional}: ${prop.type};\\n`;\n  }\n\n  types += `}\\n\\n`;\n\n  // Slot types\n  types += `/**\\n * Slots for ${componentName} component\\n */\\n`;\n  types += `export interface ${componentName}Slots {\\n`;\n\n  for (const slot of slotResult.slots) {\n    const slotName = slot.isDefault ? \"default\" : slot.name;\n    types += `  /** ${slot.description} */\\n`;\n    types += `  ${slotName}?: import('svelte').Snippet;\\n`;\n  }\n\n  types += `}\\n`;\n\n  return types;\n}\n\n/**\n * Generate a slot-aware wrapper component from Figma design\n */\nexport function generateSvelteWrapperComponent(\n  node: FigmaNode,\n  componentName: string,\n  options: Partial<SvelteGenerationOptions> = {}\n): GeneratedSvelteCode {\n  const opts: SvelteGenerationOptions = { ...DEFAULT_OPTIONS, ...options };\n\n  // Detect slots\n  const slotResult = detectSlotPatterns(node, {\n    componentName,\n    useTypeScript: opts.useTypeScript,\n    framework: \"svelte\",\n  });\n\n  // Generate component\n  const slotComponent = generateSvelteSlotComponent(node, {\n    ...opts,\n    componentName,\n  });\n\n  return {\n    component: slotComponent.component,\n    types: slotComponent.types,\n    styles: \"\",\n    stores: \"\",\n    actions: \"\",\n  };\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport { DEFAULT_OPTIONS as SVELTE_GENERATION_DEFAULTS };"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Create slot pattern detector utility",
      "status": "completed",
      "activeForm": "Creating slot pattern detector utility"
    },
    {
      "content": "Update prop-interface-generator for React children/slots",
      "status": "completed",
      "activeForm": "Updating prop-interface-generator for React children/slots"
    },
    {
      "content": "Update svelte-component-generator for Svelte slots",
      "status": "completed",
      "activeForm": "Updating svelte-component-generator for Svelte slots"
    },
    {
      "content": "Create Vue slot generator utility",
      "status": "in_progress",
      "activeForm": "Creating Vue slot generator utility"
    },
    {
      "content": "Write tests for slot pattern detection",
      "status": "pending",
      "activeForm": "Writing tests for slot pattern detection"
    },
    {
      "content": "Verify with Playwright test",
      "status": "pending",
      "activeForm": "Verifying with Playwright test"
    }
  ]
}
Now let me create the Vue slot generator utility: