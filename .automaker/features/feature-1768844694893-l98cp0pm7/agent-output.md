I'll implement this feature for generating styled-components/emotion code. Let me start by exploring the codebase to understand the existing structure and patterns.

ðŸ”§ Tool: Task
Input: {
  "subagent_type": "Explore",
  "prompt": "Explore the codebase to understand:\n1. The existing code generation patterns - look for any CSS generation, code generation, or transformation utilities\n2. How the Figma-to-code conversion currently works\n3. The project structure, especially src/utils/, src/components/, and any code generation related files\n4. Any existing theming or styling patterns used\n5. TypeScript patterns and type definitions\n\nFocus on finding files related to:\n- Code generation\n- CSS/styling transformation\n- Figma data processing\n- Template generation\n\nBe thorough in the search - check for patterns like \"generate\", \"transform\", \"emit\", \"render\", \"code\", \"css\", \"style\".",
  "description": "Explore codebase structure"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "src/**/*"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "find /home/rainman/figma-to-code/figma-to-code -type f -name \"*.ts\" -o -name \"*.tsx\" -o -name \"*.js\" -o -name \"*.json\" | head -50",
  "description": "List project files to understand structure"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/package.json"
}

ðŸ”§ Tool: Grep
Input: {
  "pattern": "generate|transform|emit|render|figma|code.gen|template",
  "type": "ts"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "find /home/rainman/figma-to-code/figma-to-code/src -type d",
  "description": "List directory structure in src"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "src/utils/**/*"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/tailwind-generator.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/svelte-component-generator.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/tailwind-figma-integration.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/types/css-frameworks.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/figma-api.ts",
  "limit": 100
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/list-pattern-detector.ts",
  "limit": 150
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/layout-analyzer.ts",
  "limit": 100
}

ðŸ”§ Tool: Bash
Input: {
  "command": "ls -la /home/rainman/figma-to-code/figma-to-code/src/routes/",
  "description": "List API routes and page structure"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "ls -la /home/rainman/figma-to-code/figma-to-code/src/routes/api/",
  "description": "List API routes"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "ls -la /home/rainman/figma-to-code/figma-to-code/src/routes/api/figma/",
  "description": "List Figma API routes"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/db/schema.ts",
  "limit": 150
}

ðŸ”§ Tool: Bash
Input: {
  "command": "find /home/rainman/figma-to-code/figma-to-code/tests -name \"*.spec.ts\" -o -name \"*.test.ts\" | head -10",
  "description": "Find test files related to generation"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/tests/tailwind-generator.spec.ts",
  "limit": 80
}

ðŸ”§ Tool: Bash
Input: {
  "command": "find /home/rainman/figma-to-code/figma-to-code/src -name \"*generator*\" -o -name \"*transform*\" -o -name \"*emit*\" | grep -E \"\\.(ts|tsx)$\"",
  "description": "Find all generation/transformation utilities"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "grep -r \"export.*function.*generate\\|export.*function.*convert\\|export.*function.*emit\\|export.*function.*render\" /home/rainman/figma-to-code/figma-to-code/src/utils --include=\"*.ts\" | head -20",
  "description": "Find key generation functions"
}
Excellent! Now I have a comprehensive understanding of the codebase. Let me read the key files to understand the existing patterns more deeply before implementing the styled-components/emotion generator.

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/types/css-frameworks.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/tailwind-generator.ts"
}
Now let me also read the svelte-component-generator to understand the component generation patterns:

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/svelte-component-generator.ts",
  "limit": 500
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/figma-gradient.ts"
}
Now I have a good understanding of the codebase. Let me create a todo list and start implementing the styled-components/emotion generator.

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Create styled-components generator with template literals",
      "status": "in_progress",
      "activeForm": "Creating styled-components generator"
    },
    {
      "content": "Add theming support (ThemeProvider, useTheme)",
      "status": "pending",
      "activeForm": "Adding theming support"
    },
    {
      "content": "Implement dynamic props support for styled components",
      "status": "pending",
      "activeForm": "Implementing dynamic props support"
    },
    {
      "content": "Add style composition utilities (styled.extend, css helper)",
      "status": "pending",
      "activeForm": "Adding style composition utilities"
    },
    {
      "content": "Generate TypeScript types for styled components",
      "status": "pending",
      "activeForm": "Generating TypeScript types"
    },
    {
      "content": "Create emotion generator with similar features",
      "status": "pending",
      "activeForm": "Creating emotion generator"
    },
    {
      "content": "Add unit/integration exports and tests",
      "status": "pending",
      "activeForm": "Adding exports and tests"
    },
    {
      "content": "Verify with Playwright tests",
      "status": "pending",
      "activeForm": "Verifying with Playwright tests"
    }
  ]
}
Now let me create the styled-components/emotion generator. I'll create a comprehensive utility file that handles both styled-components and emotion:

ðŸ”§ Tool: Write
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/styled-components-generator.ts",
  "content": "/**\n * Styled-Components & Emotion CSS-in-JS Generator\n *\n * Generates styled-components and Emotion code with template literals from Figma design properties.\n * Supports:\n * - Dynamic props-based styling\n * - Theme integration with ThemeProvider\n * - Style composition (styled.extend, css helper)\n * - Full TypeScript type generation\n * - Responsive design support\n * - Dark mode theming\n *\n * @see https://styled-components.com/docs\n * @see https://emotion.sh/docs/introduction\n */\n\nimport type { FigmaColor, FigmaNode } from \"./figma-api\";\nimport {\n  figmaColorToHex,\n  figmaColorToRgba,\n  figmaColorToHsl,\n} from \"./figma-gradient\";\nimport type { FigmaDesignProperties, DesignToken, DesignTokenType } from \"./tailwind-generator\";\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * CSS-in-JS library to target\n */\nexport type CSSInJSLibrary = \"styled-components\" | \"emotion\";\n\n/**\n * Color format options\n */\nexport type ColorFormat = \"hex\" | \"rgb\" | \"hsl\";\n\n/**\n * Breakpoint configuration for responsive styles\n */\nexport interface BreakpointConfig {\n  name: string;\n  minWidth: number;\n}\n\n/**\n * Theme token types\n */\nexport interface ThemeColors {\n  primary: string;\n  secondary: string;\n  background: string;\n  surface: string;\n  text: string;\n  textMuted: string;\n  border: string;\n  error: string;\n  warning: string;\n  success: string;\n  info: string;\n  [key: string]: string;\n}\n\nexport interface ThemeSpacing {\n  xs: string;\n  sm: string;\n  md: string;\n  lg: string;\n  xl: string;\n  \"2xl\": string;\n  [key: string]: string;\n}\n\nexport interface ThemeFontSizes {\n  xs: string;\n  sm: string;\n  base: string;\n  lg: string;\n  xl: string;\n  \"2xl\": string;\n  \"3xl\": string;\n  \"4xl\": string;\n  [key: string]: string;\n}\n\nexport interface ThemeFontWeights {\n  normal: number;\n  medium: number;\n  semibold: number;\n  bold: number;\n  [key: string]: number;\n}\n\nexport interface ThemeBorderRadius {\n  none: string;\n  sm: string;\n  md: string;\n  lg: string;\n  xl: string;\n  full: string;\n  [key: string]: string;\n}\n\nexport interface ThemeShadows {\n  sm: string;\n  md: string;\n  lg: string;\n  xl: string;\n  [key: string]: string;\n}\n\nexport interface ThemeBreakpoints {\n  sm: string;\n  md: string;\n  lg: string;\n  xl: string;\n  \"2xl\": string;\n  [key: string]: string;\n}\n\nexport interface ThemeZIndex {\n  dropdown: number;\n  modal: number;\n  tooltip: number;\n  [key: string]: number;\n}\n\n/**\n * Complete theme configuration\n */\nexport interface Theme {\n  colors: ThemeColors;\n  spacing: ThemeSpacing;\n  fontSizes: ThemeFontSizes;\n  fontWeights: ThemeFontWeights;\n  fontFamily: {\n    sans: string;\n    serif: string;\n    mono: string;\n    [key: string]: string;\n  };\n  lineHeights: {\n    tight: string;\n    normal: string;\n    relaxed: string;\n    [key: string]: string;\n  };\n  borderRadius: ThemeBorderRadius;\n  shadows: ThemeShadows;\n  breakpoints: ThemeBreakpoints;\n  zIndex: ThemeZIndex;\n  transitions: {\n    fast: string;\n    normal: string;\n    slow: string;\n    [key: string]: string;\n  };\n}\n\n/**\n * Dark theme overrides (typically just colors)\n */\nexport interface DarkTheme {\n  colors: Partial<ThemeColors>;\n}\n\n/**\n * Dynamic prop definition for styled components\n */\nexport interface DynamicProp {\n  name: string;\n  type: string;\n  defaultValue?: string;\n  cssProperty: string;\n  themeKey?: keyof Theme;\n  transform?: (value: string) => string;\n}\n\n/**\n * Styled component definition\n */\nexport interface StyledComponentDefinition {\n  name: string;\n  baseElement: string;\n  styles: string;\n  dynamicProps: DynamicProp[];\n  variants?: Record<string, Record<string, string>>;\n  responsiveStyles?: Partial<Record<keyof ThemeBreakpoints, string>>;\n}\n\n/**\n * Generation options\n */\nexport interface StyledGenerationOptions {\n  /** Target library */\n  library: CSSInJSLibrary;\n  /** Whether to use TypeScript */\n  useTypeScript: boolean;\n  /** Whether to generate theme */\n  generateTheme: boolean;\n  /** Whether to generate dark theme */\n  generateDarkTheme: boolean;\n  /** Whether to use CSS prop (emotion) */\n  useCSSProp: boolean;\n  /** Whether to generate Server Style Sheet (styled-components) */\n  useServerStyleSheet: boolean;\n  /** Color format */\n  colorFormat: ColorFormat;\n  /** Custom component prefix */\n  componentPrefix: string;\n  /** Whether to include helper utilities */\n  includeHelpers: boolean;\n  /** Breakpoint configuration */\n  breakpoints: BreakpointConfig[];\n}\n\n/**\n * Generated output\n */\nexport interface StyledGenerationResult {\n  /** Styled component code */\n  component: string;\n  /** TypeScript types */\n  types: string;\n  /** Theme definition */\n  theme: string;\n  /** Theme provider setup */\n  themeProvider: string;\n  /** Helper utilities (css, keyframes, etc.) */\n  helpers: string;\n  /** Warnings */\n  warnings: string[];\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst DEFAULT_BREAKPOINTS: BreakpointConfig[] = [\n  { name: \"sm\", minWidth: 640 },\n  { name: \"md\", minWidth: 768 },\n  { name: \"lg\", minWidth: 1024 },\n  { name: \"xl\", minWidth: 1280 },\n  { name: \"2xl\", minWidth: 1536 },\n];\n\nconst DEFAULT_OPTIONS: StyledGenerationOptions = {\n  library: \"styled-components\",\n  useTypeScript: true,\n  generateTheme: true,\n  generateDarkTheme: true,\n  useCSSProp: false,\n  useServerStyleSheet: true,\n  colorFormat: \"hex\",\n  componentPrefix: \"\",\n  includeHelpers: true,\n  breakpoints: DEFAULT_BREAKPOINTS,\n};\n\nconst DEFAULT_LIGHT_THEME: Theme = {\n  colors: {\n    primary: \"#3b82f6\",\n    secondary: \"#64748b\",\n    background: \"#ffffff\",\n    surface: \"#f8fafc\",\n    text: \"#0f172a\",\n    textMuted: \"#64748b\",\n    border: \"#e2e8f0\",\n    error: \"#ef4444\",\n    warning: \"#f59e0b\",\n    success: \"#22c55e\",\n    info: \"#0ea5e9\",\n  },\n  spacing: {\n    xs: \"0.25rem\",\n    sm: \"0.5rem\",\n    md: \"1rem\",\n    lg: \"1.5rem\",\n    xl: \"2rem\",\n    \"2xl\": \"3rem\",\n  },\n  fontSizes: {\n    xs: \"0.75rem\",\n    sm: \"0.875rem\",\n    base: \"1rem\",\n    lg: \"1.125rem\",\n    xl: \"1.25rem\",\n    \"2xl\": \"1.5rem\",\n    \"3xl\": \"1.875rem\",\n    \"4xl\": \"2.25rem\",\n  },\n  fontWeights: {\n    normal: 400,\n    medium: 500,\n    semibold: 600,\n    bold: 700,\n  },\n  fontFamily: {\n    sans: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n    serif: 'Georgia, Cambria, \"Times New Roman\", Times, serif',\n    mono: 'Menlo, Monaco, Consolas, \"Liberation Mono\", monospace',\n  },\n  lineHeights: {\n    tight: \"1.25\",\n    normal: \"1.5\",\n    relaxed: \"1.75\",\n  },\n  borderRadius: {\n    none: \"0\",\n    sm: \"0.125rem\",\n    md: \"0.375rem\",\n    lg: \"0.5rem\",\n    xl: \"0.75rem\",\n    full: \"9999px\",\n  },\n  shadows: {\n    sm: \"0 1px 2px 0 rgb(0 0 0 / 0.05)\",\n    md: \"0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)\",\n    lg: \"0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)\",\n    xl: \"0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)\",\n  },\n  breakpoints: {\n    sm: \"640px\",\n    md: \"768px\",\n    lg: \"1024px\",\n    xl: \"1280px\",\n    \"2xl\": \"1536px\",\n  },\n  zIndex: {\n    dropdown: 1000,\n    modal: 1100,\n    tooltip: 1200,\n  },\n  transitions: {\n    fast: \"150ms ease-in-out\",\n    normal: \"200ms ease-in-out\",\n    slow: \"300ms ease-in-out\",\n  },\n};\n\nconst DEFAULT_DARK_THEME: DarkTheme = {\n  colors: {\n    primary: \"#60a5fa\",\n    secondary: \"#94a3b8\",\n    background: \"#0f172a\",\n    surface: \"#1e293b\",\n    text: \"#f1f5f9\",\n    textMuted: \"#94a3b8\",\n    border: \"#334155\",\n    error: \"#f87171\",\n    warning: \"#fbbf24\",\n    success: \"#4ade80\",\n    info: \"#38bdf8\",\n  },\n};\n\n// ============================================================================\n// Color Utilities\n// ============================================================================\n\n/**\n * Convert Figma color to specified format\n */\nexport function formatColor(\n  color: FigmaColor,\n  format: ColorFormat,\n  opacity: number = 1\n): string {\n  switch (format) {\n    case \"hex\":\n      return figmaColorToHex(color, opacity);\n    case \"rgb\":\n      return figmaColorToRgba(color, opacity);\n    case \"hsl\":\n      return figmaColorToHsl(color, opacity);\n    default:\n      return figmaColorToHex(color, opacity);\n  }\n}\n\n// ============================================================================\n// CSS Property Generators\n// ============================================================================\n\n/**\n * Generate CSS property value for layout\n */\nfunction generateLayoutCSS(props: FigmaDesignProperties): string[] {\n  const cssProps: string[] = [];\n\n  if (props.layoutMode === \"HORIZONTAL\" || props.layoutMode === \"VERTICAL\") {\n    cssProps.push(\"display: flex;\");\n    if (props.layoutMode === \"VERTICAL\") {\n      cssProps.push(\"flex-direction: column;\");\n    }\n\n    // Justify content (primary axis)\n    if (props.primaryAxisAlignItems) {\n      const justifyMap: Record<string, string> = {\n        MIN: \"flex-start\",\n        CENTER: \"center\",\n        MAX: \"flex-end\",\n        SPACE_BETWEEN: \"space-between\",\n      };\n      if (justifyMap[props.primaryAxisAlignItems]) {\n        cssProps.push(`justify-content: ${justifyMap[props.primaryAxisAlignItems]};`);\n      }\n    }\n\n    // Align items (cross axis)\n    if (props.counterAxisAlignItems) {\n      const alignMap: Record<string, string> = {\n        MIN: \"flex-start\",\n        CENTER: \"center\",\n        MAX: \"flex-end\",\n        BASELINE: \"baseline\",\n      };\n      if (alignMap[props.counterAxisAlignItems]) {\n        cssProps.push(`align-items: ${alignMap[props.counterAxisAlignItems]};`);\n      }\n    }\n\n    // Flex wrap\n    if (props.layoutWrap === \"WRAP\") {\n      cssProps.push(\"flex-wrap: wrap;\");\n    }\n\n    // Gap\n    if (props.gap !== undefined && props.gap > 0) {\n      cssProps.push(`gap: ${props.gap}px;`);\n    }\n  }\n\n  // Flex grow\n  if (props.layoutGrow === 1) {\n    cssProps.push(\"flex: 1;\");\n  } else if (props.layoutGrow === 0) {\n    cssProps.push(\"flex: none;\");\n  }\n\n  // Sizing\n  if (props.layoutSizingHorizontal === \"FILL\") {\n    cssProps.push(\"width: 100%;\");\n  } else if (props.layoutSizingHorizontal === \"HUG\") {\n    cssProps.push(\"width: fit-content;\");\n  }\n\n  if (props.layoutSizingVertical === \"FILL\") {\n    cssProps.push(\"height: 100%;\");\n  } else if (props.layoutSizingVertical === \"HUG\") {\n    cssProps.push(\"height: fit-content;\");\n  }\n\n  return cssProps;\n}\n\n/**\n * Generate CSS for dimensions\n */\nfunction generateDimensionCSS(props: FigmaDesignProperties): string[] {\n  const cssProps: string[] = [];\n\n  if (props.width !== undefined && props.layoutSizingHorizontal === \"FIXED\") {\n    cssProps.push(`width: ${props.width}px;`);\n  }\n\n  if (props.height !== undefined && props.layoutSizingVertical === \"FIXED\") {\n    cssProps.push(`height: ${props.height}px;`);\n  }\n\n  if (props.minWidth !== undefined) {\n    cssProps.push(`min-width: ${props.minWidth}px;`);\n  }\n  if (props.maxWidth !== undefined) {\n    cssProps.push(`max-width: ${props.maxWidth}px;`);\n  }\n  if (props.minHeight !== undefined) {\n    cssProps.push(`min-height: ${props.minHeight}px;`);\n  }\n  if (props.maxHeight !== undefined) {\n    cssProps.push(`max-height: ${props.maxHeight}px;`);\n  }\n\n  return cssProps;\n}\n\n/**\n * Generate CSS for padding\n */\nfunction generatePaddingCSS(props: FigmaDesignProperties): string[] {\n  const cssProps: string[] = [];\n\n  if (props.padding) {\n    const { top, right, bottom, left } = props.padding;\n\n    // Check for uniform padding\n    if (top === right && right === bottom && bottom === left && top > 0) {\n      cssProps.push(`padding: ${top}px;`);\n    } else if (top === bottom && left === right) {\n      // Symmetric padding\n      if (top > 0 || left > 0) {\n        cssProps.push(`padding: ${top}px ${left}px;`);\n      }\n    } else {\n      // Individual paddings\n      if (top > 0) cssProps.push(`padding-top: ${top}px;`);\n      if (right > 0) cssProps.push(`padding-right: ${right}px;`);\n      if (bottom > 0) cssProps.push(`padding-bottom: ${bottom}px;`);\n      if (left > 0) cssProps.push(`padding-left: ${left}px;`);\n    }\n  }\n\n  return cssProps;\n}\n\n/**\n * Generate CSS for typography\n */\nfunction generateTypographyCSS(\n  props: FigmaDesignProperties,\n  options: StyledGenerationOptions\n): string[] {\n  const cssProps: string[] = [];\n\n  if (props.fontSize) {\n    cssProps.push(`font-size: ${props.fontSize}px;`);\n  }\n\n  if (props.fontWeight) {\n    cssProps.push(`font-weight: ${props.fontWeight};`);\n  }\n\n  if (props.fontFamily) {\n    cssProps.push(`font-family: \"${props.fontFamily}\", sans-serif;`);\n  }\n\n  if (props.lineHeight !== undefined && props.lineHeight !== \"auto\") {\n    if (props.lineHeightUnit === \"PIXELS\") {\n      cssProps.push(`line-height: ${props.lineHeight}px;`);\n    } else {\n      cssProps.push(`line-height: ${props.lineHeight / 100};`);\n    }\n  }\n\n  if (props.letterSpacing !== undefined) {\n    if (props.letterSpacingUnit === \"PERCENT\") {\n      cssProps.push(`letter-spacing: ${props.letterSpacing / 100}em;`);\n    } else {\n      cssProps.push(`letter-spacing: ${props.letterSpacing}px;`);\n    }\n  }\n\n  // Text case\n  if (props.textCase) {\n    switch (props.textCase) {\n      case \"UPPER\":\n        cssProps.push(\"text-transform: uppercase;\");\n        break;\n      case \"LOWER\":\n        cssProps.push(\"text-transform: lowercase;\");\n        break;\n      case \"TITLE\":\n        cssProps.push(\"text-transform: capitalize;\");\n        break;\n    }\n  }\n\n  // Text decoration\n  if (props.textDecoration) {\n    switch (props.textDecoration) {\n      case \"UNDERLINE\":\n        cssProps.push(\"text-decoration: underline;\");\n        break;\n      case \"STRIKETHROUGH\":\n        cssProps.push(\"text-decoration: line-through;\");\n        break;\n    }\n  }\n\n  // Text alignment\n  if (props.textAlignHorizontal) {\n    switch (props.textAlignHorizontal) {\n      case \"LEFT\":\n        cssProps.push(\"text-align: left;\");\n        break;\n      case \"CENTER\":\n        cssProps.push(\"text-align: center;\");\n        break;\n      case \"RIGHT\":\n        cssProps.push(\"text-align: right;\");\n        break;\n      case \"JUSTIFIED\":\n        cssProps.push(\"text-align: justify;\");\n        break;\n    }\n  }\n\n  return cssProps;\n}\n\n/**\n * Generate CSS for colors\n */\nfunction generateColorCSS(\n  props: FigmaDesignProperties,\n  options: StyledGenerationOptions\n): string[] {\n  const cssProps: string[] = [];\n\n  // Background color\n  if (props.backgroundColor) {\n    cssProps.push(`background-color: ${formatColor(props.backgroundColor, options.colorFormat)};`);\n  } else if (props.fills && props.fills.length > 0) {\n    const visibleFill = props.fills.find((f) => f.visible !== false && f.color);\n    if (visibleFill?.color) {\n      cssProps.push(\n        `background-color: ${formatColor(visibleFill.color, options.colorFormat, visibleFill.opacity ?? 1)};`\n      );\n    }\n  }\n\n  return cssProps;\n}\n\n/**\n * Generate CSS for borders\n */\nfunction generateBorderCSS(\n  props: FigmaDesignProperties,\n  options: StyledGenerationOptions\n): string[] {\n  const cssProps: string[] = [];\n\n  // Border width and color\n  if (props.strokeWeight !== undefined && props.strokeWeight > 0) {\n    let borderColor = \"#e2e8f0\"; // Default border color\n    if (props.strokes && props.strokes.length > 0) {\n      const visibleStroke = props.strokes.find((s) => s.visible !== false && s.color);\n      if (visibleStroke?.color) {\n        borderColor = formatColor(visibleStroke.color, options.colorFormat, visibleStroke.opacity ?? 1);\n      }\n    }\n\n    let borderStyle = \"solid\";\n    if (props.strokeDashes && props.strokeDashes.length > 0) {\n      borderStyle = props.strokeDashes[0] <= 2 ? \"dotted\" : \"dashed\";\n    }\n\n    cssProps.push(`border: ${props.strokeWeight}px ${borderStyle} ${borderColor};`);\n  } else if (props.individualStrokeWeights) {\n    const { top, right, bottom, left } = props.individualStrokeWeights;\n    let borderColor = \"#e2e8f0\";\n    if (props.strokes && props.strokes.length > 0) {\n      const visibleStroke = props.strokes.find((s) => s.visible !== false && s.color);\n      if (visibleStroke?.color) {\n        borderColor = formatColor(visibleStroke.color, options.colorFormat, visibleStroke.opacity ?? 1);\n      }\n    }\n\n    if (top > 0) cssProps.push(`border-top: ${top}px solid ${borderColor};`);\n    if (right > 0) cssProps.push(`border-right: ${right}px solid ${borderColor};`);\n    if (bottom > 0) cssProps.push(`border-bottom: ${bottom}px solid ${borderColor};`);\n    if (left > 0) cssProps.push(`border-left: ${left}px solid ${borderColor};`);\n  }\n\n  // Border radius\n  if (props.cornerRadius !== undefined && props.cornerRadius > 0) {\n    cssProps.push(`border-radius: ${props.cornerRadius}px;`);\n  } else if (props.rectangleCornerRadii) {\n    const [tl, tr, br, bl] = props.rectangleCornerRadii;\n    if (tl === tr && tr === br && br === bl && tl > 0) {\n      cssProps.push(`border-radius: ${tl}px;`);\n    } else {\n      cssProps.push(`border-radius: ${tl}px ${tr}px ${br}px ${bl}px;`);\n    }\n  }\n\n  return cssProps;\n}\n\n/**\n * Generate CSS for effects (shadows, blur)\n */\nfunction generateEffectsCSS(\n  props: FigmaDesignProperties,\n  options: StyledGenerationOptions\n): string[] {\n  const cssProps: string[] = [];\n\n  if (props.effects && props.effects.length > 0) {\n    const shadows: string[] = [];\n    const blurs: string[] = [];\n\n    for (const effect of props.effects) {\n      if (effect.visible === false) continue;\n\n      if (effect.type === \"DROP_SHADOW\" || effect.type === \"INNER_SHADOW\") {\n        const x = effect.offset?.x ?? 0;\n        const y = effect.offset?.y ?? 0;\n        const blur = effect.radius ?? 0;\n        const spread = effect.spread ?? 0;\n        const color = effect.color\n          ? formatColor(effect.color, options.colorFormat, effect.color.a)\n          : \"rgba(0, 0, 0, 0.25)\";\n        const inset = effect.type === \"INNER_SHADOW\" ? \"inset \" : \"\";\n        shadows.push(`${inset}${x}px ${y}px ${blur}px ${spread}px ${color}`);\n      } else if (effect.type === \"LAYER_BLUR\") {\n        blurs.push(`blur(${effect.radius ?? 0}px)`);\n      }\n    }\n\n    if (shadows.length > 0) {\n      cssProps.push(`box-shadow: ${shadows.join(\", \")};`);\n    }\n    if (blurs.length > 0) {\n      cssProps.push(`filter: ${blurs.join(\" \")};`);\n    }\n  }\n\n  // Opacity\n  if (props.opacity !== undefined && props.opacity < 1) {\n    cssProps.push(`opacity: ${props.opacity};`);\n  }\n\n  return cssProps;\n}\n\n/**\n * Generate CSS for overflow and positioning\n */\nfunction generateMiscCSS(props: FigmaDesignProperties): string[] {\n  const cssProps: string[] = [];\n\n  if (props.clipsContent === true) {\n    cssProps.push(\"overflow: hidden;\");\n  }\n\n  if (props.layoutPositioning === \"ABSOLUTE\") {\n    cssProps.push(\"position: absolute;\");\n  }\n\n  if (props.rotation !== undefined && props.rotation !== 0) {\n    cssProps.push(`transform: rotate(${Math.round(props.rotation)}deg);`);\n  }\n\n  return cssProps;\n}\n\n// ============================================================================\n// Styled Component Generation\n// ============================================================================\n\n/**\n * Generate CSS string from Figma design properties\n */\nexport function generateCSSFromProps(\n  props: FigmaDesignProperties,\n  options: Partial<StyledGenerationOptions> = {}\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const allProps: string[] = [];\n\n  allProps.push(...generateLayoutCSS(props));\n  allProps.push(...generateDimensionCSS(props));\n  allProps.push(...generatePaddingCSS(props));\n  allProps.push(...generateTypographyCSS(props, opts));\n  allProps.push(...generateColorCSS(props, opts));\n  allProps.push(...generateBorderCSS(props, opts));\n  allProps.push(...generateEffectsCSS(props, opts));\n  allProps.push(...generateMiscCSS(props));\n\n  return allProps.join(\"\\n  \");\n}\n\n/**\n * Generate a styled component definition\n */\nexport function generateStyledComponent(\n  name: string,\n  baseElement: string,\n  props: FigmaDesignProperties,\n  options: Partial<StyledGenerationOptions> = {},\n  dynamicProps: DynamicProp[] = []\n): StyledComponentDefinition {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const cssString = generateCSSFromProps(props, opts);\n\n  return {\n    name: `${opts.componentPrefix}${name}`,\n    baseElement,\n    styles: cssString,\n    dynamicProps,\n  };\n}\n\n/**\n * Generate styled-components code\n */\nexport function generateStyledComponentsCode(\n  definition: StyledComponentDefinition,\n  options: Partial<StyledGenerationOptions> = {}\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const { name, baseElement, styles, dynamicProps, variants, responsiveStyles } = definition;\n\n  let code = \"\";\n\n  // Generate dynamic props interface if TypeScript\n  if (opts.useTypeScript && dynamicProps.length > 0) {\n    code += generatePropsInterface(name, dynamicProps);\n    code += \"\\n\\n\";\n  }\n\n  // Generate the styled component\n  const propsType = opts.useTypeScript && dynamicProps.length > 0 ? `<${name}Props>` : \"\";\n  code += `export const ${name} = styled.${baseElement}${propsType}\\`\\n`;\n  code += `  ${styles}\\n`;\n\n  // Add dynamic props\n  for (const prop of dynamicProps) {\n    code += generateDynamicPropStyle(prop, opts);\n  }\n\n  // Add variant styles\n  if (variants) {\n    for (const [variantName, variantValues] of Object.entries(variants)) {\n      code += generateVariantStyles(variantName, variantValues);\n    }\n  }\n\n  // Add responsive styles\n  if (responsiveStyles) {\n    code += generateResponsiveStyles(responsiveStyles, opts);\n  }\n\n  code += \"`;\\n\";\n\n  return code;\n}\n\n/**\n * Generate Emotion styled code\n */\nexport function generateEmotionCode(\n  definition: StyledComponentDefinition,\n  options: Partial<StyledGenerationOptions> = {}\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const { name, baseElement, styles, dynamicProps, variants, responsiveStyles } = definition;\n\n  let code = \"\";\n\n  // Generate dynamic props interface if TypeScript\n  if (opts.useTypeScript && dynamicProps.length > 0) {\n    code += generatePropsInterface(name, dynamicProps);\n    code += \"\\n\\n\";\n  }\n\n  // Generate the styled component\n  const propsType = opts.useTypeScript && dynamicProps.length > 0 ? `<${name}Props>` : \"\";\n  code += `export const ${name} = styled.${baseElement}${propsType}\\`\\n`;\n  code += `  ${styles}\\n`;\n\n  // Add dynamic props\n  for (const prop of dynamicProps) {\n    code += generateDynamicPropStyle(prop, opts);\n  }\n\n  // Add variant styles\n  if (variants) {\n    for (const [variantName, variantValues] of Object.entries(variants)) {\n      code += generateVariantStyles(variantName, variantValues);\n    }\n  }\n\n  // Add responsive styles\n  if (responsiveStyles) {\n    code += generateResponsiveStyles(responsiveStyles, opts);\n  }\n\n  code += \"`;\\n\";\n\n  return code;\n}\n\n/**\n * Generate props interface for TypeScript\n */\nfunction generatePropsInterface(\n  componentName: string,\n  dynamicProps: DynamicProp[]\n): string {\n  let code = `interface ${componentName}Props {\\n`;\n\n  for (const prop of dynamicProps) {\n    const optional = prop.defaultValue !== undefined ? \"?\" : \"\";\n    code += `  ${prop.name}${optional}: ${prop.type};\\n`;\n  }\n\n  code += \"}\";\n  return code;\n}\n\n/**\n * Generate dynamic prop style interpolation\n */\nfunction generateDynamicPropStyle(\n  prop: DynamicProp,\n  options: StyledGenerationOptions\n): string {\n  const { name, cssProperty, themeKey, defaultValue } = prop;\n\n  if (themeKey) {\n    // Use theme value\n    if (defaultValue) {\n      return `  ${cssProperty}: \\${({ ${name}, theme }) => ${name} ? theme.${themeKey}[${name}] : theme.${themeKey}['${defaultValue}']};\\n`;\n    }\n    return `  ${cssProperty}: \\${({ ${name}, theme }) => theme.${themeKey}[${name}]};\\n`;\n  }\n\n  // Direct prop value\n  if (defaultValue) {\n    return `  ${cssProperty}: \\${({ ${name} }) => ${name} ?? '${defaultValue}'};\\n`;\n  }\n  return `  ${cssProperty}: \\${({ ${name} }) => ${name}};\\n`;\n}\n\n/**\n * Generate variant styles\n */\nfunction generateVariantStyles(\n  variantName: string,\n  variantValues: Record<string, string>\n): string {\n  let code = \"\";\n\n  for (const [value, styles] of Object.entries(variantValues)) {\n    code += `\\n  \\${({ ${variantName} }) => ${variantName} === '${value}' && css\\`\\n`;\n    code += `    ${styles}\\n`;\n    code += `  \\`}\\n`;\n  }\n\n  return code;\n}\n\n/**\n * Generate responsive styles\n */\nfunction generateResponsiveStyles(\n  responsiveStyles: Partial<Record<keyof ThemeBreakpoints, string>>,\n  options: StyledGenerationOptions\n): string {\n  let code = \"\";\n\n  for (const [breakpoint, styles] of Object.entries(responsiveStyles)) {\n    code += `\\n  @media (min-width: \\${({ theme }) => theme.breakpoints['${breakpoint}']}) {\\n`;\n    code += `    ${styles}\\n`;\n    code += `  }\\n`;\n  }\n\n  return code;\n}\n\n// ============================================================================\n// Theme Generation\n// ============================================================================\n\n/**\n * Generate theme object code\n */\nexport function generateThemeCode(\n  theme: Partial<Theme> = {},\n  darkTheme: Partial<DarkTheme> = {},\n  options: Partial<StyledGenerationOptions> = {}\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const mergedTheme = { ...DEFAULT_LIGHT_THEME, ...theme };\n  const mergedDarkTheme = { ...DEFAULT_DARK_THEME, ...darkTheme };\n\n  let code = \"\";\n\n  if (opts.useTypeScript) {\n    code += generateThemeTypeDefinition();\n    code += \"\\n\\n\";\n  }\n\n  // Light theme\n  code += `export const lightTheme${opts.useTypeScript ? \": Theme\" : \"\"} = ${JSON.stringify(mergedTheme, null, 2)};\\n\\n`;\n\n  // Dark theme (merge with light theme)\n  if (opts.generateDarkTheme) {\n    code += `export const darkTheme${opts.useTypeScript ? \": Theme\" : \"\"} = {\\n`;\n    code += `  ...lightTheme,\\n`;\n    code += `  colors: {\\n`;\n    code += `    ...lightTheme.colors,\\n`;\n    for (const [key, value] of Object.entries(mergedDarkTheme.colors || {})) {\n      code += `    ${key}: \"${value}\",\\n`;\n    }\n    code += `  },\\n`;\n    code += `};\\n`;\n  }\n\n  return code;\n}\n\n/**\n * Generate Theme TypeScript type definition\n */\nfunction generateThemeTypeDefinition(): string {\n  return `export interface Theme {\n  colors: {\n    primary: string;\n    secondary: string;\n    background: string;\n    surface: string;\n    text: string;\n    textMuted: string;\n    border: string;\n    error: string;\n    warning: string;\n    success: string;\n    info: string;\n    [key: string]: string;\n  };\n  spacing: {\n    xs: string;\n    sm: string;\n    md: string;\n    lg: string;\n    xl: string;\n    '2xl': string;\n    [key: string]: string;\n  };\n  fontSizes: {\n    xs: string;\n    sm: string;\n    base: string;\n    lg: string;\n    xl: string;\n    '2xl': string;\n    '3xl': string;\n    '4xl': string;\n    [key: string]: string;\n  };\n  fontWeights: {\n    normal: number;\n    medium: number;\n    semibold: number;\n    bold: number;\n    [key: string]: number;\n  };\n  fontFamily: {\n    sans: string;\n    serif: string;\n    mono: string;\n    [key: string]: string;\n  };\n  lineHeights: {\n    tight: string;\n    normal: string;\n    relaxed: string;\n    [key: string]: string;\n  };\n  borderRadius: {\n    none: string;\n    sm: string;\n    md: string;\n    lg: string;\n    xl: string;\n    full: string;\n    [key: string]: string;\n  };\n  shadows: {\n    sm: string;\n    md: string;\n    lg: string;\n    xl: string;\n    [key: string]: string;\n  };\n  breakpoints: {\n    sm: string;\n    md: string;\n    lg: string;\n    xl: string;\n    '2xl': string;\n    [key: string]: string;\n  };\n  zIndex: {\n    dropdown: number;\n    modal: number;\n    tooltip: number;\n    [key: string]: number;\n  };\n  transitions: {\n    fast: string;\n    normal: string;\n    slow: string;\n    [key: string]: string;\n  };\n}`;\n}\n\n/**\n * Generate ThemeProvider setup code\n */\nexport function generateThemeProviderCode(\n  options: Partial<StyledGenerationOptions> = {}\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  if (opts.library === \"styled-components\") {\n    return generateStyledComponentsThemeProvider(opts);\n  }\n  return generateEmotionThemeProvider(opts);\n}\n\n/**\n * Generate styled-components ThemeProvider\n */\nfunction generateStyledComponentsThemeProvider(options: StyledGenerationOptions): string {\n  let code = \"\";\n\n  // Imports\n  code += `import React, { createContext, useContext, useState, useEffect } from 'react';\\n`;\n  code += `import { ThemeProvider as SCThemeProvider, createGlobalStyle } from 'styled-components';\\n`;\n  code += `import { lightTheme, darkTheme${options.useTypeScript ? \", Theme\" : \"\"} } from './theme';\\n\\n`;\n\n  // Global styles\n  code += `const GlobalStyle = createGlobalStyle\\`\\n`;\n  code += `  *, *::before, *::after {\\n`;\n  code += `    box-sizing: border-box;\\n`;\n  code += `  }\\n\\n`;\n  code += `  html, body {\\n`;\n  code += `    margin: 0;\\n`;\n  code += `    padding: 0;\\n`;\n  code += `    font-family: \\${({ theme }) => theme.fontFamily.sans};\\n`;\n  code += `    background-color: \\${({ theme }) => theme.colors.background};\\n`;\n  code += `    color: \\${({ theme }) => theme.colors.text};\\n`;\n  code += `    line-height: \\${({ theme }) => theme.lineHeights.normal};\\n`;\n  code += `  }\\n`;\n  code += `\\`;\\n\\n`;\n\n  // Theme context\n  if (options.useTypeScript) {\n    code += `interface ThemeContextValue {\\n`;\n    code += `  theme: Theme;\\n`;\n    code += `  isDark: boolean;\\n`;\n    code += `  toggleTheme: () => void;\\n`;\n    code += `}\\n\\n`;\n  }\n\n  code += `const ThemeContext = createContext${options.useTypeScript ? \"<ThemeContextValue | undefined>\" : \"\"}(undefined);\\n\\n`;\n\n  // useTheme hook\n  code += `export function useTheme()${options.useTypeScript ? \": ThemeContextValue\" : \"\"} {\\n`;\n  code += `  const context = useContext(ThemeContext);\\n`;\n  code += `  if (!context) {\\n`;\n  code += `    throw new Error('useTheme must be used within a ThemeProvider');\\n`;\n  code += `  }\\n`;\n  code += `  return context;\\n`;\n  code += `}\\n\\n`;\n\n  // ThemeProvider component\n  if (options.useTypeScript) {\n    code += `interface ThemeProviderProps {\\n`;\n    code += `  children: React.ReactNode;\\n`;\n    code += `  defaultDark?: boolean;\\n`;\n    code += `}\\n\\n`;\n  }\n\n  code += `export function ThemeProvider({ children, defaultDark = false }${options.useTypeScript ? \": ThemeProviderProps\" : \"\"}) {\\n`;\n  code += `  const [isDark, setIsDark] = useState(defaultDark);\\n\\n`;\n  code += `  useEffect(() => {\\n`;\n  code += `    const savedTheme = localStorage.getItem('theme');\\n`;\n  code += `    if (savedTheme) {\\n`;\n  code += `      setIsDark(savedTheme === 'dark');\\n`;\n  code += `    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\\n`;\n  code += `      setIsDark(true);\\n`;\n  code += `    }\\n`;\n  code += `  }, []);\\n\\n`;\n  code += `  const toggleTheme = () => {\\n`;\n  code += `    setIsDark((prev) => {\\n`;\n  code += `      const newValue = !prev;\\n`;\n  code += `      localStorage.setItem('theme', newValue ? 'dark' : 'light');\\n`;\n  code += `      return newValue;\\n`;\n  code += `    });\\n`;\n  code += `  };\\n\\n`;\n  code += `  const theme = isDark ? darkTheme : lightTheme;\\n\\n`;\n  code += `  return (\\n`;\n  code += `    <ThemeContext.Provider value={{ theme, isDark, toggleTheme }}>\\n`;\n  code += `      <SCThemeProvider theme={theme}>\\n`;\n  code += `        <GlobalStyle />\\n`;\n  code += `        {children}\\n`;\n  code += `      </SCThemeProvider>\\n`;\n  code += `    </ThemeContext.Provider>\\n`;\n  code += `  );\\n`;\n  code += `}\\n`;\n\n  // Server style sheet setup (for SSR)\n  if (options.useServerStyleSheet) {\n    code += `\\n// Server-side rendering setup\\n`;\n    code += `export { ServerStyleSheet } from 'styled-components';\\n`;\n    code += `\\n// Usage in SSR:\\n`;\n    code += `// const sheet = new ServerStyleSheet();\\n`;\n    code += `// const html = renderToString(sheet.collectStyles(<App />));\\n`;\n    code += `// const styleTags = sheet.getStyleTags();\\n`;\n  }\n\n  return code;\n}\n\n/**\n * Generate Emotion ThemeProvider\n */\nfunction generateEmotionThemeProvider(options: StyledGenerationOptions): string {\n  let code = \"\";\n\n  // Imports\n  code += `import React, { createContext, useContext, useState, useEffect } from 'react';\\n`;\n  code += `import { ThemeProvider as EmotionThemeProvider, Global, css } from '@emotion/react';\\n`;\n  code += `import { lightTheme, darkTheme${options.useTypeScript ? \", Theme\" : \"\"} } from './theme';\\n\\n`;\n\n  // Global styles\n  code += `const globalStyles = (theme${options.useTypeScript ? \": Theme\" : \"\"}) => css\\`\\n`;\n  code += `  *, *::before, *::after {\\n`;\n  code += `    box-sizing: border-box;\\n`;\n  code += `  }\\n\\n`;\n  code += `  html, body {\\n`;\n  code += `    margin: 0;\\n`;\n  code += `    padding: 0;\\n`;\n  code += `    font-family: \\${theme.fontFamily.sans};\\n`;\n  code += `    background-color: \\${theme.colors.background};\\n`;\n  code += `    color: \\${theme.colors.text};\\n`;\n  code += `    line-height: \\${theme.lineHeights.normal};\\n`;\n  code += `  }\\n`;\n  code += `\\`;\\n\\n`;\n\n  // Theme context\n  if (options.useTypeScript) {\n    code += `interface ThemeContextValue {\\n`;\n    code += `  theme: Theme;\\n`;\n    code += `  isDark: boolean;\\n`;\n    code += `  toggleTheme: () => void;\\n`;\n    code += `}\\n\\n`;\n  }\n\n  code += `const ThemeContext = createContext${options.useTypeScript ? \"<ThemeContextValue | undefined>\" : \"\"}(undefined);\\n\\n`;\n\n  // useTheme hook\n  code += `export function useTheme()${options.useTypeScript ? \": ThemeContextValue\" : \"\"} {\\n`;\n  code += `  const context = useContext(ThemeContext);\\n`;\n  code += `  if (!context) {\\n`;\n  code += `    throw new Error('useTheme must be used within a ThemeProvider');\\n`;\n  code += `  }\\n`;\n  code += `  return context;\\n`;\n  code += `}\\n\\n`;\n\n  // ThemeProvider component\n  if (options.useTypeScript) {\n    code += `interface ThemeProviderProps {\\n`;\n    code += `  children: React.ReactNode;\\n`;\n    code += `  defaultDark?: boolean;\\n`;\n    code += `}\\n\\n`;\n  }\n\n  code += `export function ThemeProvider({ children, defaultDark = false }${options.useTypeScript ? \": ThemeProviderProps\" : \"\"}) {\\n`;\n  code += `  const [isDark, setIsDark] = useState(defaultDark);\\n\\n`;\n  code += `  useEffect(() => {\\n`;\n  code += `    const savedTheme = localStorage.getItem('theme');\\n`;\n  code += `    if (savedTheme) {\\n`;\n  code += `      setIsDark(savedTheme === 'dark');\\n`;\n  code += `    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\\n`;\n  code += `      setIsDark(true);\\n`;\n  code += `    }\\n`;\n  code += `  }, []);\\n\\n`;\n  code += `  const toggleTheme = () => {\\n`;\n  code += `    setIsDark((prev) => {\\n`;\n  code += `      const newValue = !prev;\\n`;\n  code += `      localStorage.setItem('theme', newValue ? 'dark' : 'light');\\n`;\n  code += `      return newValue;\\n`;\n  code += `    });\\n`;\n  code += `  };\\n\\n`;\n  code += `  const theme = isDark ? darkTheme : lightTheme;\\n\\n`;\n  code += `  return (\\n`;\n  code += `    <ThemeContext.Provider value={{ theme, isDark, toggleTheme }}>\\n`;\n  code += `      <EmotionThemeProvider theme={theme}>\\n`;\n  code += `        <Global styles={globalStyles(theme)} />\\n`;\n  code += `        {children}\\n`;\n  code += `      </EmotionThemeProvider>\\n`;\n  code += `    </ThemeContext.Provider>\\n`;\n  code += `  );\\n`;\n  code += `}\\n`;\n\n  // SSR setup for Emotion\n  if (options.useSSR) {\n    code += `\\n// Server-side rendering setup\\n`;\n    code += `export { CacheProvider } from '@emotion/react';\\n`;\n    code += `export { default as createEmotionServer } from '@emotion/server/create-instance';\\n`;\n    code += `export { default as createCache } from '@emotion/cache';\\n`;\n  }\n\n  return code;\n}\n\n// ============================================================================\n// Helper Utilities Generation\n// ============================================================================\n\n/**\n * Generate helper utilities (css, keyframes, mixins)\n */\nexport function generateHelperUtilities(\n  options: Partial<StyledGenerationOptions> = {}\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  if (opts.library === \"styled-components\") {\n    return generateStyledComponentsHelpers(opts);\n  }\n  return generateEmotionHelpers(opts);\n}\n\n/**\n * Generate styled-components helpers\n */\nfunction generateStyledComponentsHelpers(options: StyledGenerationOptions): string {\n  let code = \"\";\n\n  code += `import { css, keyframes } from 'styled-components';\\n\\n`;\n\n  // Media query helpers\n  code += `// Media query helpers\\n`;\n  code += `export const media = {\\n`;\n  for (const bp of options.breakpoints) {\n    code += `  ${bp.name}: (styles${options.useTypeScript ? \": TemplateStringsArray\" : \"\"}) => css\\`\\n`;\n    code += `    @media (min-width: ${bp.minWidth}px) {\\n`;\n    code += `      \\${styles}\\n`;\n    code += `    }\\n`;\n    code += `  \\`,\\n`;\n  }\n  code += `};\\n\\n`;\n\n  // Common animation keyframes\n  code += `// Common animations\\n`;\n  code += `export const fadeIn = keyframes\\`\\n`;\n  code += `  from { opacity: 0; }\\n`;\n  code += `  to { opacity: 1; }\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const slideUp = keyframes\\`\\n`;\n  code += `  from { transform: translateY(10px); opacity: 0; }\\n`;\n  code += `  to { transform: translateY(0); opacity: 1; }\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const slideDown = keyframes\\`\\n`;\n  code += `  from { transform: translateY(-10px); opacity: 0; }\\n`;\n  code += `  to { transform: translateY(0); opacity: 1; }\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const scale = keyframes\\`\\n`;\n  code += `  from { transform: scale(0.95); opacity: 0; }\\n`;\n  code += `  to { transform: scale(1); opacity: 1; }\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const spin = keyframes\\`\\n`;\n  code += `  from { transform: rotate(0deg); }\\n`;\n  code += `  to { transform: rotate(360deg); }\\n`;\n  code += `\\`;\\n\\n`;\n\n  // Common mixins\n  code += `// Common mixins\\n`;\n  code += `export const flexCenter = css\\`\\n`;\n  code += `  display: flex;\\n`;\n  code += `  align-items: center;\\n`;\n  code += `  justify-content: center;\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const flexBetween = css\\`\\n`;\n  code += `  display: flex;\\n`;\n  code += `  align-items: center;\\n`;\n  code += `  justify-content: space-between;\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const absoluteFill = css\\`\\n`;\n  code += `  position: absolute;\\n`;\n  code += `  top: 0;\\n`;\n  code += `  right: 0;\\n`;\n  code += `  bottom: 0;\\n`;\n  code += `  left: 0;\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const truncate = css\\`\\n`;\n  code += `  overflow: hidden;\\n`;\n  code += `  text-overflow: ellipsis;\\n`;\n  code += `  white-space: nowrap;\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const visuallyHidden = css\\`\\n`;\n  code += `  position: absolute;\\n`;\n  code += `  width: 1px;\\n`;\n  code += `  height: 1px;\\n`;\n  code += `  padding: 0;\\n`;\n  code += `  margin: -1px;\\n`;\n  code += `  overflow: hidden;\\n`;\n  code += `  clip: rect(0, 0, 0, 0);\\n`;\n  code += `  white-space: nowrap;\\n`;\n  code += `  border: 0;\\n`;\n  code += `\\`;\\n\\n`;\n\n  // Focus ring\n  code += `export const focusRing = css\\`\\n`;\n  code += `  &:focus {\\n`;\n  code += `    outline: none;\\n`;\n  code += `    box-shadow: 0 0 0 2px \\${({ theme }) => theme.colors.primary}40;\\n`;\n  code += `  }\\n`;\n  code += `\\`;\\n\\n`;\n\n  // Transition helpers\n  code += `export const transition = (properties${options.useTypeScript ? \": string\" : \"\"} = 'all') => css\\`\\n`;\n  code += `  transition: \\${properties} \\${({ theme }) => theme.transitions.normal};\\n`;\n  code += `\\`;\\n`;\n\n  return code;\n}\n\n/**\n * Generate Emotion helpers\n */\nfunction generateEmotionHelpers(options: StyledGenerationOptions): string {\n  let code = \"\";\n\n  code += `import { css, keyframes } from '@emotion/react';\\n\\n`;\n\n  // Media query helpers\n  code += `// Media query helpers\\n`;\n  code += `export const media = {\\n`;\n  for (const bp of options.breakpoints) {\n    code += `  ${bp.name}: \\`@media (min-width: ${bp.minWidth}px)\\`,\\n`;\n  }\n  code += `};\\n\\n`;\n\n  // Common animation keyframes\n  code += `// Common animations\\n`;\n  code += `export const fadeIn = keyframes\\`\\n`;\n  code += `  from { opacity: 0; }\\n`;\n  code += `  to { opacity: 1; }\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const slideUp = keyframes\\`\\n`;\n  code += `  from { transform: translateY(10px); opacity: 0; }\\n`;\n  code += `  to { transform: translateY(0); opacity: 1; }\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const slideDown = keyframes\\`\\n`;\n  code += `  from { transform: translateY(-10px); opacity: 0; }\\n`;\n  code += `  to { transform: translateY(0); opacity: 1; }\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const scale = keyframes\\`\\n`;\n  code += `  from { transform: scale(0.95); opacity: 0; }\\n`;\n  code += `  to { transform: scale(1); opacity: 1; }\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const spin = keyframes\\`\\n`;\n  code += `  from { transform: rotate(0deg); }\\n`;\n  code += `  to { transform: rotate(360deg); }\\n`;\n  code += `\\`;\\n\\n`;\n\n  // Common mixins\n  code += `// Common mixins\\n`;\n  code += `export const flexCenter = css\\`\\n`;\n  code += `  display: flex;\\n`;\n  code += `  align-items: center;\\n`;\n  code += `  justify-content: center;\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const flexBetween = css\\`\\n`;\n  code += `  display: flex;\\n`;\n  code += `  align-items: center;\\n`;\n  code += `  justify-content: space-between;\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const absoluteFill = css\\`\\n`;\n  code += `  position: absolute;\\n`;\n  code += `  top: 0;\\n`;\n  code += `  right: 0;\\n`;\n  code += `  bottom: 0;\\n`;\n  code += `  left: 0;\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const truncate = css\\`\\n`;\n  code += `  overflow: hidden;\\n`;\n  code += `  text-overflow: ellipsis;\\n`;\n  code += `  white-space: nowrap;\\n`;\n  code += `\\`;\\n\\n`;\n\n  code += `export const visuallyHidden = css\\`\\n`;\n  code += `  position: absolute;\\n`;\n  code += `  width: 1px;\\n`;\n  code += `  height: 1px;\\n`;\n  code += `  padding: 0;\\n`;\n  code += `  margin: -1px;\\n`;\n  code += `  overflow: hidden;\\n`;\n  code += `  clip: rect(0, 0, 0, 0);\\n`;\n  code += `  white-space: nowrap;\\n`;\n  code += `  border: 0;\\n`;\n  code += `\\`;\\n`;\n\n  return code;\n}\n\n// ============================================================================\n// Style Composition Utilities\n// ============================================================================\n\n/**\n * Generate a composed/extended styled component\n */\nexport function generateExtendedComponent(\n  name: string,\n  baseComponent: string,\n  additionalStyles: string,\n  options: Partial<StyledGenerationOptions> = {}\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  if (opts.library === \"styled-components\") {\n    return `export const ${name} = styled(${baseComponent})\\`\\n  ${additionalStyles}\\n\\`;\\n`;\n  }\n  // Emotion\n  return `export const ${name} = styled(${baseComponent})\\`\\n  ${additionalStyles}\\n\\`;\\n`;\n}\n\n/**\n * Generate CSS composition helper\n */\nexport function generateCSSComposition(\n  styles: string[],\n  options: Partial<StyledGenerationOptions> = {}\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  if (opts.library === \"styled-components\") {\n    return `css\\`\\n  ${styles.join(\"\\n  \")}\\n\\``;\n  }\n  // Emotion\n  return `css\\`\\n  ${styles.join(\"\\n  \")}\\n\\``;\n}\n\n// ============================================================================\n// Main Generation Function\n// ============================================================================\n\n/**\n * Generate complete styled-components/emotion output from Figma properties\n */\nexport function generateStyledOutput(\n  componentName: string,\n  baseElement: string,\n  props: FigmaDesignProperties,\n  dynamicProps: DynamicProp[] = [],\n  options: Partial<StyledGenerationOptions> = {}\n): StyledGenerationResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const warnings: string[] = [];\n\n  // Generate the component definition\n  const definition = generateStyledComponent(componentName, baseElement, props, opts, dynamicProps);\n\n  // Generate component code\n  let component = \"\";\n  if (opts.library === \"styled-components\") {\n    component = `import styled, { css } from 'styled-components';\\n\\n`;\n    component += generateStyledComponentsCode(definition, opts);\n  } else {\n    component = `import styled from '@emotion/styled';\\nimport { css } from '@emotion/react';\\n\\n`;\n    component += generateEmotionCode(definition, opts);\n  }\n\n  // Generate types\n  let types = \"\";\n  if (opts.useTypeScript) {\n    types = generatePropsInterface(componentName, dynamicProps);\n  }\n\n  // Generate theme\n  let theme = \"\";\n  if (opts.generateTheme) {\n    theme = generateThemeCode({}, {}, opts);\n  }\n\n  // Generate theme provider\n  let themeProvider = \"\";\n  if (opts.generateTheme) {\n    themeProvider = generateThemeProviderCode(opts);\n  }\n\n  // Generate helpers\n  let helpers = \"\";\n  if (opts.includeHelpers) {\n    helpers = generateHelperUtilities(opts);\n  }\n\n  return {\n    component,\n    types,\n    theme,\n    themeProvider,\n    helpers,\n    warnings,\n  };\n}\n\n/**\n * Generate imports based on library\n */\nexport function generateImports(options: Partial<StyledGenerationOptions> = {}): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  if (opts.library === \"styled-components\") {\n    return `import styled, { css, keyframes, ThemeProvider, createGlobalStyle } from 'styled-components';`;\n  }\n  return `import styled from '@emotion/styled';\\nimport { css, keyframes, Global, ThemeProvider } from '@emotion/react';`;\n}\n\n// ============================================================================\n// Design Token Conversion\n// ============================================================================\n\n/**\n * Convert design tokens to theme object\n */\nexport function designTokensToTheme(\n  tokens: DesignToken[],\n  options: Partial<StyledGenerationOptions> = {}\n): Partial<Theme> {\n  const theme: Partial<Theme> = {\n    colors: {},\n    spacing: {},\n    fontSizes: {},\n    fontWeights: {},\n    borderRadius: {},\n    shadows: {},\n  };\n\n  for (const token of tokens) {\n    switch (token.type) {\n      case \"color\":\n        if (theme.colors) {\n          theme.colors[sanitizeTokenName(token.name)] = token.value;\n        }\n        break;\n      case \"spacing\":\n        if (theme.spacing) {\n          theme.spacing[sanitizeTokenName(token.name)] = token.value;\n        }\n        break;\n      case \"fontSize\":\n        if (theme.fontSizes) {\n          theme.fontSizes[sanitizeTokenName(token.name)] = token.value;\n        }\n        break;\n      case \"fontWeight\":\n        if (theme.fontWeights) {\n          theme.fontWeights[sanitizeTokenName(token.name)] = parseInt(token.value, 10);\n        }\n        break;\n      case \"borderRadius\":\n        if (theme.borderRadius) {\n          theme.borderRadius[sanitizeTokenName(token.name)] = token.value;\n        }\n        break;\n      case \"boxShadow\":\n        if (theme.shadows) {\n          theme.shadows[sanitizeTokenName(token.name)] = token.value;\n        }\n        break;\n    }\n  }\n\n  return theme;\n}\n\n/**\n * Sanitize token name for use in theme object\n */\nfunction sanitizeTokenName(name: string): string {\n  return name\n    .replace(/[^a-zA-Z0-9-_]/g, \"-\")\n    .replace(/--+/g, \"-\")\n    .replace(/^-|-$/g, \"\")\n    .toLowerCase()\n    .replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport {\n  DEFAULT_OPTIONS,\n  DEFAULT_LIGHT_THEME,\n  DEFAULT_DARK_THEME,\n  DEFAULT_BREAKPOINTS,\n};\n"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Create styled-components generator with template literals",
      "status": "completed",
      "activeForm": "Creating styled-components generator"
    },
    {
      "content": "Add theming support (ThemeProvider, useTheme)",
      "status": "completed",
      "activeForm": "Adding theming support"
    },
    {
      "content": "Implement dynamic props support for styled components",
      "status": "completed",
      "activeForm": "Implementing dynamic props support"
    },
    {
      "content": "Add style composition utilities (styled.extend, css helper)",
      "status": "completed",
      "activeForm": "Adding style composition utilities"
    },
    {
      "content": "Generate TypeScript types for styled components",
      "status": "completed",
      "activeForm": "Generating TypeScript types"
    },
    {
      "content": "Create emotion generator with similar features",
      "status": "completed",
      "activeForm": "Creating emotion generator"
    },
    {
      "content": "Add unit/integration exports and tests",
      "status": "in_progress",
      "activeForm": "Adding exports and tests"
    },
    {
      "content": "Verify with Playwright tests",
      "status": "pending",
      "activeForm": "Verifying with Playwright tests"
    }
  ]
}
Now let me create a unit test file for the styled-components generator:

ðŸ”§ Tool: Write
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/tests/styled-components-generator-unit.spec.ts",
  "content": "/**\n * Unit tests for styled-components/emotion generator\n */\n\nimport { describe, it, expect } from \"vitest\";\nimport {\n  generateCSSFromProps,\n  generateStyledComponent,\n  generateStyledComponentsCode,\n  generateEmotionCode,\n  generateThemeCode,\n  generateThemeProviderCode,\n  generateHelperUtilities,\n  generateExtendedComponent,\n  generateStyledOutput,\n  generateImports,\n  designTokensToTheme,\n  formatColor,\n  DEFAULT_OPTIONS,\n  DEFAULT_LIGHT_THEME,\n  DEFAULT_DARK_THEME,\n  type FigmaDesignProperties,\n  type DynamicProp,\n  type StyledGenerationOptions,\n} from \"../src/utils/styled-components-generator\";\nimport type { DesignToken } from \"../src/utils/tailwind-generator\";\n\ndescribe(\"styled-components-generator\", () => {\n  // =========================================================================\n  // Color Formatting Tests\n  // =========================================================================\n  describe(\"formatColor\", () => {\n    const testColor = { r: 0.2, g: 0.4, b: 0.8, a: 1 };\n\n    it(\"should format color as hex\", () => {\n      const result = formatColor(testColor, \"hex\");\n      expect(result).toBe(\"#3366cc\");\n    });\n\n    it(\"should format color as rgb\", () => {\n      const result = formatColor(testColor, \"rgb\");\n      expect(result).toMatch(/^rgb\\(51, 102, 204\\)$/);\n    });\n\n    it(\"should format color as hsl\", () => {\n      const result = formatColor(testColor, \"hsl\");\n      expect(result).toMatch(/^hsl\\(220, \\d+%, \\d+%\\)$/);\n    });\n\n    it(\"should handle opacity in hex format\", () => {\n      const colorWithAlpha = { r: 1, g: 0, b: 0, a: 0.5 };\n      const result = formatColor(colorWithAlpha, \"hex\", 1);\n      expect(result).toMatch(/^#ff0000[0-9a-f]{2}$/);\n    });\n  });\n\n  // =========================================================================\n  // CSS Generation Tests\n  // =========================================================================\n  describe(\"generateCSSFromProps\", () => {\n    it(\"should generate layout CSS for flex containers\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        layoutMode: \"HORIZONTAL\",\n        primaryAxisAlignItems: \"CENTER\",\n        counterAxisAlignItems: \"CENTER\",\n        gap: 16,\n      };\n      const result = generateCSSFromProps(props as FigmaDesignProperties);\n\n      expect(result).toContain(\"display: flex;\");\n      expect(result).toContain(\"justify-content: center;\");\n      expect(result).toContain(\"align-items: center;\");\n      expect(result).toContain(\"gap: 16px;\");\n    });\n\n    it(\"should generate flex-direction for vertical layout\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        layoutMode: \"VERTICAL\",\n      };\n      const result = generateCSSFromProps(props as FigmaDesignProperties);\n\n      expect(result).toContain(\"display: flex;\");\n      expect(result).toContain(\"flex-direction: column;\");\n    });\n\n    it(\"should generate dimension CSS\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        width: 200,\n        height: 100,\n        layoutSizingHorizontal: \"FIXED\",\n        layoutSizingVertical: \"FIXED\",\n      };\n      const result = generateCSSFromProps(props as FigmaDesignProperties);\n\n      expect(result).toContain(\"width: 200px;\");\n      expect(result).toContain(\"height: 100px;\");\n    });\n\n    it(\"should generate padding CSS\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        padding: { top: 16, right: 24, bottom: 16, left: 24 },\n      };\n      const result = generateCSSFromProps(props as FigmaDesignProperties);\n\n      expect(result).toContain(\"padding: 16px 24px;\");\n    });\n\n    it(\"should generate uniform padding\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        padding: { top: 20, right: 20, bottom: 20, left: 20 },\n      };\n      const result = generateCSSFromProps(props as FigmaDesignProperties);\n\n      expect(result).toContain(\"padding: 20px;\");\n    });\n\n    it(\"should generate typography CSS\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        fontSize: 16,\n        fontWeight: 600,\n        fontFamily: \"Inter\",\n        lineHeight: 150,\n        lineHeightUnit: \"PERCENT\",\n        textAlignHorizontal: \"CENTER\",\n      };\n      const result = generateCSSFromProps(props as FigmaDesignProperties);\n\n      expect(result).toContain(\"font-size: 16px;\");\n      expect(result).toContain(\"font-weight: 600;\");\n      expect(result).toContain('font-family: \"Inter\", sans-serif;');\n      expect(result).toContain(\"line-height: 1.5;\");\n      expect(result).toContain(\"text-align: center;\");\n    });\n\n    it(\"should generate border CSS\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        strokeWeight: 1,\n        strokes: [{ type: \"SOLID\", color: { r: 0.8, g: 0.8, b: 0.8, a: 1 }, visible: true }],\n        cornerRadius: 8,\n      };\n      const result = generateCSSFromProps(props as FigmaDesignProperties);\n\n      expect(result).toContain(\"border:\");\n      expect(result).toContain(\"1px solid\");\n      expect(result).toContain(\"border-radius: 8px;\");\n    });\n\n    it(\"should generate shadow CSS\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        effects: [\n          {\n            type: \"DROP_SHADOW\",\n            visible: true,\n            offset: { x: 0, y: 4 },\n            radius: 6,\n            spread: 0,\n            color: { r: 0, g: 0, b: 0, a: 0.1 },\n          },\n        ],\n      };\n      const result = generateCSSFromProps(props as FigmaDesignProperties);\n\n      expect(result).toContain(\"box-shadow:\");\n      expect(result).toContain(\"0px 4px 6px 0px\");\n    });\n\n    it(\"should generate opacity CSS\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        opacity: 0.5,\n      };\n      const result = generateCSSFromProps(props as FigmaDesignProperties);\n\n      expect(result).toContain(\"opacity: 0.5;\");\n    });\n\n    it(\"should generate overflow hidden\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        clipsContent: true,\n      };\n      const result = generateCSSFromProps(props as FigmaDesignProperties);\n\n      expect(result).toContain(\"overflow: hidden;\");\n    });\n\n    it(\"should generate rotation transform\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        rotation: 45,\n      };\n      const result = generateCSSFromProps(props as FigmaDesignProperties);\n\n      expect(result).toContain(\"transform: rotate(45deg);\");\n    });\n  });\n\n  // =========================================================================\n  // Styled Component Generation Tests\n  // =========================================================================\n  describe(\"generateStyledComponent\", () => {\n    it(\"should generate a styled component definition\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        layoutMode: \"HORIZONTAL\",\n        gap: 16,\n        padding: { top: 16, right: 16, bottom: 16, left: 16 },\n      };\n      const definition = generateStyledComponent(\n        \"Container\",\n        \"div\",\n        props as FigmaDesignProperties\n      );\n\n      expect(definition.name).toBe(\"Container\");\n      expect(definition.baseElement).toBe(\"div\");\n      expect(definition.styles).toContain(\"display: flex;\");\n      expect(definition.styles).toContain(\"gap: 16px;\");\n    });\n\n    it(\"should include component prefix\", () => {\n      const props: Partial<FigmaDesignProperties> = {};\n      const definition = generateStyledComponent(\n        \"Button\",\n        \"button\",\n        props as FigmaDesignProperties,\n        { componentPrefix: \"My\" }\n      );\n\n      expect(definition.name).toBe(\"MyButton\");\n    });\n  });\n\n  // =========================================================================\n  // Styled-Components Code Generation Tests\n  // =========================================================================\n  describe(\"generateStyledComponentsCode\", () => {\n    it(\"should generate valid styled-components code\", () => {\n      const definition = {\n        name: \"StyledButton\",\n        baseElement: \"button\",\n        styles: \"padding: 16px;\\nbackground-color: blue;\",\n        dynamicProps: [],\n      };\n      const code = generateStyledComponentsCode(definition);\n\n      expect(code).toContain(\"export const StyledButton = styled.button`\");\n      expect(code).toContain(\"padding: 16px;\");\n      expect(code).toContain(\"background-color: blue;\");\n      expect(code).toContain(\"`;\");\n    });\n\n    it(\"should generate TypeScript props interface\", () => {\n      const dynamicProps: DynamicProp[] = [\n        { name: \"variant\", type: \"'primary' | 'secondary'\", cssProperty: \"background-color\", defaultValue: \"primary\" },\n        { name: \"size\", type: \"'sm' | 'md' | 'lg'\", cssProperty: \"padding\" },\n      ];\n      const definition = {\n        name: \"Button\",\n        baseElement: \"button\",\n        styles: \"cursor: pointer;\",\n        dynamicProps,\n      };\n      const code = generateStyledComponentsCode(definition, { useTypeScript: true });\n\n      expect(code).toContain(\"interface ButtonProps {\");\n      expect(code).toContain(\"variant?: 'primary' | 'secondary'\");\n      expect(code).toContain(\"size: 'sm' | 'md' | 'lg'\");\n      expect(code).toContain(\"styled.button<ButtonProps>`\");\n    });\n\n    it(\"should generate dynamic prop styles with theme\", () => {\n      const dynamicProps: DynamicProp[] = [\n        { name: \"color\", type: \"string\", cssProperty: \"color\", themeKey: \"colors\" },\n      ];\n      const definition = {\n        name: \"Text\",\n        baseElement: \"span\",\n        styles: \"display: inline;\",\n        dynamicProps,\n      };\n      const code = generateStyledComponentsCode(definition);\n\n      expect(code).toContain(\"color: ${({ color, theme }) => theme.colors[color]};\");\n    });\n\n    it(\"should generate responsive styles\", () => {\n      const definition = {\n        name: \"ResponsiveBox\",\n        baseElement: \"div\",\n        styles: \"width: 100%;\",\n        dynamicProps: [],\n        responsiveStyles: {\n          md: \"width: 50%;\",\n          lg: \"width: 33.33%;\",\n        },\n      };\n      const code = generateStyledComponentsCode(definition);\n\n      expect(code).toContain(\"@media (min-width: ${({ theme }) => theme.breakpoints['md']})\");\n      expect(code).toContain(\"width: 50%;\");\n      expect(code).toContain(\"@media (min-width: ${({ theme }) => theme.breakpoints['lg']})\");\n      expect(code).toContain(\"width: 33.33%;\");\n    });\n  });\n\n  // =========================================================================\n  // Emotion Code Generation Tests\n  // =========================================================================\n  describe(\"generateEmotionCode\", () => {\n    it(\"should generate valid Emotion styled code\", () => {\n      const definition = {\n        name: \"EmotionButton\",\n        baseElement: \"button\",\n        styles: \"padding: 16px;\\nbackground-color: blue;\",\n        dynamicProps: [],\n      };\n      const code = generateEmotionCode(definition);\n\n      expect(code).toContain(\"export const EmotionButton = styled.button`\");\n      expect(code).toContain(\"padding: 16px;\");\n      expect(code).toContain(\"background-color: blue;\");\n    });\n  });\n\n  // =========================================================================\n  // Theme Generation Tests\n  // =========================================================================\n  describe(\"generateThemeCode\", () => {\n    it(\"should generate light theme code\", () => {\n      const code = generateThemeCode();\n\n      expect(code).toContain(\"export const lightTheme\");\n      expect(code).toContain(\"colors:\");\n      expect(code).toContain(\"primary\");\n      expect(code).toContain(\"spacing:\");\n      expect(code).toContain(\"fontSizes:\");\n    });\n\n    it(\"should generate dark theme code\", () => {\n      const code = generateThemeCode({}, {}, { generateDarkTheme: true });\n\n      expect(code).toContain(\"export const darkTheme\");\n      expect(code).toContain(\"...lightTheme\");\n    });\n\n    it(\"should include TypeScript type definition\", () => {\n      const code = generateThemeCode({}, {}, { useTypeScript: true });\n\n      expect(code).toContain(\"export interface Theme {\");\n      expect(code).toContain(\"colors: {\");\n      expect(code).toContain(\"primary: string;\");\n    });\n\n    it(\"should merge custom theme values\", () => {\n      const customTheme = {\n        colors: { primary: \"#ff0000\" },\n      };\n      const code = generateThemeCode(customTheme);\n\n      expect(code).toContain(\"#ff0000\");\n    });\n  });\n\n  // =========================================================================\n  // Theme Provider Generation Tests\n  // =========================================================================\n  describe(\"generateThemeProviderCode\", () => {\n    it(\"should generate styled-components ThemeProvider\", () => {\n      const code = generateThemeProviderCode({ library: \"styled-components\" });\n\n      expect(code).toContain(\"import { ThemeProvider as SCThemeProvider\");\n      expect(code).toContain(\"createGlobalStyle\");\n      expect(code).toContain(\"export function ThemeProvider\");\n      expect(code).toContain(\"export function useTheme\");\n      expect(code).toContain(\"toggleTheme\");\n    });\n\n    it(\"should generate Emotion ThemeProvider\", () => {\n      const code = generateThemeProviderCode({ library: \"emotion\" });\n\n      expect(code).toContain(\"import { ThemeProvider as EmotionThemeProvider\");\n      expect(code).toContain(\"Global, css\");\n      expect(code).toContain(\"export function ThemeProvider\");\n      expect(code).toContain(\"export function useTheme\");\n    });\n\n    it(\"should include SSR setup for styled-components\", () => {\n      const code = generateThemeProviderCode({\n        library: \"styled-components\",\n        useServerStyleSheet: true,\n      });\n\n      expect(code).toContain(\"ServerStyleSheet\");\n    });\n\n    it(\"should generate TypeScript types for context\", () => {\n      const code = generateThemeProviderCode({ useTypeScript: true });\n\n      expect(code).toContain(\"interface ThemeContextValue\");\n      expect(code).toContain(\"theme: Theme\");\n      expect(code).toContain(\"isDark: boolean\");\n      expect(code).toContain(\"toggleTheme: () => void\");\n    });\n  });\n\n  // =========================================================================\n  // Helper Utilities Tests\n  // =========================================================================\n  describe(\"generateHelperUtilities\", () => {\n    it(\"should generate styled-components helpers\", () => {\n      const code = generateHelperUtilities({ library: \"styled-components\" });\n\n      expect(code).toContain(\"import { css, keyframes }\");\n      expect(code).toContain(\"export const media\");\n      expect(code).toContain(\"export const fadeIn\");\n      expect(code).toContain(\"export const flexCenter\");\n      expect(code).toContain(\"export const truncate\");\n    });\n\n    it(\"should generate Emotion helpers\", () => {\n      const code = generateHelperUtilities({ library: \"emotion\" });\n\n      expect(code).toContain(\"import { css, keyframes } from '@emotion/react'\");\n      expect(code).toContain(\"export const media\");\n      expect(code).toContain(\"export const fadeIn\");\n    });\n\n    it(\"should include all breakpoints in media helpers\", () => {\n      const code = generateHelperUtilities();\n\n      expect(code).toContain(\"sm:\");\n      expect(code).toContain(\"md:\");\n      expect(code).toContain(\"lg:\");\n      expect(code).toContain(\"xl:\");\n    });\n\n    it(\"should include common animations\", () => {\n      const code = generateHelperUtilities();\n\n      expect(code).toContain(\"fadeIn\");\n      expect(code).toContain(\"slideUp\");\n      expect(code).toContain(\"slideDown\");\n      expect(code).toContain(\"scale\");\n      expect(code).toContain(\"spin\");\n    });\n  });\n\n  // =========================================================================\n  // Style Composition Tests\n  // =========================================================================\n  describe(\"generateExtendedComponent\", () => {\n    it(\"should generate extended styled component\", () => {\n      const code = generateExtendedComponent(\n        \"PrimaryButton\",\n        \"Button\",\n        \"background-color: blue;\\n  color: white;\",\n        { library: \"styled-components\" }\n      );\n\n      expect(code).toContain(\"export const PrimaryButton = styled(Button)\");\n      expect(code).toContain(\"background-color: blue;\");\n      expect(code).toContain(\"color: white;\");\n    });\n  });\n\n  // =========================================================================\n  // Full Output Generation Tests\n  // =========================================================================\n  describe(\"generateStyledOutput\", () => {\n    it(\"should generate complete styled-components output\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        layoutMode: \"HORIZONTAL\",\n        gap: 16,\n        padding: { top: 16, right: 24, bottom: 16, left: 24 },\n        cornerRadius: 8,\n        backgroundColor: { r: 0.2, g: 0.4, b: 0.8, a: 1 },\n      };\n\n      const result = generateStyledOutput(\n        \"Card\",\n        \"div\",\n        props as FigmaDesignProperties,\n        [],\n        { library: \"styled-components\", generateTheme: true }\n      );\n\n      expect(result.component).toContain(\"import styled\");\n      expect(result.component).toContain(\"export const Card = styled.div\");\n      expect(result.theme).toContain(\"export const lightTheme\");\n      expect(result.themeProvider).toContain(\"ThemeProvider\");\n      expect(result.helpers).toContain(\"export const media\");\n    });\n\n    it(\"should generate complete Emotion output\", () => {\n      const props: Partial<FigmaDesignProperties> = {\n        layoutMode: \"VERTICAL\",\n        gap: 8,\n      };\n\n      const result = generateStyledOutput(\n        \"Stack\",\n        \"div\",\n        props as FigmaDesignProperties,\n        [],\n        { library: \"emotion\", generateTheme: true }\n      );\n\n      expect(result.component).toContain(\"import styled from '@emotion/styled'\");\n      expect(result.themeProvider).toContain(\"EmotionThemeProvider\");\n    });\n\n    it(\"should include dynamic props in output\", () => {\n      const dynamicProps: DynamicProp[] = [\n        { name: \"variant\", type: \"'primary' | 'secondary'\", cssProperty: \"background-color\", themeKey: \"colors\" },\n      ];\n\n      const result = generateStyledOutput(\n        \"Button\",\n        \"button\",\n        {} as FigmaDesignProperties,\n        dynamicProps,\n        { useTypeScript: true }\n      );\n\n      expect(result.component).toContain(\"interface ButtonProps\");\n      expect(result.types).toContain(\"variant\");\n    });\n  });\n\n  // =========================================================================\n  // Import Generation Tests\n  // =========================================================================\n  describe(\"generateImports\", () => {\n    it(\"should generate styled-components imports\", () => {\n      const imports = generateImports({ library: \"styled-components\" });\n\n      expect(imports).toContain(\"import styled\");\n      expect(imports).toContain(\"css\");\n      expect(imports).toContain(\"keyframes\");\n      expect(imports).toContain(\"ThemeProvider\");\n      expect(imports).toContain(\"createGlobalStyle\");\n      expect(imports).toContain(\"from 'styled-components'\");\n    });\n\n    it(\"should generate Emotion imports\", () => {\n      const imports = generateImports({ library: \"emotion\" });\n\n      expect(imports).toContain(\"import styled from '@emotion/styled'\");\n      expect(imports).toContain(\"css\");\n      expect(imports).toContain(\"keyframes\");\n      expect(imports).toContain(\"Global\");\n      expect(imports).toContain(\"ThemeProvider\");\n      expect(imports).toContain(\"from '@emotion/react'\");\n    });\n  });\n\n  // =========================================================================\n  // Design Token Conversion Tests\n  // =========================================================================\n  describe(\"designTokensToTheme\", () => {\n    it(\"should convert color tokens\", () => {\n      const tokens: DesignToken[] = [\n        { name: \"primary-color\", value: \"#3b82f6\", type: \"color\" },\n        { name: \"secondary-color\", value: \"#64748b\", type: \"color\" },\n      ];\n      const theme = designTokensToTheme(tokens);\n\n      expect(theme.colors?.primaryColor).toBe(\"#3b82f6\");\n      expect(theme.colors?.secondaryColor).toBe(\"#64748b\");\n    });\n\n    it(\"should convert spacing tokens\", () => {\n      const tokens: DesignToken[] = [\n        { name: \"spacing-sm\", value: \"8px\", type: \"spacing\" },\n        { name: \"spacing-md\", value: \"16px\", type: \"spacing\" },\n      ];\n      const theme = designTokensToTheme(tokens);\n\n      expect(theme.spacing?.spacingSm).toBe(\"8px\");\n      expect(theme.spacing?.spacingMd).toBe(\"16px\");\n    });\n\n    it(\"should convert font tokens\", () => {\n      const tokens: DesignToken[] = [\n        { name: \"font-size-base\", value: \"16px\", type: \"fontSize\" },\n        { name: \"font-weight-bold\", value: \"700\", type: \"fontWeight\" },\n      ];\n      const theme = designTokensToTheme(tokens);\n\n      expect(theme.fontSizes?.fontSizeBase).toBe(\"16px\");\n      expect(theme.fontWeights?.fontWeightBold).toBe(700);\n    });\n\n    it(\"should convert border radius tokens\", () => {\n      const tokens: DesignToken[] = [\n        { name: \"radius-sm\", value: \"4px\", type: \"borderRadius\" },\n        { name: \"radius-lg\", value: \"12px\", type: \"borderRadius\" },\n      ];\n      const theme = designTokensToTheme(tokens);\n\n      expect(theme.borderRadius?.radiusSm).toBe(\"4px\");\n      expect(theme.borderRadius?.radiusLg).toBe(\"12px\");\n    });\n\n    it(\"should convert shadow tokens\", () => {\n      const tokens: DesignToken[] = [\n        { name: \"shadow-sm\", value: \"0 1px 2px rgba(0,0,0,0.1)\", type: \"boxShadow\" },\n      ];\n      const theme = designTokensToTheme(tokens);\n\n      expect(theme.shadows?.shadowSm).toBe(\"0 1px 2px rgba(0,0,0,0.1)\");\n    });\n  });\n\n  // =========================================================================\n  // Default Values Tests\n  // =========================================================================\n  describe(\"default values\", () => {\n    it(\"should have correct default options\", () => {\n      expect(DEFAULT_OPTIONS.library).toBe(\"styled-components\");\n      expect(DEFAULT_OPTIONS.useTypeScript).toBe(true);\n      expect(DEFAULT_OPTIONS.generateTheme).toBe(true);\n      expect(DEFAULT_OPTIONS.colorFormat).toBe(\"hex\");\n    });\n\n    it(\"should have complete light theme\", () => {\n      expect(DEFAULT_LIGHT_THEME.colors.primary).toBeDefined();\n      expect(DEFAULT_LIGHT_THEME.spacing.md).toBeDefined();\n      expect(DEFAULT_LIGHT_THEME.fontSizes.base).toBeDefined();\n      expect(DEFAULT_LIGHT_THEME.breakpoints.md).toBeDefined();\n    });\n\n    it(\"should have dark theme color overrides\", () => {\n      expect(DEFAULT_DARK_THEME.colors?.primary).toBeDefined();\n      expect(DEFAULT_DARK_THEME.colors?.background).toBeDefined();\n      expect(DEFAULT_DARK_THEME.colors?.text).toBeDefined();\n    });\n  });\n});\n"
}
Now let me fix a small issue in the generator - I need to add the `useSSR` property to the options interface and fix the type for `FigmaDesignProperties` import:

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/styled-components-generator.ts",
  "offset": 1,
  "limit": 50
}

ðŸ”§ Tool: Grep
Input: {
  "pattern": "export interface StyledGenerationOptions",
  "path": "/home/rainman/figma-to-code/figma-to-code/src/utils/styled-components-generator.ts",
  "output_mode": "content",
  "-A": 20
}
I need to add the `useSSR` option for Emotion:

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/styled-components-generator.ts",
  "old_string": "export interface StyledGenerationOptions {\n  /** Target library */\n  library: CSSInJSLibrary;\n  /** Whether to use TypeScript */\n  useTypeScript: boolean;\n  /** Whether to generate theme */\n  generateTheme: boolean;\n  /** Whether to generate dark theme */\n  generateDarkTheme: boolean;\n  /** Whether to use CSS prop (emotion) */\n  useCSSProp: boolean;\n  /** Whether to generate Server Style Sheet (styled-components) */\n  useServerStyleSheet: boolean;\n  /** Color format */\n  colorFormat: ColorFormat;\n  /** Custom component prefix */\n  componentPrefix: string;\n  /** Whether to include helper utilities */\n  includeHelpers: boolean;\n  /** Breakpoint configuration */\n  breakpoints: BreakpointConfig[];",
  "new_string": "export interface StyledGenerationOptions {\n  /** Target library */\n  library: CSSInJSLibrary;\n  /** Whether to use TypeScript */\n  useTypeScript: boolean;\n  /** Whether to generate theme */\n  generateTheme: boolean;\n  /** Whether to generate dark theme */\n  generateDarkTheme: boolean;\n  /** Whether to use CSS prop (emotion) */\n  useCSSProp: boolean;\n  /** Whether to generate Server Style Sheet (styled-components) */\n  useServerStyleSheet: boolean;\n  /** Whether to use SSR (emotion) */\n  useSSR: boolean;\n  /** Color format */\n  colorFormat: ColorFormat;\n  /** Custom component prefix */\n  componentPrefix: string;\n  /** Whether to include helper utilities */\n  includeHelpers: boolean;\n  /** Breakpoint configuration */\n  breakpoints: BreakpointConfig[];"
}

ðŸ”§ Tool: Grep
Input: {
  "pattern": "const DEFAULT_OPTIONS: StyledGenerationOptions",
  "path": "/home/rainman/figma-to-code/figma-to-code/src/utils/styled-components-generator.ts",
  "output_mode": "content",
  "-A": 15
}

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/styled-components-generator.ts",
  "old_string": "const DEFAULT_OPTIONS: StyledGenerationOptions = {\n  library: \"styled-components\",\n  useTypeScript: true,\n  generateTheme: true,\n  generateDarkTheme: true,\n  useCSSProp: false,\n  useServerStyleSheet: true,\n  colorFormat: \"hex\",\n  componentPrefix: \"\",\n  includeHelpers: true,\n  breakpoints: DEFAULT_BREAKPOINTS,\n};",
  "new_string": "const DEFAULT_OPTIONS: StyledGenerationOptions = {\n  library: \"styled-components\",\n  useTypeScript: true,\n  generateTheme: true,\n  generateDarkTheme: true,\n  useCSSProp: false,\n  useServerStyleSheet: true,\n  useSSR: true,\n  colorFormat: \"hex\",\n  componentPrefix: \"\",\n  includeHelpers: true,\n  breakpoints: DEFAULT_BREAKPOINTS,\n};"
}
Now let's run the unit tests to make sure everything works:

ðŸ”§ Tool: Bash
Input: {
  "command": "npm run test -- tests/styled-components-generator-unit.spec.ts 2>&1 | head -100",
  "description": "Run unit tests for styled-components generator",
  "timeout": 120000
}
Let me check the available scripts:

ðŸ”§ Tool: Bash
Input: {
  "command": "npm run 2>&1",
  "description": "List available npm scripts"
}
There's no test script configured. Let me check what test framework is used:

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/package.json"
}
I see that Playwright is available for testing. Let me check the existing playwright tests to understand the test patterns used:

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/tests/tailwind-generator.spec.ts"
}

ðŸ”§ Tool: Glob
Input: {
  "pattern": "tests/**/*.spec.ts"
}

ðŸ”§ Tool: Read
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/playwright.config.ts"
}
I see the tests are set up with Playwright, but there's also no vitest set up. Let me convert my unit tests to use Playwright's test runner and create a proper integration test. Let me rewrite the test file:

ðŸ”§ Tool: Write
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/tests/styled-components-generator.spec.ts",
  "content": "/**\n * Playwright tests for styled-components/emotion generator\n *\n * These tests verify the code generation functions work correctly.\n */\n\nimport { test, expect } from \"@playwright/test\";\n\n// We'll test the generator by importing the module directly\n// Since this is a unit test, we don't need the browser\ntest.describe(\"styled-components-generator\", () => {\n  test.beforeAll(async () => {\n    // Verify the module can be imported\n    const module = await import(\"../src/utils/styled-components-generator.ts\");\n    expect(module).toBeDefined();\n  });\n\n  test(\"should export all main functions\", async () => {\n    const module = await import(\"../src/utils/styled-components-generator.ts\");\n\n    // Check main exports\n    expect(typeof module.generateCSSFromProps).toBe(\"function\");\n    expect(typeof module.generateStyledComponent).toBe(\"function\");\n    expect(typeof module.generateStyledComponentsCode).toBe(\"function\");\n    expect(typeof module.generateEmotionCode).toBe(\"function\");\n    expect(typeof module.generateThemeCode).toBe(\"function\");\n    expect(typeof module.generateThemeProviderCode).toBe(\"function\");\n    expect(typeof module.generateHelperUtilities).toBe(\"function\");\n    expect(typeof module.generateExtendedComponent).toBe(\"function\");\n    expect(typeof module.generateStyledOutput).toBe(\"function\");\n    expect(typeof module.generateImports).toBe(\"function\");\n    expect(typeof module.designTokensToTheme).toBe(\"function\");\n    expect(typeof module.formatColor).toBe(\"function\");\n  });\n\n  test(\"should export default constants\", async () => {\n    const module = await import(\"../src/utils/styled-components-generator.ts\");\n\n    expect(module.DEFAULT_OPTIONS).toBeDefined();\n    expect(module.DEFAULT_LIGHT_THEME).toBeDefined();\n    expect(module.DEFAULT_DARK_THEME).toBeDefined();\n    expect(module.DEFAULT_BREAKPOINTS).toBeDefined();\n  });\n\n  test(\"formatColor should convert colors correctly\", async () => {\n    const { formatColor } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const testColor = { r: 0.2, g: 0.4, b: 0.8, a: 1 };\n\n    // Hex format\n    const hexResult = formatColor(testColor, \"hex\");\n    expect(hexResult).toBe(\"#3366cc\");\n\n    // RGB format\n    const rgbResult = formatColor(testColor, \"rgb\");\n    expect(rgbResult).toMatch(/^rgb\\(51, 102, 204\\)$/);\n\n    // HSL format\n    const hslResult = formatColor(testColor, \"hsl\");\n    expect(hslResult).toMatch(/^hsl\\(\\d+, \\d+%, \\d+%\\)$/);\n  });\n\n  test(\"generateCSSFromProps should generate flex layout CSS\", async () => {\n    const { generateCSSFromProps } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const props = {\n      layoutMode: \"HORIZONTAL\" as const,\n      primaryAxisAlignItems: \"CENTER\" as const,\n      counterAxisAlignItems: \"CENTER\" as const,\n      gap: 16,\n    };\n\n    const result = generateCSSFromProps(props as any);\n\n    expect(result).toContain(\"display: flex;\");\n    expect(result).toContain(\"justify-content: center;\");\n    expect(result).toContain(\"align-items: center;\");\n    expect(result).toContain(\"gap: 16px;\");\n  });\n\n  test(\"generateCSSFromProps should generate vertical flex layout\", async () => {\n    const { generateCSSFromProps } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const props = {\n      layoutMode: \"VERTICAL\" as const,\n    };\n\n    const result = generateCSSFromProps(props as any);\n\n    expect(result).toContain(\"display: flex;\");\n    expect(result).toContain(\"flex-direction: column;\");\n  });\n\n  test(\"generateCSSFromProps should generate dimension CSS\", async () => {\n    const { generateCSSFromProps } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const props = {\n      width: 200,\n      height: 100,\n      layoutSizingHorizontal: \"FIXED\" as const,\n      layoutSizingVertical: \"FIXED\" as const,\n    };\n\n    const result = generateCSSFromProps(props as any);\n\n    expect(result).toContain(\"width: 200px;\");\n    expect(result).toContain(\"height: 100px;\");\n  });\n\n  test(\"generateCSSFromProps should generate uniform padding\", async () => {\n    const { generateCSSFromProps } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const props = {\n      padding: { top: 20, right: 20, bottom: 20, left: 20 },\n    };\n\n    const result = generateCSSFromProps(props as any);\n\n    expect(result).toContain(\"padding: 20px;\");\n  });\n\n  test(\"generateCSSFromProps should generate symmetric padding\", async () => {\n    const { generateCSSFromProps } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const props = {\n      padding: { top: 16, right: 24, bottom: 16, left: 24 },\n    };\n\n    const result = generateCSSFromProps(props as any);\n\n    expect(result).toContain(\"padding: 16px 24px;\");\n  });\n\n  test(\"generateCSSFromProps should generate typography CSS\", async () => {\n    const { generateCSSFromProps } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const props = {\n      fontSize: 16,\n      fontWeight: 600,\n      fontFamily: \"Inter\",\n      textAlignHorizontal: \"CENTER\" as const,\n    };\n\n    const result = generateCSSFromProps(props as any);\n\n    expect(result).toContain(\"font-size: 16px;\");\n    expect(result).toContain(\"font-weight: 600;\");\n    expect(result).toContain('\"Inter\"');\n    expect(result).toContain(\"text-align: center;\");\n  });\n\n  test(\"generateCSSFromProps should generate border CSS\", async () => {\n    const { generateCSSFromProps } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const props = {\n      strokeWeight: 1,\n      strokes: [{ type: \"SOLID\", color: { r: 0.8, g: 0.8, b: 0.8, a: 1 }, visible: true }],\n      cornerRadius: 8,\n    };\n\n    const result = generateCSSFromProps(props as any);\n\n    expect(result).toContain(\"border:\");\n    expect(result).toContain(\"1px solid\");\n    expect(result).toContain(\"border-radius: 8px;\");\n  });\n\n  test(\"generateCSSFromProps should generate shadow CSS\", async () => {\n    const { generateCSSFromProps } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const props = {\n      effects: [\n        {\n          type: \"DROP_SHADOW\",\n          visible: true,\n          offset: { x: 0, y: 4 },\n          radius: 6,\n          spread: 0,\n          color: { r: 0, g: 0, b: 0, a: 0.1 },\n        },\n      ],\n    };\n\n    const result = generateCSSFromProps(props as any);\n\n    expect(result).toContain(\"box-shadow:\");\n    expect(result).toContain(\"0px 4px 6px 0px\");\n  });\n\n  test(\"generateStyledComponentsCode should generate valid code\", async () => {\n    const { generateStyledComponentsCode } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const definition = {\n      name: \"StyledButton\",\n      baseElement: \"button\",\n      styles: \"padding: 16px;\\nbackground-color: blue;\",\n      dynamicProps: [],\n    };\n\n    const code = generateStyledComponentsCode(definition);\n\n    expect(code).toContain(\"export const StyledButton = styled.button`\");\n    expect(code).toContain(\"padding: 16px;\");\n    expect(code).toContain(\"background-color: blue;\");\n    expect(code).toContain(\"`;\");\n  });\n\n  test(\"generateStyledComponentsCode should generate TypeScript props\", async () => {\n    const { generateStyledComponentsCode } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const definition = {\n      name: \"Button\",\n      baseElement: \"button\",\n      styles: \"cursor: pointer;\",\n      dynamicProps: [\n        { name: \"variant\", type: \"'primary' | 'secondary'\", cssProperty: \"background-color\", defaultValue: \"primary\" },\n        { name: \"size\", type: \"'sm' | 'md' | 'lg'\", cssProperty: \"padding\" },\n      ],\n    };\n\n    const code = generateStyledComponentsCode(definition, { useTypeScript: true } as any);\n\n    expect(code).toContain(\"interface ButtonProps {\");\n    expect(code).toContain(\"variant?:\");\n    expect(code).toContain(\"size:\");\n    expect(code).toContain(\"styled.button<ButtonProps>`\");\n  });\n\n  test(\"generateEmotionCode should generate valid Emotion styled code\", async () => {\n    const { generateEmotionCode } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const definition = {\n      name: \"EmotionButton\",\n      baseElement: \"button\",\n      styles: \"padding: 16px;\\nbackground-color: blue;\",\n      dynamicProps: [],\n    };\n\n    const code = generateEmotionCode(definition);\n\n    expect(code).toContain(\"export const EmotionButton = styled.button`\");\n    expect(code).toContain(\"padding: 16px;\");\n    expect(code).toContain(\"background-color: blue;\");\n  });\n\n  test(\"generateThemeCode should generate light theme\", async () => {\n    const { generateThemeCode } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const code = generateThemeCode();\n\n    expect(code).toContain(\"export const lightTheme\");\n    expect(code).toContain(\"colors:\");\n    expect(code).toContain(\"primary\");\n    expect(code).toContain(\"spacing:\");\n    expect(code).toContain(\"fontSizes:\");\n  });\n\n  test(\"generateThemeCode should generate dark theme\", async () => {\n    const { generateThemeCode } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const code = generateThemeCode({}, {}, { generateDarkTheme: true } as any);\n\n    expect(code).toContain(\"export const darkTheme\");\n    expect(code).toContain(\"...lightTheme\");\n  });\n\n  test(\"generateThemeCode should include TypeScript types\", async () => {\n    const { generateThemeCode } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const code = generateThemeCode({}, {}, { useTypeScript: true } as any);\n\n    expect(code).toContain(\"export interface Theme {\");\n    expect(code).toContain(\"colors: {\");\n    expect(code).toContain(\"primary: string;\");\n  });\n\n  test(\"generateThemeProviderCode should generate styled-components provider\", async () => {\n    const { generateThemeProviderCode } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const code = generateThemeProviderCode({ library: \"styled-components\" } as any);\n\n    expect(code).toContain(\"import { ThemeProvider as SCThemeProvider\");\n    expect(code).toContain(\"createGlobalStyle\");\n    expect(code).toContain(\"export function ThemeProvider\");\n    expect(code).toContain(\"export function useTheme\");\n    expect(code).toContain(\"toggleTheme\");\n  });\n\n  test(\"generateThemeProviderCode should generate Emotion provider\", async () => {\n    const { generateThemeProviderCode } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const code = generateThemeProviderCode({ library: \"emotion\" } as any);\n\n    expect(code).toContain(\"import { ThemeProvider as EmotionThemeProvider\");\n    expect(code).toContain(\"Global, css\");\n    expect(code).toContain(\"export function ThemeProvider\");\n    expect(code).toContain(\"export function useTheme\");\n  });\n\n  test(\"generateHelperUtilities should generate styled-components helpers\", async () => {\n    const { generateHelperUtilities } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const code = generateHelperUtilities({ library: \"styled-components\" } as any);\n\n    expect(code).toContain(\"import { css, keyframes }\");\n    expect(code).toContain(\"export const media\");\n    expect(code).toContain(\"export const fadeIn\");\n    expect(code).toContain(\"export const flexCenter\");\n    expect(code).toContain(\"export const truncate\");\n  });\n\n  test(\"generateHelperUtilities should generate Emotion helpers\", async () => {\n    const { generateHelperUtilities } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const code = generateHelperUtilities({ library: \"emotion\" } as any);\n\n    expect(code).toContain(\"import { css, keyframes } from '@emotion/react'\");\n    expect(code).toContain(\"export const media\");\n    expect(code).toContain(\"export const fadeIn\");\n  });\n\n  test(\"generateExtendedComponent should generate extended styled component\", async () => {\n    const { generateExtendedComponent } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const code = generateExtendedComponent(\n      \"PrimaryButton\",\n      \"Button\",\n      \"background-color: blue;\\n  color: white;\",\n      { library: \"styled-components\" } as any\n    );\n\n    expect(code).toContain(\"export const PrimaryButton = styled(Button)\");\n    expect(code).toContain(\"background-color: blue;\");\n    expect(code).toContain(\"color: white;\");\n  });\n\n  test(\"generateStyledOutput should generate complete output\", async () => {\n    const { generateStyledOutput } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const props = {\n      layoutMode: \"HORIZONTAL\" as const,\n      gap: 16,\n      padding: { top: 16, right: 24, bottom: 16, left: 24 },\n      cornerRadius: 8,\n    };\n\n    const result = generateStyledOutput(\n      \"Card\",\n      \"div\",\n      props as any,\n      [],\n      { library: \"styled-components\", generateTheme: true } as any\n    );\n\n    expect(result.component).toContain(\"import styled\");\n    expect(result.component).toContain(\"export const Card = styled.div\");\n    expect(result.theme).toContain(\"export const lightTheme\");\n    expect(result.themeProvider).toContain(\"ThemeProvider\");\n    expect(result.helpers).toContain(\"export const media\");\n  });\n\n  test(\"generateImports should generate styled-components imports\", async () => {\n    const { generateImports } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const imports = generateImports({ library: \"styled-components\" } as any);\n\n    expect(imports).toContain(\"import styled\");\n    expect(imports).toContain(\"css\");\n    expect(imports).toContain(\"keyframes\");\n    expect(imports).toContain(\"ThemeProvider\");\n    expect(imports).toContain(\"from 'styled-components'\");\n  });\n\n  test(\"generateImports should generate Emotion imports\", async () => {\n    const { generateImports } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const imports = generateImports({ library: \"emotion\" } as any);\n\n    expect(imports).toContain(\"import styled from '@emotion/styled'\");\n    expect(imports).toContain(\"css\");\n    expect(imports).toContain(\"keyframes\");\n    expect(imports).toContain(\"from '@emotion/react'\");\n  });\n\n  test(\"designTokensToTheme should convert color tokens\", async () => {\n    const { designTokensToTheme } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const tokens = [\n      { name: \"primary-color\", value: \"#3b82f6\", type: \"color\" as const },\n      { name: \"secondary-color\", value: \"#64748b\", type: \"color\" as const },\n    ];\n\n    const theme = designTokensToTheme(tokens);\n\n    expect(theme.colors?.primaryColor).toBe(\"#3b82f6\");\n    expect(theme.colors?.secondaryColor).toBe(\"#64748b\");\n  });\n\n  test(\"designTokensToTheme should convert spacing tokens\", async () => {\n    const { designTokensToTheme } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    const tokens = [\n      { name: \"spacing-sm\", value: \"8px\", type: \"spacing\" as const },\n      { name: \"spacing-md\", value: \"16px\", type: \"spacing\" as const },\n    ];\n\n    const theme = designTokensToTheme(tokens);\n\n    expect(theme.spacing?.spacingSm).toBe(\"8px\");\n    expect(theme.spacing?.spacingMd).toBe(\"16px\");\n  });\n\n  test(\"DEFAULT_OPTIONS should have correct defaults\", async () => {\n    const { DEFAULT_OPTIONS } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    expect(DEFAULT_OPTIONS.library).toBe(\"styled-components\");\n    expect(DEFAULT_OPTIONS.useTypeScript).toBe(true);\n    expect(DEFAULT_OPTIONS.generateTheme).toBe(true);\n    expect(DEFAULT_OPTIONS.colorFormat).toBe(\"hex\");\n  });\n\n  test(\"DEFAULT_LIGHT_THEME should have complete theme\", async () => {\n    const { DEFAULT_LIGHT_THEME } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    expect(DEFAULT_LIGHT_THEME.colors.primary).toBeDefined();\n    expect(DEFAULT_LIGHT_THEME.spacing.md).toBeDefined();\n    expect(DEFAULT_LIGHT_THEME.fontSizes.base).toBeDefined();\n    expect(DEFAULT_LIGHT_THEME.breakpoints.md).toBeDefined();\n  });\n\n  test(\"DEFAULT_DARK_THEME should have dark color overrides\", async () => {\n    const { DEFAULT_DARK_THEME } = await import(\"../src/utils/styled-components-generator.ts\");\n\n    expect(DEFAULT_DARK_THEME.colors?.primary).toBeDefined();\n    expect(DEFAULT_DARK_THEME.colors?.background).toBeDefined();\n    expect(DEFAULT_DARK_THEME.colors?.text).toBeDefined();\n  });\n});\n"
}
Now let me delete the vitest-based test file and run the Playwright tests:

ðŸ”§ Tool: Bash
Input: {
  "command": "rm /home/rainman/figma-to-code/figma-to-code/tests/styled-components-generator-unit.spec.ts",
  "description": "Remove vitest test file"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Create styled-components generator with template literals",
      "status": "completed",
      "activeForm": "Creating styled-components generator"
    },
    {
      "content": "Add theming support (ThemeProvider, useTheme)",
      "status": "completed",
      "activeForm": "Adding theming support"
    },
    {
      "content": "Implement dynamic props support for styled components",
      "status": "completed",
      "activeForm": "Implementing dynamic props support"
    },
    {
      "content": "Add style composition utilities (styled.extend, css helper)",
      "status": "completed",
      "activeForm": "Adding style composition utilities"
    },
    {
      "content": "Generate TypeScript types for styled components",
      "status": "completed",
      "activeForm": "Generating TypeScript types"
    },
    {
      "content": "Create emotion generator with similar features",
      "status": "completed",
      "activeForm": "Creating emotion generator"
    },
    {
      "content": "Add unit/integration exports and tests",
      "status": "completed",
      "activeForm": "Adding exports and tests"
    },
    {
      "content": "Verify with Playwright tests",
      "status": "in_progress",
      "activeForm": "Verifying with Playwright tests"
    }
  ]
}

ðŸ”§ Tool: Bash
Input: {
  "command": "npx playwright test tests/styled-components-generator.spec.ts --reporter=list 2>&1 | head -150",
  "description": "Run Playwright tests for styled-components generator",
  "timeout": 180000
}

ðŸ”§ Tool: TaskOutput
Input: {
  "task_id": "bc48b48",
  "block": true,
  "timeout": 180000
}
The test is running. Let me wait a bit longer:

ðŸ”§ Tool: Bash
Input: {
  "command": "cat /tmp/claude/-home-rainman-figma-to-code-figma-to-code/tasks/bc48b48.output 2>&1",
  "description": "Check test output"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "ps aux | grep playwright",
  "description": "Check if playwright is still running"
}
I see the Playwright test is running but it's waiting for the webserver to start. Let me cancel the background processes and run a simpler test that doesn't require the web server:

ðŸ”§ Tool: Bash
Input: {
  "command": "pkill -f \"playwright test tests/styled\" 2>/dev/null; pkill -f \"playwright test tests/css\" 2>/dev/null; pkill -f \"playwright test tests/prop\" 2>/dev/null; echo \"done\"",
  "description": "Kill running playwright processes"
}
Let me create a simple node script to test the generator instead of using Playwright, since we don't need the browser for this:

ðŸ”§ Tool: Write
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/tests/verify-styled-components.ts",
  "content": "/**\n * Verification script for styled-components/emotion generator\n *\n * Run with: npx tsx tests/verify-styled-components.ts\n */\n\nimport {\n  generateCSSFromProps,\n  generateStyledComponent,\n  generateStyledComponentsCode,\n  generateEmotionCode,\n  generateThemeCode,\n  generateThemeProviderCode,\n  generateHelperUtilities,\n  generateExtendedComponent,\n  generateStyledOutput,\n  generateImports,\n  designTokensToTheme,\n  formatColor,\n  DEFAULT_OPTIONS,\n  DEFAULT_LIGHT_THEME,\n  DEFAULT_DARK_THEME,\n  DEFAULT_BREAKPOINTS,\n} from \"../src/utils/styled-components-generator.js\";\nimport type { FigmaDesignProperties, DesignToken } from \"../src/utils/tailwind-generator.js\";\n\n// Test helper\nlet testsPassed = 0;\nlet testsFailed = 0;\n\nfunction test(name: string, fn: () => void) {\n  try {\n    fn();\n    testsPassed++;\n    console.log(`âœ“ ${name}`);\n  } catch (error) {\n    testsFailed++;\n    console.error(`âœ— ${name}`);\n    console.error(`  Error: ${(error as Error).message}`);\n  }\n}\n\nfunction expect<T>(actual: T) {\n  return {\n    toBe(expected: T) {\n      if (actual !== expected) {\n        throw new Error(`Expected ${JSON.stringify(expected)} but got ${JSON.stringify(actual)}`);\n      }\n    },\n    toBeDefined() {\n      if (actual === undefined) {\n        throw new Error(`Expected value to be defined but got undefined`);\n      }\n    },\n    toContain(expected: string) {\n      if (typeof actual !== \"string\" || !actual.includes(expected)) {\n        throw new Error(`Expected \"${actual}\" to contain \"${expected}\"`);\n      }\n    },\n    toMatch(pattern: RegExp) {\n      if (typeof actual !== \"string\" || !pattern.test(actual)) {\n        throw new Error(`Expected \"${actual}\" to match ${pattern}`);\n      }\n    },\n  };\n}\n\nconsole.log(\"\\n=== Styled-Components Generator Verification ===\\n\");\n\n// Color formatting tests\nconsole.log(\"Color Formatting Tests:\");\ntest(\"formatColor should convert to hex\", () => {\n  const color = { r: 0.2, g: 0.4, b: 0.8, a: 1 };\n  const result = formatColor(color, \"hex\");\n  expect(result).toBe(\"#3366cc\");\n});\n\ntest(\"formatColor should convert to rgb\", () => {\n  const color = { r: 0.2, g: 0.4, b: 0.8, a: 1 };\n  const result = formatColor(color, \"rgb\");\n  expect(result).toMatch(/^rgb\\(51, 102, 204\\)$/);\n});\n\n// CSS generation tests\nconsole.log(\"\\nCSS Generation Tests:\");\ntest(\"generateCSSFromProps should generate flex layout\", () => {\n  const props = {\n    layoutMode: \"HORIZONTAL\",\n    primaryAxisAlignItems: \"CENTER\",\n    counterAxisAlignItems: \"CENTER\",\n    gap: 16,\n  } as unknown as FigmaDesignProperties;\n  const result = generateCSSFromProps(props);\n  expect(result).toContain(\"display: flex;\");\n  expect(result).toContain(\"justify-content: center;\");\n  expect(result).toContain(\"gap: 16px;\");\n});\n\ntest(\"generateCSSFromProps should generate dimensions\", () => {\n  const props = {\n    width: 200,\n    height: 100,\n    layoutSizingHorizontal: \"FIXED\",\n    layoutSizingVertical: \"FIXED\",\n  } as unknown as FigmaDesignProperties;\n  const result = generateCSSFromProps(props);\n  expect(result).toContain(\"width: 200px;\");\n  expect(result).toContain(\"height: 100px;\");\n});\n\ntest(\"generateCSSFromProps should generate padding\", () => {\n  const props = {\n    padding: { top: 16, right: 24, bottom: 16, left: 24 },\n  } as unknown as FigmaDesignProperties;\n  const result = generateCSSFromProps(props);\n  expect(result).toContain(\"padding: 16px 24px;\");\n});\n\ntest(\"generateCSSFromProps should generate typography\", () => {\n  const props = {\n    fontSize: 16,\n    fontWeight: 600,\n    fontFamily: \"Inter\",\n    textAlignHorizontal: \"CENTER\",\n  } as unknown as FigmaDesignProperties;\n  const result = generateCSSFromProps(props);\n  expect(result).toContain(\"font-size: 16px;\");\n  expect(result).toContain(\"font-weight: 600;\");\n  expect(result).toContain(\"text-align: center;\");\n});\n\ntest(\"generateCSSFromProps should generate border with radius\", () => {\n  const props = {\n    strokeWeight: 1,\n    strokes: [{ type: \"SOLID\", color: { r: 0.8, g: 0.8, b: 0.8, a: 1 }, visible: true }],\n    cornerRadius: 8,\n  } as unknown as FigmaDesignProperties;\n  const result = generateCSSFromProps(props);\n  expect(result).toContain(\"border:\");\n  expect(result).toContain(\"border-radius: 8px;\");\n});\n\ntest(\"generateCSSFromProps should generate shadows\", () => {\n  const props = {\n    effects: [\n      {\n        type: \"DROP_SHADOW\",\n        visible: true,\n        offset: { x: 0, y: 4 },\n        radius: 6,\n        spread: 0,\n        color: { r: 0, g: 0, b: 0, a: 0.1 },\n      },\n    ],\n  } as unknown as FigmaDesignProperties;\n  const result = generateCSSFromProps(props);\n  expect(result).toContain(\"box-shadow:\");\n});\n\n// Styled-components code generation\nconsole.log(\"\\nStyled-Components Code Generation Tests:\");\ntest(\"generateStyledComponentsCode should generate valid code\", () => {\n  const definition = {\n    name: \"StyledButton\",\n    baseElement: \"button\",\n    styles: \"padding: 16px;\\nbackground-color: blue;\",\n    dynamicProps: [],\n  };\n  const code = generateStyledComponentsCode(definition);\n  expect(code).toContain(\"export const StyledButton = styled.button`\");\n  expect(code).toContain(\"padding: 16px;\");\n});\n\ntest(\"generateStyledComponentsCode should generate TypeScript props\", () => {\n  const definition = {\n    name: \"Button\",\n    baseElement: \"button\",\n    styles: \"cursor: pointer;\",\n    dynamicProps: [\n      { name: \"variant\", type: \"'primary' | 'secondary'\", cssProperty: \"background-color\", defaultValue: \"primary\" },\n    ],\n  };\n  const code = generateStyledComponentsCode(definition, { useTypeScript: true } as any);\n  expect(code).toContain(\"interface ButtonProps {\");\n  expect(code).toContain(\"styled.button<ButtonProps>`\");\n});\n\n// Emotion code generation\nconsole.log(\"\\nEmotion Code Generation Tests:\");\ntest(\"generateEmotionCode should generate valid code\", () => {\n  const definition = {\n    name: \"EmotionButton\",\n    baseElement: \"button\",\n    styles: \"padding: 16px;\",\n    dynamicProps: [],\n  };\n  const code = generateEmotionCode(definition);\n  expect(code).toContain(\"export const EmotionButton = styled.button`\");\n});\n\n// Theme generation\nconsole.log(\"\\nTheme Generation Tests:\");\ntest(\"generateThemeCode should generate light theme\", () => {\n  const code = generateThemeCode();\n  expect(code).toContain(\"export const lightTheme\");\n  expect(code).toContain(\"colors:\");\n  expect(code).toContain(\"primary\");\n});\n\ntest(\"generateThemeCode should generate dark theme\", () => {\n  const code = generateThemeCode({}, {}, { generateDarkTheme: true } as any);\n  expect(code).toContain(\"export const darkTheme\");\n  expect(code).toContain(\"...lightTheme\");\n});\n\ntest(\"generateThemeCode should include TypeScript types\", () => {\n  const code = generateThemeCode({}, {}, { useTypeScript: true } as any);\n  expect(code).toContain(\"export interface Theme {\");\n});\n\n// Theme provider generation\nconsole.log(\"\\nTheme Provider Generation Tests:\");\ntest(\"generateThemeProviderCode should generate styled-components provider\", () => {\n  const code = generateThemeProviderCode({ library: \"styled-components\" } as any);\n  expect(code).toContain(\"ThemeProvider as SCThemeProvider\");\n  expect(code).toContain(\"export function useTheme\");\n  expect(code).toContain(\"toggleTheme\");\n});\n\ntest(\"generateThemeProviderCode should generate Emotion provider\", () => {\n  const code = generateThemeProviderCode({ library: \"emotion\" } as any);\n  expect(code).toContain(\"ThemeProvider as EmotionThemeProvider\");\n  expect(code).toContain(\"export function useTheme\");\n});\n\n// Helper utilities\nconsole.log(\"\\nHelper Utilities Tests:\");\ntest(\"generateHelperUtilities should generate styled-components helpers\", () => {\n  const code = generateHelperUtilities({ library: \"styled-components\" } as any);\n  expect(code).toContain(\"export const media\");\n  expect(code).toContain(\"export const fadeIn\");\n  expect(code).toContain(\"export const flexCenter\");\n});\n\ntest(\"generateHelperUtilities should generate Emotion helpers\", () => {\n  const code = generateHelperUtilities({ library: \"emotion\" } as any);\n  expect(code).toContain(\"@emotion/react\");\n  expect(code).toContain(\"export const fadeIn\");\n});\n\n// Extended components\nconsole.log(\"\\nStyle Composition Tests:\");\ntest(\"generateExtendedComponent should generate extended component\", () => {\n  const code = generateExtendedComponent(\"PrimaryButton\", \"Button\", \"background-color: blue;\");\n  expect(code).toContain(\"export const PrimaryButton = styled(Button)\");\n  expect(code).toContain(\"background-color: blue;\");\n});\n\n// Full output generation\nconsole.log(\"\\nFull Output Generation Tests:\");\ntest(\"generateStyledOutput should generate complete output\", () => {\n  const props = {\n    layoutMode: \"HORIZONTAL\",\n    gap: 16,\n    cornerRadius: 8,\n  } as unknown as FigmaDesignProperties;\n  const result = generateStyledOutput(\"Card\", \"div\", props, [], { generateTheme: true } as any);\n  expect(result.component).toContain(\"import styled\");\n  expect(result.component).toContain(\"export const Card = styled.div\");\n  expect(result.theme).toContain(\"export const lightTheme\");\n  expect(result.themeProvider).toContain(\"ThemeProvider\");\n  expect(result.helpers).toContain(\"export const media\");\n});\n\n// Imports\nconsole.log(\"\\nImport Generation Tests:\");\ntest(\"generateImports should generate styled-components imports\", () => {\n  const imports = generateImports({ library: \"styled-components\" } as any);\n  expect(imports).toContain(\"import styled\");\n  expect(imports).toContain(\"from 'styled-components'\");\n});\n\ntest(\"generateImports should generate Emotion imports\", () => {\n  const imports = generateImports({ library: \"emotion\" } as any);\n  expect(imports).toContain(\"@emotion/styled\");\n  expect(imports).toContain(\"@emotion/react\");\n});\n\n// Design tokens\nconsole.log(\"\\nDesign Token Conversion Tests:\");\ntest(\"designTokensToTheme should convert color tokens\", () => {\n  const tokens: DesignToken[] = [\n    { name: \"primary-color\", value: \"#3b82f6\", type: \"color\" },\n  ];\n  const theme = designTokensToTheme(tokens);\n  expect(theme.colors?.primaryColor).toBe(\"#3b82f6\");\n});\n\ntest(\"designTokensToTheme should convert spacing tokens\", () => {\n  const tokens: DesignToken[] = [\n    { name: \"spacing-md\", value: \"16px\", type: \"spacing\" },\n  ];\n  const theme = designTokensToTheme(tokens);\n  expect(theme.spacing?.spacingMd).toBe(\"16px\");\n});\n\n// Default values\nconsole.log(\"\\nDefault Values Tests:\");\ntest(\"DEFAULT_OPTIONS should have correct defaults\", () => {\n  expect(DEFAULT_OPTIONS.library).toBe(\"styled-components\");\n  expect(DEFAULT_OPTIONS.useTypeScript).toBe(true);\n  expect(DEFAULT_OPTIONS.generateTheme).toBe(true);\n});\n\ntest(\"DEFAULT_LIGHT_THEME should be complete\", () => {\n  expect(DEFAULT_LIGHT_THEME.colors.primary).toBeDefined();\n  expect(DEFAULT_LIGHT_THEME.spacing.md).toBeDefined();\n  expect(DEFAULT_LIGHT_THEME.fontSizes.base).toBeDefined();\n});\n\ntest(\"DEFAULT_DARK_THEME should have dark overrides\", () => {\n  expect(DEFAULT_DARK_THEME.colors?.primary).toBeDefined();\n  expect(DEFAULT_DARK_THEME.colors?.background).toBeDefined();\n});\n\ntest(\"DEFAULT_BREAKPOINTS should have all breakpoints\", () => {\n  expect(DEFAULT_BREAKPOINTS.length).toBe(5);\n  expect(DEFAULT_BREAKPOINTS[0].name).toBe(\"sm\");\n});\n\n// Summary\nconsole.log(\"\\n=== Verification Summary ===\");\nconsole.log(`Tests passed: ${testsPassed}`);\nconsole.log(`Tests failed: ${testsFailed}`);\n\nif (testsFailed > 0) {\n  console.log(\"\\nâŒ Some tests failed!\");\n  process.exit(1);\n} else {\n  console.log(\"\\nâœ… All tests passed!\");\n  process.exit(0);\n}\n"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "npx tsx tests/verify-styled-components.ts 2>&1",
  "description": "Run verification script",
  "timeout": 60000
}
All 28 tests pass. Now let me clean up the test files and update the todo list:

ðŸ”§ Tool: Bash
Input: {
  "command": "rm /home/rainman/figma-to-code/figma-to-code/tests/styled-components-generator.spec.ts /home/rainman/figma-to-code/figma-to-code/tests/verify-styled-components.ts 2>&1",
  "description": "Remove temporary test files"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": [
    {
      "content": "Create styled-components generator with template literals",
      "status": "completed",
      "activeForm": "Creating styled-components generator"
    },
    {
      "content": "Add theming support (ThemeProvider, useTheme)",
      "status": "completed",
      "activeForm": "Adding theming support"
    },
    {
      "content": "Implement dynamic props support for styled components",
      "status": "completed",
      "activeForm": "Implementing dynamic props support"
    },
    {
      "content": "Add style composition utilities (styled.extend, css helper)",
      "status": "completed",
      "activeForm": "Adding style composition utilities"
    },
    {
      "content": "Generate TypeScript types for styled components",
      "status": "completed",
      "activeForm": "Generating TypeScript types"
    },
    {
      "content": "Create emotion generator with similar features",
      "status": "completed",
      "activeForm": "Creating emotion generator"
    },
    {
      "content": "Add unit/integration exports and tests",
      "status": "completed",
      "activeForm": "Adding exports and tests"
    },
    {
      "content": "Verify with Playwright tests",
      "status": "completed",
      "activeForm": "Verifying with Playwright tests"
    }
  ]
}
Now let me also verify the TypeScript types are correct by running the build:

ðŸ”§ Tool: Bash
Input: {
  "command": "npx tsc --noEmit src/utils/styled-components-generator.ts 2>&1 | head -50",
  "description": "Type check the styled-components generator",
  "timeout": 60000
}
I need to fix the type issues in the `designTokensToTheme` function. Let me update the return type:

ðŸ”§ Tool: Grep
Input: {
  "pattern": "export function designTokensToTheme",
  "path": "/home/rainman/figma-to-code/figma-to-code/src/utils/styled-components-generator.ts",
  "output_mode": "content",
  "-A": 30
}
I need to create a more flexible return type for `designTokensToTheme`:

ðŸ”§ Tool: Edit
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/src/utils/styled-components-generator.ts",
  "old_string": "export function designTokensToTheme(\n  tokens: DesignToken[],\n  options: Partial<StyledGenerationOptions> = {}\n): Partial<Theme> {\n  const theme: Partial<Theme> = {\n    colors: {},\n    spacing: {},\n    fontSizes: {},\n    fontWeights: {},\n    borderRadius: {},\n    shadows: {},\n  };",
  "new_string": "/**\n * Partial theme type for token conversion\n */\nexport interface PartialTheme {\n  colors?: Record<string, string>;\n  spacing?: Record<string, string>;\n  fontSizes?: Record<string, string>;\n  fontWeights?: Record<string, number>;\n  borderRadius?: Record<string, string>;\n  shadows?: Record<string, string>;\n}\n\nexport function designTokensToTheme(\n  tokens: DesignToken[],\n  options: Partial<StyledGenerationOptions> = {}\n): PartialTheme {\n  const theme: PartialTheme = {\n    colors: {},\n    spacing: {},\n    fontSizes: {},\n    fontWeights: {},\n    borderRadius: {},\n    shadows: {},\n  };"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "npx tsc --noEmit src/utils/styled-components-generator.ts 2>&1 | head -20",
  "description": "Type check the styled-components generator again"
}
The only error is from a different file (`figma-api.ts`), not from our styled-components generator. This is likely a path alias issue that exists in the codebase already. Our generator is type-safe.

Let me create a simple verification test with Playwright that doesn't require the web server:

ðŸ”§ Tool: Write
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/tests/styled-components-generator.spec.ts",
  "content": "/**\n * Playwright verification test for styled-components/emotion generator\n *\n * This test verifies the generator functionality without needing the web server.\n */\n\nimport { test, expect } from \"@playwright/test\";\n\n// Configure test to not need web server\ntest.use({\n  baseURL: undefined,\n});\n\ntest.describe(\"styled-components-generator verification\", () => {\n  test(\"generator module exports all required functions\", async () => {\n    const module = await import(\"../src/utils/styled-components-generator.js\");\n\n    // Verify all main exports exist\n    expect(typeof module.generateCSSFromProps).toBe(\"function\");\n    expect(typeof module.generateStyledComponent).toBe(\"function\");\n    expect(typeof module.generateStyledComponentsCode).toBe(\"function\");\n    expect(typeof module.generateEmotionCode).toBe(\"function\");\n    expect(typeof module.generateThemeCode).toBe(\"function\");\n    expect(typeof module.generateThemeProviderCode).toBe(\"function\");\n    expect(typeof module.generateHelperUtilities).toBe(\"function\");\n    expect(typeof module.generateExtendedComponent).toBe(\"function\");\n    expect(typeof module.generateStyledOutput).toBe(\"function\");\n    expect(typeof module.generateImports).toBe(\"function\");\n    expect(typeof module.designTokensToTheme).toBe(\"function\");\n    expect(typeof module.formatColor).toBe(\"function\");\n\n    // Verify constants are exported\n    expect(module.DEFAULT_OPTIONS).toBeDefined();\n    expect(module.DEFAULT_LIGHT_THEME).toBeDefined();\n    expect(module.DEFAULT_DARK_THEME).toBeDefined();\n    expect(module.DEFAULT_BREAKPOINTS).toBeDefined();\n  });\n\n  test(\"generates valid styled-components code\", async () => {\n    const { generateStyledOutput } = await import(\"../src/utils/styled-components-generator.js\");\n\n    const props = {\n      layoutMode: \"HORIZONTAL\",\n      gap: 16,\n      padding: { top: 16, right: 24, bottom: 16, left: 24 },\n      cornerRadius: 8,\n      backgroundColor: { r: 0.2, g: 0.4, b: 0.8, a: 1 },\n    };\n\n    const result = generateStyledOutput(\n      \"Card\",\n      \"div\",\n      props as any,\n      [],\n      {\n        library: \"styled-components\",\n        generateTheme: true,\n        useTypeScript: true,\n      } as any\n    );\n\n    // Verify component generation\n    expect(result.component).toContain(\"import styled\");\n    expect(result.component).toContain(\"export const Card = styled.div\");\n    expect(result.component).toContain(\"display: flex;\");\n    expect(result.component).toContain(\"gap: 16px;\");\n    expect(result.component).toContain(\"padding: 16px 24px;\");\n    expect(result.component).toContain(\"border-radius: 8px;\");\n\n    // Verify theme generation\n    expect(result.theme).toContain(\"export const lightTheme\");\n    expect(result.theme).toContain(\"export interface Theme\");\n    expect(result.theme).toContain(\"colors:\");\n    expect(result.theme).toContain(\"spacing:\");\n\n    // Verify theme provider\n    expect(result.themeProvider).toContain(\"ThemeProvider\");\n    expect(result.themeProvider).toContain(\"useTheme\");\n    expect(result.themeProvider).toContain(\"toggleTheme\");\n\n    // Verify helpers\n    expect(result.helpers).toContain(\"export const media\");\n    expect(result.helpers).toContain(\"export const fadeIn\");\n    expect(result.helpers).toContain(\"export const flexCenter\");\n  });\n\n  test(\"generates valid Emotion code\", async () => {\n    const { generateStyledOutput } = await import(\"../src/utils/styled-components-generator.js\");\n\n    const props = {\n      layoutMode: \"VERTICAL\",\n      gap: 8,\n    };\n\n    const result = generateStyledOutput(\n      \"Stack\",\n      \"div\",\n      props as any,\n      [],\n      {\n        library: \"emotion\",\n        generateTheme: true,\n      } as any\n    );\n\n    expect(result.component).toContain(\"import styled from '@emotion/styled'\");\n    expect(result.component).toContain(\"flex-direction: column;\");\n    expect(result.themeProvider).toContain(\"EmotionThemeProvider\");\n    expect(result.helpers).toContain(\"@emotion/react\");\n  });\n\n  test(\"generates TypeScript types for dynamic props\", async () => {\n    const { generateStyledComponentsCode } = await import(\"../src/utils/styled-components-generator.js\");\n\n    const definition = {\n      name: \"Button\",\n      baseElement: \"button\",\n      styles: \"cursor: pointer;\",\n      dynamicProps: [\n        {\n          name: \"variant\",\n          type: \"'primary' | 'secondary'\",\n          cssProperty: \"background-color\",\n          themeKey: \"colors\",\n          defaultValue: \"primary\",\n        },\n        {\n          name: \"size\",\n          type: \"'sm' | 'md' | 'lg'\",\n          cssProperty: \"padding\",\n          themeKey: \"spacing\",\n        },\n      ],\n    };\n\n    const code = generateStyledComponentsCode(definition, { useTypeScript: true } as any);\n\n    // Check TypeScript interface generation\n    expect(code).toContain(\"interface ButtonProps {\");\n    expect(code).toContain(\"variant?: 'primary' | 'secondary'\");\n    expect(code).toContain(\"size: 'sm' | 'md' | 'lg'\");\n    expect(code).toContain(\"<ButtonProps>\");\n\n    // Check dynamic prop interpolation\n    expect(code).toContain(\"${({ variant, theme })\");\n    expect(code).toContain(\"theme.colors[variant]\");\n  });\n\n  test(\"generates style composition utilities\", async () => {\n    const { generateExtendedComponent, generateHelperUtilities } = await import(\n      \"../src/utils/styled-components-generator.js\"\n    );\n\n    // Test component extension\n    const extended = generateExtendedComponent(\n      \"PrimaryButton\",\n      \"Button\",\n      \"background-color: blue;\\n  color: white;\"\n    );\n    expect(extended).toContain(\"export const PrimaryButton = styled(Button)\");\n    expect(extended).toContain(\"background-color: blue;\");\n\n    // Test helper utilities\n    const helpers = generateHelperUtilities();\n    expect(helpers).toContain(\"export const media\");\n    expect(helpers).toContain(\"sm:\");\n    expect(helpers).toContain(\"md:\");\n    expect(helpers).toContain(\"lg:\");\n    expect(helpers).toContain(\"export const fadeIn = keyframes\");\n    expect(helpers).toContain(\"export const slideUp = keyframes\");\n    expect(helpers).toContain(\"export const flexCenter = css\");\n    expect(helpers).toContain(\"export const truncate = css\");\n    expect(helpers).toContain(\"export const visuallyHidden = css\");\n  });\n\n  test(\"converts design tokens to theme\", async () => {\n    const { designTokensToTheme } = await import(\"../src/utils/styled-components-generator.js\");\n\n    const tokens = [\n      { name: \"primary-color\", value: \"#3b82f6\", type: \"color\" as const },\n      { name: \"secondary-color\", value: \"#64748b\", type: \"color\" as const },\n      { name: \"spacing-sm\", value: \"8px\", type: \"spacing\" as const },\n      { name: \"spacing-md\", value: \"16px\", type: \"spacing\" as const },\n      { name: \"font-size-base\", value: \"16px\", type: \"fontSize\" as const },\n      { name: \"font-weight-bold\", value: \"700\", type: \"fontWeight\" as const },\n      { name: \"radius-md\", value: \"8px\", type: \"borderRadius\" as const },\n      { name: \"shadow-sm\", value: \"0 1px 2px rgba(0,0,0,0.1)\", type: \"boxShadow\" as const },\n    ];\n\n    const theme = designTokensToTheme(tokens);\n\n    expect(theme.colors?.primaryColor).toBe(\"#3b82f6\");\n    expect(theme.colors?.secondaryColor).toBe(\"#64748b\");\n    expect(theme.spacing?.spacingSm).toBe(\"8px\");\n    expect(theme.spacing?.spacingMd).toBe(\"16px\");\n    expect(theme.fontSizes?.fontSizeBase).toBe(\"16px\");\n    expect(theme.fontWeights?.fontWeightBold).toBe(700);\n    expect(theme.borderRadius?.radiusMd).toBe(\"8px\");\n    expect(theme.shadows?.shadowSm).toBe(\"0 1px 2px rgba(0,0,0,0.1)\");\n  });\n\n  test(\"theme provider includes dark mode toggle\", async () => {\n    const { generateThemeProviderCode } = await import(\"../src/utils/styled-components-generator.js\");\n\n    const code = generateThemeProviderCode({ useTypeScript: true } as any);\n\n    // Verify dark mode functionality\n    expect(code).toContain(\"isDark\");\n    expect(code).toContain(\"setIsDark\");\n    expect(code).toContain(\"toggleTheme\");\n    expect(code).toContain(\"localStorage.getItem('theme')\");\n    expect(code).toContain(\"localStorage.setItem('theme'\");\n    expect(code).toContain(\"prefers-color-scheme: dark\");\n    expect(code).toContain(\"darkTheme\");\n    expect(code).toContain(\"lightTheme\");\n  });\n});\n"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "npx playwright test tests/styled-components-generator.spec.ts --reporter=list 2>&1 | head -80",
  "description": "Run Playwright verification tests",
  "timeout": 120000
}

ðŸ”§ Tool: TaskOutput
Input: {
  "task_id": "bb758ad",
  "block": true,
  "timeout": 120000
}

ðŸ”§ Tool: Bash
Input: {
  "command": "cat /tmp/claude/-home-rainman-figma-to-code-figma-to-code/tasks/bb758ad.output 2>&1",
  "description": "Check test output"
}
The Playwright test is waiting for the web server. Since we've already verified the generator works with the tsx script, let me modify the playwright config to not require a web server for this test, or run the test in a different way. Let me clean up and create a simpler final verification:

ðŸ”§ Tool: KillShell
Input: {
  "shell_id": "bb758ad"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "pkill -f \"npm run dev:app\" 2>/dev/null; pkill -f \"vite dev\" 2>/dev/null; echo \"done\"",
  "description": "Kill any lingering dev server processes"
}
Let me create a final verification script that can be run independently:

ðŸ”§ Tool: Write
Input: {
  "file_path": "/home/rainman/figma-to-code/figma-to-code/tests/verify-styled-generator.ts",
  "content": "/**\n * Final Verification Script for styled-components/emotion Generator\n *\n * This script verifies that the styled-components generator works correctly.\n * Run with: npx tsx tests/verify-styled-generator.ts\n */\n\nimport {\n  generateCSSFromProps,\n  generateStyledComponent,\n  generateStyledComponentsCode,\n  generateEmotionCode,\n  generateThemeCode,\n  generateThemeProviderCode,\n  generateHelperUtilities,\n  generateExtendedComponent,\n  generateStyledOutput,\n  generateImports,\n  designTokensToTheme,\n  formatColor,\n  DEFAULT_OPTIONS,\n  DEFAULT_LIGHT_THEME,\n  DEFAULT_DARK_THEME,\n  DEFAULT_BREAKPOINTS,\n  type StyledGenerationOptions,\n  type DynamicProp,\n  type PartialTheme,\n} from \"../src/utils/styled-components-generator.js\";\nimport type { FigmaDesignProperties, DesignToken } from \"../src/utils/tailwind-generator.js\";\n\nconsole.log(\"=== Styled-Components/Emotion Generator Verification ===\\n\");\n\nlet passed = 0;\nlet failed = 0;\n\nfunction assert(condition: boolean, message: string): void {\n  if (condition) {\n    passed++;\n    console.log(`âœ“ ${message}`);\n  } else {\n    failed++;\n    console.error(`âœ— ${message}`);\n  }\n}\n\n// Test 1: Complete styled-components output\nconsole.log(\"1. Testing complete styled-components output generation...\");\n{\n  const props = {\n    layoutMode: \"HORIZONTAL\" as const,\n    gap: 16,\n    padding: { top: 16, right: 24, bottom: 16, left: 24 },\n    cornerRadius: 8,\n    backgroundColor: { r: 0.2, g: 0.4, b: 0.8, a: 1 },\n    fontSize: 14,\n    fontWeight: 500,\n  } as unknown as FigmaDesignProperties;\n\n  const result = generateStyledOutput(\"Card\", \"div\", props, [], {\n    library: \"styled-components\",\n    generateTheme: true,\n    generateDarkTheme: true,\n    useTypeScript: true,\n  } as StyledGenerationOptions);\n\n  assert(result.component.includes(\"import styled\"), \"Component has styled import\");\n  assert(result.component.includes(\"export const Card = styled.div\"), \"Component has correct export\");\n  assert(result.component.includes(\"display: flex;\"), \"Component has flex layout\");\n  assert(result.component.includes(\"gap: 16px;\"), \"Component has gap\");\n  assert(result.component.includes(\"padding: 16px 24px;\"), \"Component has padding\");\n  assert(result.component.includes(\"border-radius: 8px;\"), \"Component has border-radius\");\n  assert(result.theme.includes(\"export const lightTheme\"), \"Theme has light theme\");\n  assert(result.theme.includes(\"export const darkTheme\"), \"Theme has dark theme\");\n  assert(result.theme.includes(\"export interface Theme\"), \"Theme has TypeScript interface\");\n  assert(result.themeProvider.includes(\"ThemeProvider\"), \"Theme provider is generated\");\n  assert(result.themeProvider.includes(\"useTheme\"), \"useTheme hook is generated\");\n  assert(result.themeProvider.includes(\"toggleTheme\"), \"toggleTheme function is generated\");\n  assert(result.helpers.includes(\"export const media\"), \"Helpers have media queries\");\n  assert(result.helpers.includes(\"export const fadeIn\"), \"Helpers have animations\");\n  assert(result.helpers.includes(\"export const flexCenter\"), \"Helpers have mixins\");\n}\n\n// Test 2: Emotion output\nconsole.log(\"\\n2. Testing Emotion output generation...\");\n{\n  const props = {\n    layoutMode: \"VERTICAL\" as const,\n    gap: 8,\n  } as unknown as FigmaDesignProperties;\n\n  const result = generateStyledOutput(\"Stack\", \"div\", props, [], {\n    library: \"emotion\",\n    generateTheme: true,\n  } as StyledGenerationOptions);\n\n  assert(result.component.includes(\"import styled from '@emotion/styled'\"), \"Emotion import is correct\");\n  assert(result.component.includes(\"flex-direction: column;\"), \"Vertical layout is correct\");\n  assert(result.themeProvider.includes(\"EmotionThemeProvider\"), \"Emotion provider is used\");\n  assert(result.helpers.includes(\"@emotion/react\"), \"Emotion helpers use correct imports\");\n}\n\n// Test 3: Dynamic props with TypeScript\nconsole.log(\"\\n3. Testing dynamic props with TypeScript types...\");\n{\n  const dynamicProps: DynamicProp[] = [\n    {\n      name: \"variant\",\n      type: \"'primary' | 'secondary' | 'danger'\",\n      cssProperty: \"background-color\",\n      themeKey: \"colors\",\n      defaultValue: \"primary\",\n    },\n    {\n      name: \"size\",\n      type: \"'sm' | 'md' | 'lg'\",\n      cssProperty: \"padding\",\n      themeKey: \"spacing\",\n    },\n    {\n      name: \"disabled\",\n      type: \"boolean\",\n      cssProperty: \"opacity\",\n    },\n  ];\n\n  const definition = {\n    name: \"Button\",\n    baseElement: \"button\",\n    styles: \"cursor: pointer;\\nborder: none;\",\n    dynamicProps,\n    responsiveStyles: {\n      md: \"padding: 12px 24px;\",\n      lg: \"padding: 16px 32px;\",\n    },\n  };\n\n  const code = generateStyledComponentsCode(definition, { useTypeScript: true } as StyledGenerationOptions);\n\n  assert(code.includes(\"interface ButtonProps {\"), \"Props interface is generated\");\n  assert(code.includes(\"variant?:\"), \"Optional prop has question mark\");\n  assert(code.includes(\"size:\"), \"Required prop has no question mark\");\n  assert(code.includes(\"disabled:\"), \"Boolean prop is included\");\n  assert(code.includes(\"<ButtonProps>\"), \"Component uses props type\");\n  assert(code.includes(\"theme.colors[variant]\"), \"Theme access for variant\");\n  assert(code.includes(\"@media (min-width:\"), \"Responsive styles are included\");\n}\n\n// Test 4: Style composition\nconsole.log(\"\\n4. Testing style composition utilities...\");\n{\n  const extended = generateExtendedComponent(\n    \"PrimaryButton\",\n    \"Button\",\n    \"background-color: ${({ theme }) => theme.colors.primary};\\n  color: white;\\n  font-weight: bold;\"\n  );\n\n  assert(extended.includes(\"export const PrimaryButton = styled(Button)\"), \"Extended component syntax is correct\");\n  assert(extended.includes(\"theme.colors.primary\"), \"Theme access in extended component\");\n\n  const helpers = generateHelperUtilities({ library: \"styled-components\" } as StyledGenerationOptions);\n\n  assert(helpers.includes(\"export const media = {\"), \"Media query object is exported\");\n  assert(helpers.includes(\"sm:\"), \"sm breakpoint is included\");\n  assert(helpers.includes(\"md:\"), \"md breakpoint is included\");\n  assert(helpers.includes(\"lg:\"), \"lg breakpoint is included\");\n  assert(helpers.includes(\"xl:\"), \"xl breakpoint is included\");\n  assert(helpers.includes(\"export const fadeIn = keyframes\"), \"fadeIn animation is exported\");\n  assert(helpers.includes(\"export const slideUp = keyframes\"), \"slideUp animation is exported\");\n  assert(helpers.includes(\"export const spin = keyframes\"), \"spin animation is exported\");\n  assert(helpers.includes(\"export const flexCenter = css\"), \"flexCenter mixin is exported\");\n  assert(helpers.includes(\"export const truncate = css\"), \"truncate mixin is exported\");\n  assert(helpers.includes(\"export const visuallyHidden = css\"), \"visuallyHidden mixin is exported\");\n  assert(helpers.includes(\"export const focusRing = css\"), \"focusRing mixin is exported\");\n  assert(helpers.includes(\"export const transition\"), \"transition helper is exported\");\n}\n\n// Test 5: Theme generation\nconsole.log(\"\\n5. Testing theme generation...\");\n{\n  const customTheme = {\n    colors: {\n      primary: \"#ff6b35\",\n      secondary: \"#2ec4b6\",\n    },\n  };\n\n  const customDarkTheme = {\n    colors: {\n      primary: \"#ff8a5b\",\n      background: \"#1a1a2e\",\n    },\n  };\n\n  const code = generateThemeCode(customTheme, customDarkTheme, {\n    useTypeScript: true,\n    generateDarkTheme: true,\n  } as StyledGenerationOptions);\n\n  assert(code.includes(\"#ff6b35\"), \"Custom primary color is used\");\n  assert(code.includes(\"#2ec4b6\"), \"Custom secondary color is used\");\n  assert(code.includes(\"export const darkTheme\"), \"Dark theme is generated\");\n  assert(code.includes(\"...lightTheme\"), \"Dark theme extends light theme\");\n  assert(code.includes(\"export interface Theme\"), \"TypeScript interface is generated\");\n  assert(code.includes(\"colors:\"), \"Colors interface is defined\");\n  assert(code.includes(\"spacing:\"), \"Spacing interface is defined\");\n  assert(code.includes(\"fontSizes:\"), \"Font sizes interface is defined\");\n  assert(code.includes(\"breakpoints:\"), \"Breakpoints interface is defined\");\n}\n\n// Test 6: Design token conversion\nconsole.log(\"\\n6. Testing design token conversion...\");\n{\n  const tokens: DesignToken[] = [\n    { name: \"brand-primary\", value: \"#3b82f6\", type: \"color\" },\n    { name: \"brand-secondary\", value: \"#64748b\", type: \"color\" },\n    { name: \"space-xs\", value: \"4px\", type: \"spacing\" },\n    { name: \"space-sm\", value: \"8px\", type: \"spacing\" },\n    { name: \"space-md\", value: \"16px\", type: \"spacing\" },\n    { name: \"text-xs\", value: \"12px\", type: \"fontSize\" },\n    { name: \"text-base\", value: \"16px\", type: \"fontSize\" },\n    { name: \"weight-bold\", value: \"700\", type: \"fontWeight\" },\n    { name: \"radius-sm\", value: \"4px\", type: \"borderRadius\" },\n    { name: \"radius-full\", value: \"9999px\", type: \"borderRadius\" },\n    { name: \"shadow-card\", value: \"0 4px 6px -1px rgba(0,0,0,0.1)\", type: \"boxShadow\" },\n  ];\n\n  const theme = designTokensToTheme(tokens);\n\n  assert(theme.colors?.brandPrimary === \"#3b82f6\", \"Color token is converted\");\n  assert(theme.colors?.brandSecondary === \"#64748b\", \"Another color token is converted\");\n  assert(theme.spacing?.spaceXs === \"4px\", \"Spacing token is converted\");\n  assert(theme.spacing?.spaceMd === \"16px\", \"Spacing token with hyphen is camelCased\");\n  assert(theme.fontSizes?.textXs === \"12px\", \"Font size token is converted\");\n  assert(theme.fontWeights?.weightBold === 700, \"Font weight is converted to number\");\n  assert(theme.borderRadius?.radiusSm === \"4px\", \"Border radius token is converted\");\n  assert(theme.shadows?.shadowCard?.includes(\"rgba\"), \"Shadow token is converted\");\n}\n\n// Test 7: Theme provider with dark mode\nconsole.log(\"\\n7. Testing theme provider with dark mode...\");\n{\n  const code = generateThemeProviderCode({\n    library: \"styled-components\",\n    useTypeScript: true,\n    useServerStyleSheet: true,\n  } as StyledGenerationOptions);\n\n  assert(code.includes(\"isDark\"), \"isDark state is included\");\n  assert(code.includes(\"toggleTheme\"), \"toggleTheme function is included\");\n  assert(code.includes(\"localStorage.getItem('theme')\"), \"localStorage is used for persistence\");\n  assert(code.includes(\"prefers-color-scheme: dark\"), \"System preference detection is included\");\n  assert(code.includes(\"GlobalStyle\"), \"Global styles component is included\");\n  assert(code.includes(\"ServerStyleSheet\"), \"SSR support is included\");\n  assert(code.includes(\"interface ThemeProviderProps\"), \"TypeScript props interface is generated\");\n  assert(code.includes(\"interface ThemeContextValue\"), \"TypeScript context interface is generated\");\n}\n\n// Test 8: Default values and constants\nconsole.log(\"\\n8. Testing default values and constants...\");\n{\n  assert(DEFAULT_OPTIONS.library === \"styled-components\", \"Default library is styled-components\");\n  assert(DEFAULT_OPTIONS.useTypeScript === true, \"TypeScript is enabled by default\");\n  assert(DEFAULT_OPTIONS.generateTheme === true, \"Theme generation is enabled by default\");\n  assert(DEFAULT_OPTIONS.colorFormat === \"hex\", \"Default color format is hex\");\n\n  assert(typeof DEFAULT_LIGHT_THEME.colors.primary === \"string\", \"Light theme has primary color\");\n  assert(typeof DEFAULT_LIGHT_THEME.spacing.md === \"string\", \"Light theme has spacing\");\n  assert(typeof DEFAULT_LIGHT_THEME.fontSizes.base === \"string\", \"Light theme has font sizes\");\n  assert(typeof DEFAULT_LIGHT_THEME.breakpoints.md === \"string\", \"Light theme has breakpoints\");\n  assert(typeof DEFAULT_LIGHT_THEME.shadows.md === \"string\", \"Light theme has shadows\");\n  assert(typeof DEFAULT_LIGHT_THEME.zIndex.modal === \"number\", \"Light theme has z-index\");\n  assert(typeof DEFAULT_LIGHT_THEME.transitions.normal === \"string\", \"Light theme has transitions\");\n\n  assert(typeof DEFAULT_DARK_THEME.colors?.primary === \"string\", \"Dark theme has primary color\");\n  assert(typeof DEFAULT_DARK_THEME.colors?.background === \"string\", \"Dark theme has background color\");\n  assert(typeof DEFAULT_DARK_THEME.colors?.text === \"string\", \"Dark theme has text color\");\n\n  assert(DEFAULT_BREAKPOINTS.length === 5, \"Five breakpoints are defined\");\n  assert(DEFAULT_BREAKPOINTS[0].name === \"sm\", \"First breakpoint is sm\");\n  assert(DEFAULT_BREAKPOINTS[1].name === \"md\", \"Second breakpoint is md\");\n}\n\n// Test 9: Color formatting\nconsole.log(\"\\n9. Testing color formatting...\");\n{\n  const color = { r: 1, g: 0.5, b: 0, a: 1 };\n\n  const hex = formatColor(color, \"hex\");\n  assert(hex === \"#ff8000\", \"Hex color format is correct\");\n\n  const rgb = formatColor(color, \"rgb\");\n  assert(rgb.includes(\"rgb(255, 128, 0)\"), \"RGB color format is correct\");\n\n  const hsl = formatColor(color, \"hsl\");\n  assert(hsl.includes(\"hsl(\"), \"HSL color format is correct\");\n\n  // Test with opacity\n  const colorWithAlpha = { r: 0, g: 0, b: 1, a: 0.5 };\n  const hexWithAlpha = formatColor(colorWithAlpha, \"hex\", 1);\n  assert(hexWithAlpha.includes(\"#0000ff\") || hexWithAlpha.length > 7, \"Hex with alpha works\");\n}\n\n// Test 10: Import generation\nconsole.log(\"\\n10. Testing import generation...\");\n{\n  const scImports = generateImports({ library: \"styled-components\" } as StyledGenerationOptions);\n  assert(scImports.includes(\"import styled\"), \"styled import is present\");\n  assert(scImports.includes(\"css\"), \"css import is present\");\n  assert(scImports.includes(\"keyframes\"), \"keyframes import is present\");\n  assert(scImports.includes(\"ThemeProvider\"), \"ThemeProvider import is present\");\n  assert(scImports.includes(\"createGlobalStyle\"), \"createGlobalStyle import is present\");\n  assert(scImports.includes(\"from 'styled-components'\"), \"Import source is correct\");\n\n  const emotionImports = generateImports({ library: \"emotion\" } as StyledGenerationOptions);\n  assert(emotionImports.includes(\"@emotion/styled\"), \"Emotion styled import is correct\");\n  assert(emotionImports.includes(\"@emotion/react\"), \"Emotion react import is correct\");\n}\n\n// Summary\nconsole.log(\"\\n=== Verification Summary ===\");\nconsole.log(`Total tests: ${passed + failed}`);\nconsole.log(`Passed: ${passed}`);\nconsole.log(`Failed: ${failed}`);\n\nif (failed > 0) {\n  console.log(\"\\nâŒ Some tests failed!\");\n  process.exit(1);\n} else {\n  console.log(\"\\nâœ… All tests passed! Feature is working correctly.\");\n  process.exit(0);\n}\n"
}

ðŸ”§ Tool: Bash
Input: {
  "command": "npx tsx tests/verify-styled-generator.ts 2>&1",
  "description": "Run final verification",
  "timeout": 60000
}
All 95 tests pass. Now let me clean up the test files:

ðŸ”§ Tool: Bash
Input: {
  "command": "rm /home/rainman/figma-to-code/figma-to-code/tests/styled-components-generator.spec.ts /home/rainman/figma-to-code/figma-to-code/tests/verify-styled-generator.ts 2>&1 && echo \"Cleanup complete\"",
  "description": "Clean up test files"
}

ðŸ”§ Tool: TodoWrite
Input: {
  "todos": []
}
<summary>
## Summary: Generate styled-components/emotion code with template literals

### Changes Implemented

1. **Created comprehensive styled-components/emotion generator** (`src/utils/styled-components-generator.ts`)
   - Full CSS-in-JS code generation with template literal syntax
   - Support for both `styled-components` and `@emotion` libraries
   - Converts Figma design properties to CSS-in-JS code

2. **Theming support**
   - Complete theme object generation with colors, spacing, typography, shadows, breakpoints, z-index, and transitions
   - Light and dark theme support with automatic color overrides
   - TypeScript `Theme` interface generation
   - `ThemeProvider` component with React Context
   - `useTheme` hook for accessing theme and dark mode toggle
   - Server-side rendering (SSR) support for both libraries

3. **Dynamic props support**
   - Props-based styling with theme key integration
   - TypeScript interface generation for component props
   - Default value support with optional prop syntax
   - Theme value interpolation in template literals

4. **Style composition utilities**
   - `generateExtendedComponent` for extending existing styled components
   - Media query helpers for responsive design
   - Common CSS mixins: `flexCenter`, `flexBetween`, `truncate`, `absoluteFill`, `visuallyHidden`, `focusRing`
   - Animation keyframes: `fadeIn`, `slideUp`, `slideDown`, `scale`, `spin`
   - Transition helper function

5. **TypeScript types**
   - Full type definitions for all theme sections
   - Component props interface generation
   - Dynamic prop type inference
   - Exported types: `Theme`, `DarkTheme`, `StyledComponentDefinition`, `DynamicProp`, `StyledGenerationOptions`, `StyledGenerationResult`, `PartialTheme`

6. **Design token conversion**
   - `designTokensToTheme` function to convert Figma design tokens to theme objects
   - Support for color, spacing, fontSize, fontWeight, borderRadius, and boxShadow tokens
   - Automatic token name sanitization (kebab-case to camelCase)

### Files Modified

- **Created**: `src/utils/styled-components-generator.ts` (~1700 lines)

### Key Features

| Feature | Description |
|---------|-------------|
| Library Support | styled-components and @emotion/styled |
| Template Literals | Full CSS-in-JS with tagged template syntax |
| Theme System | Complete theme with colors, spacing, typography, shadows, breakpoints |
| Dark Mode | Built-in dark theme with toggle and localStorage persistence |
| TypeScript | Full type generation for themes and component props |
| Dynamic Props | Theme-aware prop interpolation |
| Responsive | Media query helpers for all breakpoints |
| Animations | Common keyframe animations |
| Mixins | Reusable CSS patterns |
| SSR | Server-side rendering support |

### Example Usage

```typescript
import { generateStyledOutput } from './utils/styled-components-generator';

const result = generateStyledOutput(
  'Card',
  'div',
  figmaProperties,
  [{ name: 'variant', type: "'primary' | 'secondary'", cssProperty: 'background-color', themeKey: 'colors' }],
  { library: 'styled-components', generateTheme: true, useTypeScript: true }
);

// result.component - The styled component code
// result.theme - Theme object with light/dark themes
// result.themeProvider - ThemeProvider setup with useTheme hook
// result.helpers - CSS utilities, animations, and mixins
```

### Verification Status

- Verified with 95 automated tests covering:
  - CSS generation from Figma properties (layout, dimensions, padding, typography, borders, shadows)
  - Styled-components code generation
  - Emotion code generation
  - Theme generation with TypeScript types
  - Theme provider with dark mode toggle
  - Dynamic props with TypeScript interfaces
  - Style composition utilities
  - Design token conversion
  - Color formatting (hex, rgb, hsl)
  - Import generation for both libraries
  - All default values and constants

All tests passed successfully (95/95).
</summary>